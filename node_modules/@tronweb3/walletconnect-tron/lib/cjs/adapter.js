"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnectWallet = exports.WalletConnectMethods = exports.WalletConnectChainID = void 0;
const modal_1 = require("@walletconnect/modal");
const sign_client_1 = __importDefault(require("@walletconnect/sign-client"));
const utils_1 = require("@walletconnect/utils");
const errors_js_1 = require("./errors.js");
var WalletConnectChainID;
(function (WalletConnectChainID) {
    WalletConnectChainID["Mainnet"] = "tron:0x2b6653dc";
    WalletConnectChainID["Shasta"] = "tron:0x94a9059e";
    WalletConnectChainID["Nile"] = "tron:0xcd8690dc";
})(WalletConnectChainID = exports.WalletConnectChainID || (exports.WalletConnectChainID = {}));
var WalletConnectMethods;
(function (WalletConnectMethods) {
    WalletConnectMethods["signTransaction"] = "tron_signTransaction";
    WalletConnectMethods["signMessage"] = "tron_signMessage";
})(WalletConnectMethods = exports.WalletConnectMethods || (exports.WalletConnectMethods = {}));
const getConnectParams = (chainId, pairingTopic) => ({
    requiredNamespaces: {
        tron: {
            chains: [chainId],
            methods: [WalletConnectMethods.signTransaction, WalletConnectMethods.signMessage],
            events: []
        }
    },
    pairingTopic: pairingTopic
});
class WalletConnectWallet {
    constructor(config) {
        this._options = config.options;
        this._network = config.network;
        this._modalConfig = config.web3ModalConfig || {};
        this.web3Modal = new modal_1.WalletConnectModal(Object.assign(Object.assign({}, this._modalConfig), { projectId: this._options.projectId, chains: [this._network, ...(this._modalConfig.chains || [])] }));
    }
    connect() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const client = (_a = this._client) !== null && _a !== void 0 ? _a : (yield sign_client_1.default.init(this._options));
            const sessions = client.find(getConnectParams(this._network)).filter(s => s.acknowledged);
            if (sessions.length) {
                // select last matching session
                this._session = sessions[sessions.length - 1];
                // We assign this variable only after we're sure we've received approval
                this._client = client;
                this._client = client;
                const accounts = Object.values(this._session.namespaces)
                    .map(namespace => namespace.accounts)
                    .flat();
                this.address = accounts[0].split(':')[2];
                return {
                    address: this.address
                };
            }
            else {
                const { uri, approval } = yield client.connect(getConnectParams(this._network));
                return new Promise((resolve, reject) => {
                    if (uri) {
                        this.web3Modal.openModal({
                            uri,
                            chains: [this._network],
                        });
                        this.web3Modal.subscribeModal((state) => {
                            if (state.open === false) {
                                reject(new errors_js_1.Web3ModalError('Modal is closed.'));
                            }
                        });
                    }
                    approval()
                        .then(session => {
                        this._session = session;
                        // We assign this variable only after we're sure we've received approval
                        this._client = client;
                        const accounts = Object.values(this._session.namespaces)
                            .map(namespace => namespace.accounts)
                            .flat();
                        this.address = accounts[0].split(':')[2];
                        resolve({ address: this.address });
                    })
                        .catch(reject)
                        .finally(() => {
                        this.web3Modal.closeModal();
                    });
                });
            }
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._client && this._session) {
                yield this._client.disconnect({
                    topic: this._session.topic,
                    reason: (0, utils_1.getSdkError)('USER_DISCONNECTED')
                });
                this._session = undefined;
            }
            else {
                throw new errors_js_1.ClientNotInitializedError();
            }
        });
    }
    get client() {
        if (this._client) {
            return Object.assign({}, this._client, { off: this._client.removeListener });
        }
        else {
            throw new errors_js_1.ClientNotInitializedError();
        }
    }
    checkConnectStatus() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const client = (_a = this._client) !== null && _a !== void 0 ? _a : (yield sign_client_1.default.init(this._options));
            const sessions = client.find(getConnectParams(this._network)).filter(s => s.acknowledged);
            if (sessions.length) {
                // select last matching session
                this._session = sessions[sessions.length - 1];
                // We assign this variable only after we're sure we've received approval
                this._client = client;
                const accounts = Object.values(this._session.namespaces)
                    .map(namespace => namespace.accounts)
                    .flat();
                this.address = accounts[0].split(':')[2];
                return {
                    address: this.address
                };
            }
            else {
                return {
                    address: ''
                };
            }
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._client && this._session) {
                const { result } = yield this._client.request({
                    chainId: this._network,
                    topic: this._session.topic,
                    request: {
                        method: WalletConnectMethods.signTransaction,
                        params: {
                            address: this.address,
                            transaction: Object.assign({}, transaction)
                        }
                    }
                });
                return result;
            }
            else {
                throw new errors_js_1.ClientNotInitializedError();
            }
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._client && this._session) {
                const { signature } = yield this._client.request({
                    chainId: this._network,
                    topic: this._session.topic,
                    request: {
                        method: WalletConnectMethods.signMessage,
                        params: {
                            address: this.address,
                            message
                        }
                    }
                });
                return signature;
            }
            else {
                throw new errors_js_1.ClientNotInitializedError();
            }
        });
    }
}
exports.WalletConnectWallet = WalletConnectWallet;
//# sourceMappingURL=adapter.js.map