import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-OS7ZSSJM.js";

// node_modules/validator/lib/util/assertString.js
var require_assertString = __commonJS({
  "node_modules/validator/lib/util/assertString.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assertString;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function assertString(input) {
      var isString3 = typeof input === "string" || input instanceof String;
      if (!isString3) {
        var invalidType = _typeof(input);
        if (input === null) invalidType = "null";
        else if (invalidType === "object") invalidType = input.constructor.name;
        throw new TypeError("Expected a string but received a ".concat(invalidType));
      }
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/toDate.js
var require_toDate = __commonJS({
  "node_modules/validator/lib/toDate.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toDate;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toDate(date) {
      (0, _assertString.default)(date);
      date = Date.parse(date);
      return !isNaN(date) ? new Date(date) : null;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/alpha.js
var require_alpha = __commonJS({
  "node_modules/validator/lib/alpha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.farsiLocales = exports.englishLocales = exports.dotDecimal = exports.decimal = exports.commaDecimal = exports.bengaliLocales = exports.arabicLocales = exports.alphanumeric = exports.alpha = void 0;
    var alpha = exports.alpha = {
      "en-US": /^[A-Z]+$/i,
      "az-AZ": /^[A-VXYZÇƏĞİıÖŞÜ]+$/i,
      "bg-BG": /^[А-Я]+$/i,
      "cs-CZ": /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      "da-DK": /^[A-ZÆØÅ]+$/i,
      "de-DE": /^[A-ZÄÖÜß]+$/i,
      "el-GR": /^[Α-ώ]+$/i,
      "es-ES": /^[A-ZÁÉÍÑÓÚÜ]+$/i,
      "fa-IR": /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i,
      "fi-FI": /^[A-ZÅÄÖ]+$/i,
      "fr-FR": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      "it-IT": /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
      "ja-JP": /^[ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
      "nb-NO": /^[A-ZÆØÅ]+$/i,
      "nl-NL": /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
      "nn-NO": /^[A-ZÆØÅ]+$/i,
      "hu-HU": /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      "pl-PL": /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      "pt-PT": /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
      "ru-RU": /^[А-ЯЁ]+$/i,
      "kk-KZ": /^[А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
      "sl-SI": /^[A-ZČĆĐŠŽ]+$/i,
      "sk-SK": /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      "sr-RS@latin": /^[A-ZČĆŽŠĐ]+$/i,
      "sr-RS": /^[А-ЯЂЈЉЊЋЏ]+$/i,
      "sv-SE": /^[A-ZÅÄÖ]+$/i,
      "th-TH": /^[ก-๐\s]+$/i,
      "tr-TR": /^[A-ZÇĞİıÖŞÜ]+$/i,
      "uk-UA": /^[А-ЩЬЮЯЄIЇҐі]+$/i,
      "vi-VN": /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
      "ko-KR": /^[ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
      "ku-IQ": /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
      he: /^[א-ת]+$/,
      fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i,
      bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
      eo: /^[ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
      "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
      "si-LK": /^[\u0D80-\u0DFF]+$/
    };
    var alphanumeric = exports.alphanumeric = {
      "en-US": /^[0-9A-Z]+$/i,
      "az-AZ": /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i,
      "bg-BG": /^[0-9А-Я]+$/i,
      "cs-CZ": /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      "da-DK": /^[0-9A-ZÆØÅ]+$/i,
      "de-DE": /^[0-9A-ZÄÖÜß]+$/i,
      "el-GR": /^[0-9Α-ω]+$/i,
      "es-ES": /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
      "fi-FI": /^[0-9A-ZÅÄÖ]+$/i,
      "fr-FR": /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      "it-IT": /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
      "ja-JP": /^[0-9０-９ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
      "hu-HU": /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      "nb-NO": /^[0-9A-ZÆØÅ]+$/i,
      "nl-NL": /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
      "nn-NO": /^[0-9A-ZÆØÅ]+$/i,
      "pl-PL": /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      "pt-PT": /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
      "ru-RU": /^[0-9А-ЯЁ]+$/i,
      "kk-KZ": /^[0-9А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
      "sl-SI": /^[0-9A-ZČĆĐŠŽ]+$/i,
      "sk-SK": /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      "sr-RS@latin": /^[0-9A-ZČĆŽŠĐ]+$/i,
      "sr-RS": /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
      "sv-SE": /^[0-9A-ZÅÄÖ]+$/i,
      "th-TH": /^[ก-๙\s]+$/i,
      "tr-TR": /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
      "uk-UA": /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
      "ko-KR": /^[0-9ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
      "ku-IQ": /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      "vi-VN": /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
      ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
      he: /^[0-9א-ת]+$/,
      fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i,
      bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣ০১২৩৪৫৬৭৮৯ৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
      eo: /^[0-9ABCĈD-GĜHĤIJĴK-PRSŜTUŬVZ]+$/i,
      "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
      "si-LK": /^[0-9\u0D80-\u0DFF]+$/
    };
    var decimal = exports.decimal = {
      "en-US": ".",
      ar: "٫"
    };
    var englishLocales = exports.englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
    for (i = 0; i < englishLocales.length; i++) {
      locale = "en-".concat(englishLocales[i]);
      alpha[locale] = alpha["en-US"];
      alphanumeric[locale] = alphanumeric["en-US"];
      decimal[locale] = decimal["en-US"];
    }
    var locale;
    var i;
    var arabicLocales = exports.arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
    for (_i = 0; _i < arabicLocales.length; _i++) {
      _locale = "ar-".concat(arabicLocales[_i]);
      alpha[_locale] = alpha.ar;
      alphanumeric[_locale] = alphanumeric.ar;
      decimal[_locale] = decimal.ar;
    }
    var _locale;
    var _i;
    var farsiLocales = exports.farsiLocales = ["IR", "AF"];
    for (_i2 = 0; _i2 < farsiLocales.length; _i2++) {
      _locale2 = "fa-".concat(farsiLocales[_i2]);
      alphanumeric[_locale2] = alphanumeric.fa;
      decimal[_locale2] = decimal.ar;
    }
    var _locale2;
    var _i2;
    var bengaliLocales = exports.bengaliLocales = ["BD", "IN"];
    for (_i3 = 0; _i3 < bengaliLocales.length; _i3++) {
      _locale3 = "bn-".concat(bengaliLocales[_i3]);
      alpha[_locale3] = alpha.bn;
      alphanumeric[_locale3] = alphanumeric.bn;
      decimal[_locale3] = decimal["en-US"];
    }
    var _locale3;
    var _i3;
    var dotDecimal = exports.dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
    var commaDecimal = exports.commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "eo", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
    for (_i4 = 0; _i4 < dotDecimal.length; _i4++) {
      decimal[dotDecimal[_i4]] = decimal["en-US"];
    }
    var _i4;
    for (_i5 = 0; _i5 < commaDecimal.length; _i5++) {
      decimal[commaDecimal[_i5]] = ",";
    }
    var _i5;
    alpha["fr-CA"] = alpha["fr-FR"];
    alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
    alpha["pt-BR"] = alpha["pt-PT"];
    alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
    decimal["pt-BR"] = decimal["pt-PT"];
    alpha["pl-Pl"] = alpha["pl-PL"];
    alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
    decimal["pl-Pl"] = decimal["pl-PL"];
    alpha["fa-AF"] = alpha.fa;
  }
});

// node_modules/validator/lib/isFloat.js
var require_isFloat = __commonJS({
  "node_modules/validator/lib/isFloat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isFloat;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isFloat(str, options) {
      (0, _assertString.default)(str);
      options = options || {};
      var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha.decimal[options.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
      if (str === "" || str === "." || str === "," || str === "-" || str === "+") {
        return false;
      }
      var value = parseFloat(str.replace(",", "."));
      return float.test(str) && (!options.hasOwnProperty("min") || value >= options.min) && (!options.hasOwnProperty("max") || value <= options.max) && (!options.hasOwnProperty("lt") || value < options.lt) && (!options.hasOwnProperty("gt") || value > options.gt);
    }
    var locales = exports.locales = Object.keys(_alpha.decimal);
  }
});

// node_modules/validator/lib/toFloat.js
var require_toFloat = __commonJS({
  "node_modules/validator/lib/toFloat.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toFloat;
    var _isFloat = _interopRequireDefault(require_isFloat());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toFloat(str) {
      if (!(0, _isFloat.default)(str)) return NaN;
      return parseFloat(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/toInt.js
var require_toInt = __commonJS({
  "node_modules/validator/lib/toInt.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toInt;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toInt(str, radix) {
      (0, _assertString.default)(str);
      return parseInt(str, radix || 10);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/toBoolean.js
var require_toBoolean = __commonJS({
  "node_modules/validator/lib/toBoolean.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toBoolean;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toBoolean(str, strict) {
      (0, _assertString.default)(str);
      if (strict) {
        return str === "1" || /^true$/i.test(str);
      }
      return str !== "0" && !/^false$/i.test(str) && str !== "";
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/equals.js
var require_equals = __commonJS({
  "node_modules/validator/lib/equals.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = equals;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function equals(str, comparison) {
      (0, _assertString.default)(str);
      return str === comparison;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/util/toString.js
var require_toString = __commonJS({
  "node_modules/validator/lib/util/toString.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toString4;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function toString4(input) {
      if (_typeof(input) === "object" && input !== null) {
        if (typeof input.toString === "function") {
          input = input.toString();
        } else {
          input = "[object Object]";
        }
      } else if (input === null || typeof input === "undefined" || isNaN(input) && !input.length) {
        input = "";
      }
      return String(input);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/util/merge.js
var require_merge = __commonJS({
  "node_modules/validator/lib/util/merge.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = merge2;
    function merge2() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var defaults2 = arguments.length > 1 ? arguments[1] : void 0;
      for (var key in defaults2) {
        if (typeof obj[key] === "undefined") {
          obj[key] = defaults2[key];
        }
      }
      return obj;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/contains.js
var require_contains = __commonJS({
  "node_modules/validator/lib/contains.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = contains;
    var _assertString = _interopRequireDefault(require_assertString());
    var _toString = _interopRequireDefault(require_toString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var defaulContainsOptions = {
      ignoreCase: false,
      minOccurrences: 1
    };
    function contains(str, elem, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaulContainsOptions);
      if (options.ignoreCase) {
        return str.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options.minOccurrences;
      }
      return str.split((0, _toString.default)(elem)).length > options.minOccurrences;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/matches.js
var require_matches = __commonJS({
  "node_modules/validator/lib/matches.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = matches;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function matches(str, pattern, modifiers) {
      (0, _assertString.default)(str);
      if (Object.prototype.toString.call(pattern) !== "[object RegExp]") {
        pattern = new RegExp(pattern, modifiers);
      }
      return !!str.match(pattern);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isByteLength.js
var require_isByteLength = __commonJS({
  "node_modules/validator/lib/isByteLength.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isByteLength;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function isByteLength(str, options) {
      (0, _assertString.default)(str);
      var min;
      var max;
      if (_typeof(options) === "object") {
        min = options.min || 0;
        max = options.max;
      } else {
        min = arguments[1];
        max = arguments[2];
      }
      var len = encodeURI(str).split(/%..|./).length - 1;
      return len >= min && (typeof max === "undefined" || len <= max);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isFQDN.js
var require_isFQDN = __commonJS({
  "node_modules/validator/lib/isFQDN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isFQDN;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_fqdn_options = {
      require_tld: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_numeric_tld: false,
      allow_wildcard: false,
      ignore_max_length: false
    };
    function isFQDN(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_fqdn_options);
      if (options.allow_trailing_dot && str[str.length - 1] === ".") {
        str = str.substring(0, str.length - 1);
      }
      if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
        str = str.substring(2);
      }
      var parts = str.split(".");
      var tld = parts[parts.length - 1];
      if (options.require_tld) {
        if (parts.length < 2) {
          return false;
        }
        if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
          return false;
        }
        if (/\s/.test(tld)) {
          return false;
        }
      }
      if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
        return false;
      }
      return parts.every(function(part) {
        if (part.length > 63 && !options.ignore_max_length) {
          return false;
        }
        if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
          return false;
        }
        if (/[\uff01-\uff5e]/.test(part)) {
          return false;
        }
        if (/^-|-$/.test(part)) {
          return false;
        }
        if (!options.allow_underscores && /_/.test(part)) {
          return false;
        }
        return true;
      });
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isIP.js
var require_isIP = __commonJS({
  "node_modules/validator/lib/isIP.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIP;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
    var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
    var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
    var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
    function isIP(str) {
      var version3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      (0, _assertString.default)(str);
      version3 = String(version3);
      if (!version3) {
        return isIP(str, 4) || isIP(str, 6);
      }
      if (version3 === "4") {
        return IPv4AddressRegExp.test(str);
      }
      if (version3 === "6") {
        return IPv6AddressRegExp.test(str);
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isEmail.js
var require_isEmail = __commonJS({
  "node_modules/validator/lib/isEmail.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isEmail;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isByteLength = _interopRequireDefault(require_isByteLength());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isIP = _interopRequireDefault(require_isIP());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_email_options = {
      allow_display_name: false,
      allow_underscores: false,
      require_display_name: false,
      allow_utf8_local_part: true,
      require_tld: true,
      blacklisted_chars: "",
      ignore_max_length: false,
      host_blacklist: [],
      host_whitelist: []
    };
    var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
    var gmailUserPart = /^[a-z\d]+$/;
    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
    var defaultMaxEmailLength = 254;
    function validateDisplayName(display_name) {
      var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
      if (!display_name_without_quotes.trim()) {
        return false;
      }
      var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
      if (contains_illegal) {
        if (display_name_without_quotes === display_name) {
          return false;
        }
        var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
        if (!all_start_with_back_slash) {
          return false;
        }
      }
      return true;
    }
    function isEmail(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_email_options);
      if (options.require_display_name || options.allow_display_name) {
        var display_email = str.match(splitNameAddress);
        if (display_email) {
          var display_name = display_email[1];
          str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
          if (display_name.endsWith(" ")) {
            display_name = display_name.slice(0, -1);
          }
          if (!validateDisplayName(display_name)) {
            return false;
          }
        } else if (options.require_display_name) {
          return false;
        }
      }
      if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
        return false;
      }
      var parts = str.split("@");
      var domain = parts.pop();
      var lower_domain = domain.toLowerCase();
      if (options.host_blacklist.includes(lower_domain)) {
        return false;
      }
      if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
        return false;
      }
      var user = parts.join("@");
      if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
        user = user.toLowerCase();
        var username = user.split("+")[0];
        if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
          min: 6,
          max: 30
        })) {
          return false;
        }
        var _user_parts = username.split(".");
        for (var i = 0; i < _user_parts.length; i++) {
          if (!gmailUserPart.test(_user_parts[i])) {
            return false;
          }
        }
      }
      if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
        max: 64
      }) || !(0, _isByteLength.default)(domain, {
        max: 254
      }))) {
        return false;
      }
      if (!(0, _isFQDN.default)(domain, {
        require_tld: options.require_tld,
        ignore_max_length: options.ignore_max_length,
        allow_underscores: options.allow_underscores
      })) {
        if (!options.allow_ip_domain) {
          return false;
        }
        if (!(0, _isIP.default)(domain)) {
          if (!domain.startsWith("[") || !domain.endsWith("]")) {
            return false;
          }
          var noBracketdomain = domain.slice(1, -1);
          if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
            return false;
          }
        }
      }
      if (user[0] === '"') {
        user = user.slice(1, user.length - 1);
        return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
      }
      var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
      var user_parts = user.split(".");
      for (var _i = 0; _i < user_parts.length; _i++) {
        if (!pattern.test(user_parts[_i])) {
          return false;
        }
      }
      if (options.blacklisted_chars) {
        if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), "g")) !== -1) return false;
      }
      return true;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isURL.js
var require_isURL = __commonJS({
  "node_modules/validator/lib/isURL.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isURL;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isIP = _interopRequireDefault(require_isIP());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n2, i, u, a = [], f2 = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f2 = false;
          } else for (; !(f2 = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f2 = true) ;
        } catch (r2) {
          o = true, n2 = r2;
        } finally {
          try {
            if (!f2 && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var default_url_options = {
      protocols: ["http", "https", "ftp"],
      require_tld: true,
      require_protocol: false,
      require_host: true,
      require_port: false,
      require_valid_protocol: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_protocol_relative_urls: false,
      allow_fragments: true,
      allow_query_components: true,
      validate_length: true
    };
    var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
    function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function checkHost(host, matches) {
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        if (host === match || isRegExp2(match) && match.test(host)) {
          return true;
        }
      }
      return false;
    }
    function isURL(url, options) {
      (0, _assertString.default)(url);
      if (!url || /[\s<>]/.test(url)) {
        return false;
      }
      if (url.indexOf("mailto:") === 0) {
        return false;
      }
      options = (0, _merge.default)(options, default_url_options);
      if (options.validate_length && url.length >= 2083) {
        return false;
      }
      if (!options.allow_fragments && url.includes("#")) {
        return false;
      }
      if (!options.allow_query_components && (url.includes("?") || url.includes("&"))) {
        return false;
      }
      var protocol, auth, host, hostname, port, port_str, split2, ipv6;
      split2 = url.split("#");
      url = split2.shift();
      split2 = url.split("?");
      url = split2.shift();
      split2 = url.split("://");
      if (split2.length > 1) {
        protocol = split2.shift().toLowerCase();
        if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
          return false;
        }
      } else if (options.require_protocol) {
        return false;
      } else if (url.slice(0, 2) === "//") {
        if (!options.allow_protocol_relative_urls) {
          return false;
        }
        split2[0] = url.slice(2);
      }
      url = split2.join("://");
      if (url === "") {
        return false;
      }
      split2 = url.split("/");
      url = split2.shift();
      if (url === "" && !options.require_host) {
        return true;
      }
      split2 = url.split("@");
      if (split2.length > 1) {
        if (options.disallow_auth) {
          return false;
        }
        if (split2[0] === "") {
          return false;
        }
        auth = split2.shift();
        if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
          return false;
        }
        var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
        if (user === "" && password === "") {
          return false;
        }
      }
      hostname = split2.join("@");
      port_str = null;
      ipv6 = null;
      var ipv6_match = hostname.match(wrapped_ipv6);
      if (ipv6_match) {
        host = "";
        ipv6 = ipv6_match[1];
        port_str = ipv6_match[2] || null;
      } else {
        split2 = hostname.split(":");
        host = split2.shift();
        if (split2.length) {
          port_str = split2.join(":");
        }
      }
      if (port_str !== null && port_str.length > 0) {
        port = parseInt(port_str, 10);
        if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
          return false;
        }
      } else if (options.require_port) {
        return false;
      }
      if (options.host_whitelist) {
        return checkHost(host, options.host_whitelist);
      }
      if (host === "" && !options.require_host) {
        return true;
      }
      if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
        return false;
      }
      host = host || ipv6;
      if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
        return false;
      }
      return true;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isMACAddress.js
var require_isMACAddress = __commonJS({
  "node_modules/validator/lib/isMACAddress.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMACAddress;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/;
    var macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;
    var macAddress48WithDots = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
    var macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/;
    var macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;
    var macAddress64WithDots = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
    function isMACAddress(str, options) {
      (0, _assertString.default)(str);
      if (options !== null && options !== void 0 && options.eui) {
        options.eui = String(options.eui);
      }
      if (options !== null && options !== void 0 && options.no_colons || options !== null && options !== void 0 && options.no_separators) {
        if (options.eui === "48") {
          return macAddress48NoSeparators.test(str);
        }
        if (options.eui === "64") {
          return macAddress64NoSeparators.test(str);
        }
        return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);
      }
      if ((options === null || options === void 0 ? void 0 : options.eui) === "48") {
        return macAddress48.test(str) || macAddress48WithDots.test(str);
      }
      if ((options === null || options === void 0 ? void 0 : options.eui) === "64") {
        return macAddress64.test(str) || macAddress64WithDots.test(str);
      }
      return isMACAddress(str, {
        eui: "48"
      }) || isMACAddress(str, {
        eui: "64"
      });
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isIPRange.js
var require_isIPRange = __commonJS({
  "node_modules/validator/lib/isIPRange.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIPRange;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isIP = _interopRequireDefault(require_isIP());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var subnetMaybe = /^\d{1,3}$/;
    var v4Subnet = 32;
    var v6Subnet = 128;
    function isIPRange(str) {
      var version3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      (0, _assertString.default)(str);
      var parts = str.split("/");
      if (parts.length !== 2) {
        return false;
      }
      if (!subnetMaybe.test(parts[1])) {
        return false;
      }
      if (parts[1].length > 1 && parts[1].startsWith("0")) {
        return false;
      }
      var isValidIP = (0, _isIP.default)(parts[0], version3);
      if (!isValidIP) {
        return false;
      }
      var expectedSubnet = null;
      switch (String(version3)) {
        case "4":
          expectedSubnet = v4Subnet;
          break;
        case "6":
          expectedSubnet = v6Subnet;
          break;
        default:
          expectedSubnet = (0, _isIP.default)(parts[0], "6") ? v6Subnet : v4Subnet;
      }
      return parts[1] <= expectedSubnet && parts[1] >= 0;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isDate.js
var require_isDate = __commonJS({
  "node_modules/validator/lib/isDate.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isDate2;
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n2, i, u, a = [], f2 = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f2 = false;
          } else for (; !(f2 = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f2 = true) ;
        } catch (r2) {
          o = true, n2 = r2;
        } finally {
          try {
            if (!f2 && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f2() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    var default_date_options = {
      format: "YYYY/MM/DD",
      delimiters: ["/", "-"],
      strictMode: false
    };
    function isValidFormat(format) {
      return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(format);
    }
    function zip(date, format) {
      var zippedArr = [], len = Math.min(date.length, format.length);
      for (var i = 0; i < len; i++) {
        zippedArr.push([date[i], format[i]]);
      }
      return zippedArr;
    }
    function isDate2(input, options) {
      if (typeof options === "string") {
        options = (0, _merge.default)({
          format: options
        }, default_date_options);
      } else {
        options = (0, _merge.default)(options, default_date_options);
      }
      if (typeof input === "string" && isValidFormat(options.format)) {
        var formatDelimiter = options.delimiters.find(function(delimiter) {
          return options.format.indexOf(delimiter) !== -1;
        });
        var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function(delimiter) {
          return input.indexOf(delimiter) !== -1;
        });
        var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));
        var dateObj = {};
        var _iterator = _createForOfIteratorHelper(dateAndFormat), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), dateWord = _step$value[0], formatWord = _step$value[1];
            if (dateWord.length !== formatWord.length) {
              return false;
            }
            dateObj[formatWord.charAt(0)] = dateWord;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var fullYear = dateObj.y;
        if (fullYear.startsWith("-")) {
          return false;
        }
        if (dateObj.y.length === 2) {
          var parsedYear = parseInt(dateObj.y, 10);
          if (isNaN(parsedYear)) {
            return false;
          }
          var currentYearLastTwoDigits = (/* @__PURE__ */ new Date()).getFullYear() % 100;
          if (parsedYear < currentYearLastTwoDigits) {
            fullYear = "20".concat(dateObj.y);
          } else {
            fullYear = "19".concat(dateObj.y);
          }
        }
        var month = dateObj.m;
        if (dateObj.m.length === 1) {
          month = "0".concat(dateObj.m);
        }
        var day = dateObj.d;
        if (dateObj.d.length === 1) {
          day = "0".concat(dateObj.d);
        }
        return new Date("".concat(fullYear, "-").concat(month, "-").concat(day, "T00:00:00.000Z")).getUTCDate() === +dateObj.d;
      }
      if (!options.strictMode) {
        return Object.prototype.toString.call(input) === "[object Date]" && isFinite(input);
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isTime.js
var require_isTime = __commonJS({
  "node_modules/validator/lib/isTime.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isTime;
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_time_options = {
      hourFormat: "hour24",
      mode: "default"
    };
    var formats = {
      hour24: {
        default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
        withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
      },
      hour12: {
        default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
        withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
      }
    };
    function isTime(input, options) {
      options = (0, _merge.default)(options, default_time_options);
      if (typeof input !== "string") return false;
      return formats[options.hourFormat][options.mode].test(input);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/validator/lib/isBoolean.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBoolean3;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var defaultOptions2 = {
      loose: false
    };
    var strictBooleans = ["true", "false", "1", "0"];
    var looseBooleans = [].concat(strictBooleans, ["yes", "no"]);
    function isBoolean3(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOptions2;
      (0, _assertString.default)(str);
      if (options.loose) {
        return looseBooleans.includes(str.toLowerCase());
      }
      return strictBooleans.includes(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isLocale.js
var require_isLocale = __commonJS({
  "node_modules/validator/lib/isLocale.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLocale;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var extlang = "([A-Za-z]{3}(-[A-Za-z]{3}){0,2})";
    var language = "(([a-zA-Z]{2,3}(-".concat(extlang, ")?)|([a-zA-Z]{5,8}))");
    var script = "([A-Za-z]{4})";
    var region = "([A-Za-z]{2}|\\d{3})";
    var variant = "([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))";
    var singleton = "(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])";
    var extension = "(".concat(singleton, "(-[A-Za-z0-9]{2,8})+)");
    var privateuse = "(x(-[A-Za-z0-9]{1,8})+)";
    var irregular = "((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))";
    var regular = "((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))";
    var grandfathered = "(".concat(irregular, "|").concat(regular, ")");
    var delimiter = "(-|_)";
    var langtag = "".concat(language, "(").concat(delimiter).concat(script, ")?(").concat(delimiter).concat(region, ")?(").concat(delimiter).concat(variant, ")*(").concat(delimiter).concat(extension, ")*(").concat(delimiter).concat(privateuse, ")?");
    var languageTagRegex = new RegExp("(^".concat(privateuse, "$)|(^").concat(grandfathered, "$)|(^").concat(langtag, "$)"));
    function isLocale(str) {
      (0, _assertString.default)(str);
      return languageTagRegex.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isAbaRouting.js
var require_isAbaRouting = __commonJS({
  "node_modules/validator/lib/isAbaRouting.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isAbaRouting;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isRoutingReg = /^(?!(1[3-9])|(20)|(3[3-9])|(4[0-9])|(5[0-9])|(60)|(7[3-9])|(8[1-9])|(9[0-2])|(9[3-9]))[0-9]{9}$/;
    function isAbaRouting(str) {
      (0, _assertString.default)(str);
      if (!isRoutingReg.test(str)) return false;
      var checkSumVal = 0;
      for (var i = 0; i < str.length; i++) {
        if (i % 3 === 0) checkSumVal += str[i] * 3;
        else if (i % 3 === 1) checkSumVal += str[i] * 7;
        else checkSumVal += str[i] * 1;
      }
      return checkSumVal % 10 === 0;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isAlpha.js
var require_isAlpha = __commonJS({
  "node_modules/validator/lib/isAlpha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isAlpha;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAlpha(_str) {
      var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      (0, _assertString.default)(_str);
      var str = _str;
      var ignore = options.ignore;
      if (ignore) {
        if (ignore instanceof RegExp) {
          str = str.replace(ignore, "");
        } else if (typeof ignore === "string") {
          str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
        } else {
          throw new Error("ignore should be instance of a String or RegExp");
        }
      }
      if (locale in _alpha.alpha) {
        return _alpha.alpha[locale].test(str);
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    var locales = exports.locales = Object.keys(_alpha.alpha);
  }
});

// node_modules/validator/lib/isAlphanumeric.js
var require_isAlphanumeric = __commonJS({
  "node_modules/validator/lib/isAlphanumeric.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isAlphanumeric;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAlphanumeric(_str) {
      var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      (0, _assertString.default)(_str);
      var str = _str;
      var ignore = options.ignore;
      if (ignore) {
        if (ignore instanceof RegExp) {
          str = str.replace(ignore, "");
        } else if (typeof ignore === "string") {
          str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
        } else {
          throw new Error("ignore should be instance of a String or RegExp");
        }
      }
      if (locale in _alpha.alphanumeric) {
        return _alpha.alphanumeric[locale].test(str);
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    var locales = exports.locales = Object.keys(_alpha.alphanumeric);
  }
});

// node_modules/validator/lib/isNumeric.js
var require_isNumeric = __commonJS({
  "node_modules/validator/lib/isNumeric.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNumeric2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var numericNoSymbols = /^[0-9]+$/;
    function isNumeric2(str, options) {
      (0, _assertString.default)(str);
      if (options && options.no_symbols) {
        return numericNoSymbols.test(str);
      }
      return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? _alpha.decimal[options.locale] : ".", "])?[0-9]+$")).test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isPassportNumber.js
var require_isPassportNumber = __commonJS({
  "node_modules/validator/lib/isPassportNumber.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPassportNumber;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var passportRegexByCountryCode = {
      AM: /^[A-Z]{2}\d{7}$/,
      // ARMENIA
      AR: /^[A-Z]{3}\d{6}$/,
      // ARGENTINA
      AT: /^[A-Z]\d{7}$/,
      // AUSTRIA
      AU: /^[A-Z]\d{7}$/,
      // AUSTRALIA
      AZ: /^[A-Z]{1}\d{8}$/,
      // AZERBAIJAN
      BE: /^[A-Z]{2}\d{6}$/,
      // BELGIUM
      BG: /^\d{9}$/,
      // BULGARIA
      BR: /^[A-Z]{2}\d{6}$/,
      // BRAZIL
      BY: /^[A-Z]{2}\d{7}$/,
      // BELARUS
      CA: /^[A-Z]{2}\d{6}$/,
      // CANADA
      CH: /^[A-Z]\d{7}$/,
      // SWITZERLAND
      CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
      // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits
      CY: /^[A-Z](\d{6}|\d{8})$/,
      // CYPRUS
      CZ: /^\d{8}$/,
      // CZECH REPUBLIC
      DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
      // GERMANY
      DK: /^\d{9}$/,
      // DENMARK
      DZ: /^\d{9}$/,
      // ALGERIA
      EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
      // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits
      ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
      // SPAIN
      FI: /^[A-Z]{2}\d{7}$/,
      // FINLAND
      FR: /^\d{2}[A-Z]{2}\d{5}$/,
      // FRANCE
      GB: /^\d{9}$/,
      // UNITED KINGDOM
      GR: /^[A-Z]{2}\d{7}$/,
      // GREECE
      HR: /^\d{9}$/,
      // CROATIA
      HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
      // HUNGARY
      IE: /^[A-Z0-9]{2}\d{7}$/,
      // IRELAND
      IN: /^[A-Z]{1}-?\d{7}$/,
      // INDIA
      ID: /^[A-C]\d{7}$/,
      // INDONESIA
      IR: /^[A-Z]\d{8}$/,
      // IRAN
      IS: /^(A)\d{7}$/,
      // ICELAND
      IT: /^[A-Z0-9]{2}\d{7}$/,
      // ITALY
      JM: /^[Aa]\d{7}$/,
      // JAMAICA
      JP: /^[A-Z]{2}\d{7}$/,
      // JAPAN
      KR: /^[MS]\d{8}$/,
      // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]
      KZ: /^[a-zA-Z]\d{7}$/,
      // KAZAKHSTAN
      LI: /^[a-zA-Z]\d{5}$/,
      // LIECHTENSTEIN
      LT: /^[A-Z0-9]{8}$/,
      // LITHUANIA
      LU: /^[A-Z0-9]{8}$/,
      // LUXEMBURG
      LV: /^[A-Z0-9]{2}\d{7}$/,
      // LATVIA
      LY: /^[A-Z0-9]{8}$/,
      // LIBYA
      MT: /^\d{7}$/,
      // MALTA
      MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
      // MOZAMBIQUE
      MY: /^[AHK]\d{8}$/,
      // MALAYSIA
      MX: /^\d{10,11}$/,
      // MEXICO
      NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
      // NETHERLANDS
      NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
      // NEW ZEALAND
      PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
      // PHILIPPINES
      PK: /^[A-Z]{2}\d{7}$/,
      // PAKISTAN
      PL: /^[A-Z]{2}\d{7}$/,
      // POLAND
      PT: /^[A-Z]\d{6}$/,
      // PORTUGAL
      RO: /^\d{8,9}$/,
      // ROMANIA
      RU: /^\d{9}$/,
      // RUSSIAN FEDERATION
      SE: /^\d{8}$/,
      // SWEDEN
      SL: /^(P)[A-Z]\d{7}$/,
      // SLOVENIA
      SK: /^[0-9A-Z]\d{7}$/,
      // SLOVAKIA
      TH: /^[A-Z]{1,2}\d{6,7}$/,
      // THAILAND
      TR: /^[A-Z]\d{8}$/,
      // TURKEY
      UA: /^[A-Z]{2}\d{6}$/,
      // UKRAINE
      US: /^\d{9}$/,
      // UNITED STATES
      ZA: /^[TAMD]\d{8}$/
      // SOUTH AFRICA
    };
    function isPassportNumber(str, countryCode) {
      (0, _assertString.default)(str);
      var normalizedStr = str.replace(/\s/g, "").toUpperCase();
      return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isInt.js
var require_isInt = __commonJS({
  "node_modules/validator/lib/isInt.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isInt;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
    var intLeadingZeroes = /^[-+]?[0-9]+$/;
    function isInt(str, options) {
      (0, _assertString.default)(str);
      options = options || {};
      var regex = options.allow_leading_zeroes === false ? int : intLeadingZeroes;
      var minCheckPassed = !options.hasOwnProperty("min") || str >= options.min;
      var maxCheckPassed = !options.hasOwnProperty("max") || str <= options.max;
      var ltCheckPassed = !options.hasOwnProperty("lt") || str < options.lt;
      var gtCheckPassed = !options.hasOwnProperty("gt") || str > options.gt;
      return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isPort.js
var require_isPort = __commonJS({
  "node_modules/validator/lib/isPort.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPort;
    var _isInt = _interopRequireDefault(require_isInt());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isPort(str) {
      return (0, _isInt.default)(str, {
        allow_leading_zeroes: false,
        min: 0,
        max: 65535
      });
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isLowercase.js
var require_isLowercase = __commonJS({
  "node_modules/validator/lib/isLowercase.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLowercase;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isLowercase(str) {
      (0, _assertString.default)(str);
      return str === str.toLowerCase();
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isUppercase.js
var require_isUppercase = __commonJS({
  "node_modules/validator/lib/isUppercase.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isUppercase;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isUppercase(str) {
      (0, _assertString.default)(str);
      return str === str.toUpperCase();
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isIMEI.js
var require_isIMEI = __commonJS({
  "node_modules/validator/lib/isIMEI.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIMEI;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var imeiRegexWithoutHypens = /^[0-9]{15}$/;
    var imeiRegexWithHypens = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
    function isIMEI(str, options) {
      (0, _assertString.default)(str);
      options = options || {};
      var imeiRegex = imeiRegexWithoutHypens;
      if (options.allow_hyphens) {
        imeiRegex = imeiRegexWithHypens;
      }
      if (!imeiRegex.test(str)) {
        return false;
      }
      str = str.replace(/-/g, "");
      var sum = 0, mul = 2, l = 14;
      for (var i = 0; i < l; i++) {
        var digit = str.substring(l - i - 1, l - i);
        var tp = parseInt(digit, 10) * mul;
        if (tp >= 10) {
          sum += tp % 10 + 1;
        } else {
          sum += tp;
        }
        if (mul === 1) {
          mul += 1;
        } else {
          mul -= 1;
        }
      }
      var chk = (10 - sum % 10) % 10;
      if (chk !== parseInt(str.substring(14, 15), 10)) {
        return false;
      }
      return true;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isAscii.js
var require_isAscii = __commonJS({
  "node_modules/validator/lib/isAscii.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isAscii;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ascii = /^[\x00-\x7F]+$/;
    function isAscii(str) {
      (0, _assertString.default)(str);
      return ascii.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isFullWidth.js
var require_isFullWidth = __commonJS({
  "node_modules/validator/lib/isFullWidth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isFullWidth;
    exports.fullWidth = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var fullWidth = exports.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    function isFullWidth(str) {
      (0, _assertString.default)(str);
      return fullWidth.test(str);
    }
  }
});

// node_modules/validator/lib/isHalfWidth.js
var require_isHalfWidth = __commonJS({
  "node_modules/validator/lib/isHalfWidth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isHalfWidth;
    exports.halfWidth = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var halfWidth = exports.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
    function isHalfWidth(str) {
      (0, _assertString.default)(str);
      return halfWidth.test(str);
    }
  }
});

// node_modules/validator/lib/isVariableWidth.js
var require_isVariableWidth = __commonJS({
  "node_modules/validator/lib/isVariableWidth.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isVariableWidth;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isFullWidth = require_isFullWidth();
    var _isHalfWidth = require_isHalfWidth();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isVariableWidth(str) {
      (0, _assertString.default)(str);
      return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isMultibyte.js
var require_isMultibyte = __commonJS({
  "node_modules/validator/lib/isMultibyte.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMultibyte;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var multibyte = /[^\x00-\x7F]/;
    function isMultibyte(str) {
      (0, _assertString.default)(str);
      return multibyte.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/util/multilineRegex.js
var require_multilineRegex = __commonJS({
  "node_modules/validator/lib/util/multilineRegex.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = multilineRegexp;
    function multilineRegexp(parts, flags) {
      var regexpAsStringLiteral = parts.join("");
      return new RegExp(regexpAsStringLiteral, flags);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isSemVer.js
var require_isSemVer = __commonJS({
  "node_modules/validator/lib/isSemVer.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isSemVer;
    var _assertString = _interopRequireDefault(require_assertString());
    var _multilineRegex = _interopRequireDefault(require_multilineRegex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var semanticVersioningRegex = (0, _multilineRegex.default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
    function isSemVer(str) {
      (0, _assertString.default)(str);
      return semanticVersioningRegex.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isSurrogatePair.js
var require_isSurrogatePair = __commonJS({
  "node_modules/validator/lib/isSurrogatePair.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isSurrogatePair;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
    function isSurrogatePair(str) {
      (0, _assertString.default)(str);
      return surrogatePair.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/util/includes.js
var require_includes = __commonJS({
  "node_modules/validator/lib/util/includes.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var includes = function includes2(arr, val) {
      return arr.some(function(arrVal) {
        return val === arrVal;
      });
    };
    var _default = exports.default = includes;
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isDecimal.js
var require_isDecimal = __commonJS({
  "node_modules/validator/lib/isDecimal.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isDecimal;
    var _merge = _interopRequireDefault(require_merge());
    var _assertString = _interopRequireDefault(require_assertString());
    var _includes = _interopRequireDefault(require_includes());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function decimalRegExp(options) {
      var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? "" : "?", "$"));
      return regExp;
    }
    var default_decimal_options = {
      force_decimal: false,
      decimal_digits: "1,",
      locale: "en-US"
    };
    var blacklist = ["", "-", "+"];
    function isDecimal(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_decimal_options);
      if (options.locale in _alpha.decimal) {
        return !(0, _includes.default)(blacklist, str.replace(/ /g, "")) && decimalRegExp(options).test(str);
      }
      throw new Error("Invalid locale '".concat(options.locale, "'"));
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isHexadecimal.js
var require_isHexadecimal = __commonJS({
  "node_modules/validator/lib/isHexadecimal.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isHexadecimal;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
    function isHexadecimal(str) {
      (0, _assertString.default)(str);
      return hexadecimal.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isOctal.js
var require_isOctal = __commonJS({
  "node_modules/validator/lib/isOctal.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isOctal;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var octal = /^(0o)?[0-7]+$/i;
    function isOctal(str) {
      (0, _assertString.default)(str);
      return octal.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isDivisibleBy.js
var require_isDivisibleBy = __commonJS({
  "node_modules/validator/lib/isDivisibleBy.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isDivisibleBy;
    var _assertString = _interopRequireDefault(require_assertString());
    var _toFloat = _interopRequireDefault(require_toFloat());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isDivisibleBy(str, num) {
      (0, _assertString.default)(str);
      return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isHexColor.js
var require_isHexColor = __commonJS({
  "node_modules/validator/lib/isHexColor.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isHexColor;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
    function isHexColor(str) {
      (0, _assertString.default)(str);
      return hexcolor.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isRgbColor.js
var require_isRgbColor = __commonJS({
  "node_modules/validator/lib/isRgbColor.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isRgbColor;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
    var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
    var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/;
    var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
    function isRgbColor(str) {
      var includePercentValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      (0, _assertString.default)(str);
      if (!includePercentValues) {
        return rgbColor.test(str) || rgbaColor.test(str);
      }
      return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isHSL.js
var require_isHSL = __commonJS({
  "node_modules/validator/lib/isHSL.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isHSL;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hslComma = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i;
    var hslSpace = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
    function isHSL(str) {
      (0, _assertString.default)(str);
      var strippedStr = str.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/ig, "$1");
      if (strippedStr.indexOf(",") !== -1) {
        return hslComma.test(strippedStr);
      }
      return hslSpace.test(strippedStr);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isISRC.js
var require_isISRC = __commonJS({
  "node_modules/validator/lib/isISRC.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISRC;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
    function isISRC(str) {
      (0, _assertString.default)(str);
      return isrc.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isIBAN.js
var require_isIBAN = __commonJS({
  "node_modules/validator/lib/isIBAN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIBAN;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ibanRegexThroughCountryCode = {
      AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
      AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
      AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
      AT: /^(AT[0-9]{2})\d{16}$/,
      AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
      BA: /^(BA[0-9]{2})\d{16}$/,
      BE: /^(BE[0-9]{2})\d{12}$/,
      BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
      BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
      BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
      BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
      CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
      CR: /^(CR[0-9]{2})\d{18}$/,
      CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
      CZ: /^(CZ[0-9]{2})\d{20}$/,
      DE: /^(DE[0-9]{2})\d{18}$/,
      DK: /^(DK[0-9]{2})\d{14}$/,
      DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
      DZ: /^(DZ\d{24})$/,
      EE: /^(EE[0-9]{2})\d{16}$/,
      EG: /^(EG[0-9]{2})\d{25}$/,
      ES: /^(ES[0-9]{2})\d{20}$/,
      FI: /^(FI[0-9]{2})\d{14}$/,
      FO: /^(FO[0-9]{2})\d{14}$/,
      FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
      GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
      GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
      GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
      GL: /^(GL[0-9]{2})\d{14}$/,
      GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
      GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
      HR: /^(HR[0-9]{2})\d{17}$/,
      HU: /^(HU[0-9]{2})\d{24}$/,
      IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
      IL: /^(IL[0-9]{2})\d{19}$/,
      IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
      IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
      IS: /^(IS[0-9]{2})\d{22}$/,
      IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
      JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
      KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
      KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
      LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
      LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
      LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
      LT: /^(LT[0-9]{2})\d{16}$/,
      LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
      LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
      MA: /^(MA[0-9]{26})$/,
      MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
      MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
      ME: /^(ME[0-9]{2})\d{18}$/,
      MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
      MR: /^(MR[0-9]{2})\d{23}$/,
      MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
      MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
      MZ: /^(MZ[0-9]{2})\d{21}$/,
      NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
      NO: /^(NO[0-9]{2})\d{11}$/,
      PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
      PL: /^(PL[0-9]{2})\d{24}$/,
      PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
      PT: /^(PT[0-9]{2})\d{21}$/,
      QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
      RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
      RS: /^(RS[0-9]{2})\d{18}$/,
      SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
      SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
      SE: /^(SE[0-9]{2})\d{20}$/,
      SI: /^(SI[0-9]{2})\d{15}$/,
      SK: /^(SK[0-9]{2})\d{20}$/,
      SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
      SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
      TL: /^(TL[0-9]{2})\d{19}$/,
      TN: /^(TN[0-9]{2})\d{20}$/,
      TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
      UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
      VA: /^(VA[0-9]{2})\d{18}$/,
      VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
      XK: /^(XK[0-9]{2})\d{16}$/
    };
    function hasOnlyValidCountryCodes(countryCodeArray) {
      var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function(countryCode) {
        return !(countryCode in ibanRegexThroughCountryCode);
      });
      if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {
        return false;
      }
      return true;
    }
    function hasValidIbanFormat(str, options) {
      var strippedStr = str.replace(/[\s\-]+/gi, "").toUpperCase();
      var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
      var isoCountryCodeInIbanRegexCodeObject = isoCountryCode in ibanRegexThroughCountryCode;
      if (options.whitelist) {
        if (!hasOnlyValidCountryCodes(options.whitelist)) {
          return false;
        }
        var isoCountryCodeInWhiteList = options.whitelist.includes(isoCountryCode);
        if (!isoCountryCodeInWhiteList) {
          return false;
        }
      }
      if (options.blacklist) {
        var isoCountryCodeInBlackList = options.blacklist.includes(isoCountryCode);
        if (isoCountryCodeInBlackList) {
          return false;
        }
      }
      return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
    }
    function hasValidIbanChecksum(str) {
      var strippedStr = str.replace(/[^A-Z0-9]+/gi, "").toUpperCase();
      var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
      var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function(char) {
        return char.charCodeAt(0) - 55;
      });
      var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function(acc, value) {
        return Number(acc + value) % 97;
      }, "");
      return remainder === 1;
    }
    function isIBAN(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(str);
      return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);
    }
    var locales = exports.locales = Object.keys(ibanRegexThroughCountryCode);
  }
});

// node_modules/validator/lib/isISO31661Alpha2.js
var require_isISO31661Alpha2 = __commonJS({
  "node_modules/validator/lib/isISO31661Alpha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CountryCodes = void 0;
    exports.default = isISO31661Alpha2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validISO31661Alpha2CountriesCodes = /* @__PURE__ */ new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
    function isISO31661Alpha2(str) {
      (0, _assertString.default)(str);
      return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());
    }
    var CountryCodes = exports.CountryCodes = validISO31661Alpha2CountriesCodes;
  }
});

// node_modules/validator/lib/isBIC.js
var require_isBIC = __commonJS({
  "node_modules/validator/lib/isBIC.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBIC;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isISO31661Alpha = require_isISO31661Alpha2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
    function isBIC(str) {
      (0, _assertString.default)(str);
      var countryCode = str.slice(4, 6).toUpperCase();
      if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== "XK") {
        return false;
      }
      return isBICReg.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isMD5.js
var require_isMD5 = __commonJS({
  "node_modules/validator/lib/isMD5.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMD5;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var md5 = /^[a-f0-9]{32}$/;
    function isMD5(str) {
      (0, _assertString.default)(str);
      return md5.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isHash.js
var require_isHash = __commonJS({
  "node_modules/validator/lib/isHash.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isHash;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var lengths = {
      md5: 32,
      md4: 32,
      sha1: 40,
      sha256: 64,
      sha384: 96,
      sha512: 128,
      ripemd128: 32,
      ripemd160: 40,
      tiger128: 32,
      tiger160: 40,
      tiger192: 48,
      crc32: 8,
      crc32b: 8
    };
    function isHash(str, algorithm) {
      (0, _assertString.default)(str);
      var hash3 = new RegExp("^[a-fA-F0-9]{".concat(lengths[algorithm], "}$"));
      return hash3.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isBase64.js
var require_isBase64 = __commonJS({
  "node_modules/validator/lib/isBase64.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBase64;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var notBase64 = /[^A-Z0-9+\/=]/i;
    var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
    var defaultBase64Options = {
      urlSafe: false
    };
    function isBase64(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultBase64Options);
      var len = str.length;
      if (options.urlSafe) {
        return urlSafeBase64.test(str);
      }
      if (len % 4 !== 0 || notBase64.test(str)) {
        return false;
      }
      var firstPaddingChar = str.indexOf("=");
      return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === "=";
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isJWT.js
var require_isJWT = __commonJS({
  "node_modules/validator/lib/isJWT.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isJWT;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isBase = _interopRequireDefault(require_isBase64());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isJWT(str) {
      (0, _assertString.default)(str);
      var dotSplit = str.split(".");
      var len = dotSplit.length;
      if (len !== 3) {
        return false;
      }
      return dotSplit.reduce(function(acc, currElem) {
        return acc && (0, _isBase.default)(currElem, {
          urlSafe: true
        });
      }, true);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isJSON.js
var require_isJSON = __commonJS({
  "node_modules/validator/lib/isJSON.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isJSON;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var default_json_options = {
      allow_primitives: false
    };
    function isJSON(str, options) {
      (0, _assertString.default)(str);
      try {
        options = (0, _merge.default)(options, default_json_options);
        var primitives = [];
        if (options.allow_primitives) {
          primitives = [null, false, true];
        }
        var obj = JSON.parse(str);
        return primitives.includes(obj) || !!obj && _typeof(obj) === "object";
      } catch (e) {
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/validator/lib/isEmpty.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isEmpty;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_is_empty_options = {
      ignore_whitespace: false
    };
    function isEmpty(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_is_empty_options);
      return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isLength.js
var require_isLength = __commonJS({
  "node_modules/validator/lib/isLength.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLength;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function isLength(str, options) {
      (0, _assertString.default)(str);
      var min;
      var max;
      if (_typeof(options) === "object") {
        min = options.min || 0;
        max = options.max;
      } else {
        min = arguments[1] || 0;
        max = arguments[2];
      }
      var presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
      var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
      var len = str.length - presentationSequences.length - surrogatePairs.length;
      return len >= min && (typeof max === "undefined" || len <= max);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isUUID.js
var require_isUUID = __commonJS({
  "node_modules/validator/lib/isUUID.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isUUID;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var uuid = {
      1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
      all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
    };
    function isUUID(str, version3) {
      (0, _assertString.default)(str);
      var pattern = uuid[![void 0, null].includes(version3) ? version3 : "all"];
      return !!pattern && pattern.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isMongoId.js
var require_isMongoId = __commonJS({
  "node_modules/validator/lib/isMongoId.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMongoId;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isHexadecimal = _interopRequireDefault(require_isHexadecimal());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isMongoId(str) {
      (0, _assertString.default)(str);
      return (0, _isHexadecimal.default)(str) && str.length === 24;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isAfter.js
var require_isAfter = __commonJS({
  "node_modules/validator/lib/isAfter.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isAfter;
    var _toDate = _interopRequireDefault(require_toDate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAfter(date, options) {
      var comparisonDate = (options === null || options === void 0 ? void 0 : options.comparisonDate) || options || Date().toString();
      var comparison = (0, _toDate.default)(comparisonDate);
      var original = (0, _toDate.default)(date);
      return !!(original && comparison && original > comparison);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isBefore.js
var require_isBefore = __commonJS({
  "node_modules/validator/lib/isBefore.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBefore;
    var _assertString = _interopRequireDefault(require_assertString());
    var _toDate = _interopRequireDefault(require_toDate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isBefore(str) {
      var date = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : String(/* @__PURE__ */ new Date());
      (0, _assertString.default)(str);
      var comparison = (0, _toDate.default)(date);
      var original = (0, _toDate.default)(str);
      return !!(original && comparison && original < comparison);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isIn.js
var require_isIn = __commonJS({
  "node_modules/validator/lib/isIn.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIn;
    var _assertString = _interopRequireDefault(require_assertString());
    var _toString = _interopRequireDefault(require_toString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function isIn(str, options) {
      (0, _assertString.default)(str);
      var i;
      if (Object.prototype.toString.call(options) === "[object Array]") {
        var array = [];
        for (i in options) {
          if ({}.hasOwnProperty.call(options, i)) {
            array[i] = (0, _toString.default)(options[i]);
          }
        }
        return array.indexOf(str) >= 0;
      } else if (_typeof(options) === "object") {
        return options.hasOwnProperty(str);
      } else if (options && typeof options.indexOf === "function") {
        return options.indexOf(str) >= 0;
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isLuhnNumber.js
var require_isLuhnNumber = __commonJS({
  "node_modules/validator/lib/isLuhnNumber.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLuhnNumber;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isLuhnNumber(str) {
      (0, _assertString.default)(str);
      var sanitized = str.replace(/[- ]+/g, "");
      var sum = 0;
      var digit;
      var tmpNum;
      var shouldDouble;
      for (var i = sanitized.length - 1; i >= 0; i--) {
        digit = sanitized.substring(i, i + 1);
        tmpNum = parseInt(digit, 10);
        if (shouldDouble) {
          tmpNum *= 2;
          if (tmpNum >= 10) {
            sum += tmpNum % 10 + 1;
          } else {
            sum += tmpNum;
          }
        } else {
          sum += tmpNum;
        }
        shouldDouble = !shouldDouble;
      }
      return !!(sum % 10 === 0 ? sanitized : false);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isCreditCard.js
var require_isCreditCard = __commonJS({
  "node_modules/validator/lib/isCreditCard.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isCreditCard;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isLuhnNumber = _interopRequireDefault(require_isLuhnNumber());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var cards = {
      amex: /^3[47][0-9]{13}$/,
      dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
      discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
      jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
      mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
      // /^[25][1-7][0-9]{14}$/;
      unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
      visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
    };
    var allCards = function() {
      var tmpCardsArray = [];
      for (var cardProvider in cards) {
        if (cards.hasOwnProperty(cardProvider)) {
          tmpCardsArray.push(cards[cardProvider]);
        }
      }
      return tmpCardsArray;
    }();
    function isCreditCard(card) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(card);
      var provider = options.provider;
      var sanitized = card.replace(/[- ]+/g, "");
      if (provider && provider.toLowerCase() in cards) {
        if (!cards[provider.toLowerCase()].test(sanitized)) {
          return false;
        }
      } else if (provider && !(provider.toLowerCase() in cards)) {
        throw new Error("".concat(provider, " is not a valid credit card provider."));
      } else if (!allCards.some(function(cardProvider) {
        return cardProvider.test(sanitized);
      })) {
        return false;
      }
      return (0, _isLuhnNumber.default)(card);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isIdentityCard.js
var require_isIdentityCard = __commonJS({
  "node_modules/validator/lib/isIdentityCard.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIdentityCard;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isInt = _interopRequireDefault(require_isInt());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validators3 = {
      PL: function PL(str) {
        (0, _assertString.default)(str);
        var weightOfDigits = {
          1: 1,
          2: 3,
          3: 7,
          4: 9,
          5: 1,
          6: 3,
          7: 7,
          8: 9,
          9: 1,
          10: 3,
          11: 0
        };
        if (str != null && str.length === 11 && (0, _isInt.default)(str, {
          allow_leading_zeroes: true
        })) {
          var digits = str.split("").slice(0, -1);
          var sum = digits.reduce(function(acc, digit, index) {
            return acc + Number(digit) * weightOfDigits[index + 1];
          }, 0);
          var modulo = sum % 10;
          var lastDigit = Number(str.charAt(str.length - 1));
          if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {
            return true;
          }
        }
        return false;
      },
      ES: function ES(str) {
        (0, _assertString.default)(str);
        var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
        var charsValue = {
          X: 0,
          Y: 1,
          Z: 2
        };
        var controlDigits = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
        var sanitized = str.trim().toUpperCase();
        if (!DNI.test(sanitized)) {
          return false;
        }
        var number3 = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function(char) {
          return charsValue[char];
        });
        return sanitized.endsWith(controlDigits[number3 % 23]);
      },
      FI: function FI(str) {
        (0, _assertString.default)(str);
        if (str.length !== 11) {
          return false;
        }
        if (!str.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {
          return false;
        }
        var checkDigits = "0123456789ABCDEFHJKLMNPRSTUVWXY";
        var idAsNumber = parseInt(str.slice(0, 6), 10) * 1e3 + parseInt(str.slice(7, 10), 10);
        var remainder = idAsNumber % 31;
        var checkDigit = checkDigits[remainder];
        return checkDigit === str.slice(10, 11);
      },
      IN: function IN(str) {
        var DNI = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/;
        var d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
        var p = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
        var sanitized = str.trim();
        if (!DNI.test(sanitized)) {
          return false;
        }
        var c = 0;
        var invertedArray = sanitized.replace(/\s/g, "").split("").map(Number).reverse();
        invertedArray.forEach(function(val, i) {
          c = d[c][p[i % 8][val]];
        });
        return c === 0;
      },
      IR: function IR(str) {
        if (!str.match(/^\d{10}$/)) return false;
        str = "0000".concat(str).slice(str.length - 6);
        if (parseInt(str.slice(3, 9), 10) === 0) return false;
        var lastNumber = parseInt(str.slice(9, 10), 10);
        var sum = 0;
        for (var i = 0; i < 9; i++) {
          sum += parseInt(str.slice(i, i + 1), 10) * (10 - i);
        }
        sum %= 11;
        return sum < 2 && lastNumber === sum || sum >= 2 && lastNumber === 11 - sum;
      },
      IT: function IT(str) {
        if (str.length !== 9) return false;
        if (str === "CA00000AA") return false;
        return str.search(/C[A-Z]\d{5}[A-Z]{2}/i) > -1;
      },
      NO: function NO(str) {
        var sanitized = str.trim();
        if (isNaN(Number(sanitized))) return false;
        if (sanitized.length !== 11) return false;
        if (sanitized === "00000000000") return false;
        var f2 = sanitized.split("").map(Number);
        var k1 = (11 - (3 * f2[0] + 7 * f2[1] + 6 * f2[2] + 1 * f2[3] + 8 * f2[4] + 9 * f2[5] + 4 * f2[6] + 5 * f2[7] + 2 * f2[8]) % 11) % 11;
        var k2 = (11 - (5 * f2[0] + 4 * f2[1] + 3 * f2[2] + 2 * f2[3] + 7 * f2[4] + 6 * f2[5] + 5 * f2[6] + 4 * f2[7] + 3 * f2[8] + 2 * k1) % 11) % 11;
        if (k1 !== f2[9] || k2 !== f2[10]) return false;
        return true;
      },
      TH: function TH(str) {
        if (!str.match(/^[1-8]\d{12}$/)) return false;
        var sum = 0;
        for (var i = 0; i < 12; i++) {
          sum += parseInt(str[i], 10) * (13 - i);
        }
        return str[12] === ((11 - sum % 11) % 10).toString();
      },
      LK: function LK(str) {
        var old_nic = /^[1-9]\d{8}[vx]$/i;
        var new_nic = /^[1-9]\d{11}$/i;
        if (str.length === 10 && old_nic.test(str)) return true;
        else if (str.length === 12 && new_nic.test(str)) return true;
        return false;
      },
      "he-IL": function heIL(str) {
        var DNI = /^\d{9}$/;
        var sanitized = str.trim();
        if (!DNI.test(sanitized)) {
          return false;
        }
        var id2 = sanitized;
        var sum = 0, incNum;
        for (var i = 0; i < id2.length; i++) {
          incNum = Number(id2[i]) * (i % 2 + 1);
          sum += incNum > 9 ? incNum - 9 : incNum;
        }
        return sum % 10 === 0;
      },
      "ar-LY": function arLY(str) {
        var NIN = /^(1|2)\d{11}$/;
        var sanitized = str.trim();
        if (!NIN.test(sanitized)) {
          return false;
        }
        return true;
      },
      "ar-TN": function arTN(str) {
        var DNI = /^\d{8}$/;
        var sanitized = str.trim();
        if (!DNI.test(sanitized)) {
          return false;
        }
        return true;
      },
      "zh-CN": function zhCN(str) {
        var provincesAndCities = [
          "11",
          // 北京
          "12",
          // 天津
          "13",
          // 河北
          "14",
          // 山西
          "15",
          // 内蒙古
          "21",
          // 辽宁
          "22",
          // 吉林
          "23",
          // 黑龙江
          "31",
          // 上海
          "32",
          // 江苏
          "33",
          // 浙江
          "34",
          // 安徽
          "35",
          // 福建
          "36",
          // 江西
          "37",
          // 山东
          "41",
          // 河南
          "42",
          // 湖北
          "43",
          // 湖南
          "44",
          // 广东
          "45",
          // 广西
          "46",
          // 海南
          "50",
          // 重庆
          "51",
          // 四川
          "52",
          // 贵州
          "53",
          // 云南
          "54",
          // 西藏
          "61",
          // 陕西
          "62",
          // 甘肃
          "63",
          // 青海
          "64",
          // 宁夏
          "65",
          // 新疆
          "71",
          // 台湾
          "81",
          // 香港
          "82",
          // 澳门
          "91"
          // 国外
        ];
        var powers = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"];
        var parityBit = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"];
        var checkAddressCode = function checkAddressCode2(addressCode) {
          return provincesAndCities.includes(addressCode);
        };
        var checkBirthDayCode = function checkBirthDayCode2(birDayCode) {
          var yyyy = parseInt(birDayCode.substring(0, 4), 10);
          var mm = parseInt(birDayCode.substring(4, 6), 10);
          var dd = parseInt(birDayCode.substring(6), 10);
          var xdata = new Date(yyyy, mm - 1, dd);
          if (xdata > /* @__PURE__ */ new Date()) {
            return false;
          } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd) {
            return true;
          }
          return false;
        };
        var getParityBit = function getParityBit2(idCardNo) {
          var id17 = idCardNo.substring(0, 17);
          var power = 0;
          for (var i = 0; i < 17; i++) {
            power += parseInt(id17.charAt(i), 10) * parseInt(powers[i], 10);
          }
          var mod3 = power % 11;
          return parityBit[mod3];
        };
        var checkParityBit = function checkParityBit2(idCardNo) {
          return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();
        };
        var check15IdCardNo = function check15IdCardNo2(idCardNo) {
          var check = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(idCardNo);
          if (!check) return false;
          var addressCode = idCardNo.substring(0, 2);
          check = checkAddressCode(addressCode);
          if (!check) return false;
          var birDayCode = "19".concat(idCardNo.substring(6, 12));
          check = checkBirthDayCode(birDayCode);
          if (!check) return false;
          return true;
        };
        var check18IdCardNo = function check18IdCardNo2(idCardNo) {
          var check = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(idCardNo);
          if (!check) return false;
          var addressCode = idCardNo.substring(0, 2);
          check = checkAddressCode(addressCode);
          if (!check) return false;
          var birDayCode = idCardNo.substring(6, 14);
          check = checkBirthDayCode(birDayCode);
          if (!check) return false;
          return checkParityBit(idCardNo);
        };
        var checkIdCardNo = function checkIdCardNo2(idCardNo) {
          var check = /^\d{15}|(\d{17}(\d|x|X))$/.test(idCardNo);
          if (!check) return false;
          if (idCardNo.length === 15) {
            return check15IdCardNo(idCardNo);
          }
          return check18IdCardNo(idCardNo);
        };
        return checkIdCardNo(str);
      },
      "zh-HK": function zhHK(str) {
        str = str.trim();
        var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/;
        var regexIsDigit = /^[0-9]$/;
        str = str.toUpperCase();
        if (!regexHKID.test(str)) return false;
        str = str.replace(/\[|\]|\(|\)/g, "");
        if (str.length === 8) str = "3".concat(str);
        var checkSumVal = 0;
        for (var i = 0; i <= 7; i++) {
          var convertedChar = void 0;
          if (!regexIsDigit.test(str[i])) convertedChar = (str[i].charCodeAt(0) - 55) % 11;
          else convertedChar = str[i];
          checkSumVal += convertedChar * (9 - i);
        }
        checkSumVal %= 11;
        var checkSumConverted;
        if (checkSumVal === 0) checkSumConverted = "0";
        else if (checkSumVal === 1) checkSumConverted = "A";
        else checkSumConverted = String(11 - checkSumVal);
        if (checkSumConverted === str[str.length - 1]) return true;
        return false;
      },
      "zh-TW": function zhTW(str) {
        var ALPHABET_CODES = {
          A: 10,
          B: 11,
          C: 12,
          D: 13,
          E: 14,
          F: 15,
          G: 16,
          H: 17,
          I: 34,
          J: 18,
          K: 19,
          L: 20,
          M: 21,
          N: 22,
          O: 35,
          P: 23,
          Q: 24,
          R: 25,
          S: 26,
          T: 27,
          U: 28,
          V: 29,
          W: 32,
          X: 30,
          Y: 31,
          Z: 33
        };
        var sanitized = str.trim().toUpperCase();
        if (!/^[A-Z][0-9]{9}$/.test(sanitized)) return false;
        return Array.from(sanitized).reduce(function(sum, number3, index) {
          if (index === 0) {
            var code = ALPHABET_CODES[number3];
            return code % 10 * 9 + Math.floor(code / 10);
          }
          if (index === 9) {
            return (10 - sum % 10 - Number(number3)) % 10 === 0;
          }
          return sum + Number(number3) * (9 - index);
        }, 0);
      }
    };
    function isIdentityCard(str, locale) {
      (0, _assertString.default)(str);
      if (locale in validators3) {
        return validators3[locale](str);
      } else if (locale === "any") {
        for (var key in validators3) {
          if (validators3.hasOwnProperty(key)) {
            var validator2 = validators3[key];
            if (validator2(str)) {
              return true;
            }
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isEAN.js
var require_isEAN = __commonJS({
  "node_modules/validator/lib/isEAN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isEAN;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var LENGTH_EAN_8 = 8;
    var LENGTH_EAN_14 = 14;
    var validEanRegex = /^(\d{8}|\d{13}|\d{14})$/;
    function getPositionWeightThroughLengthAndIndex(length, index) {
      if (length === LENGTH_EAN_8 || length === LENGTH_EAN_14) {
        return index % 2 === 0 ? 3 : 1;
      }
      return index % 2 === 0 ? 1 : 3;
    }
    function calculateCheckDigit(ean) {
      var checksum2 = ean.slice(0, -1).split("").map(function(char, index) {
        return Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index);
      }).reduce(function(acc, partialSum) {
        return acc + partialSum;
      }, 0);
      var remainder = 10 - checksum2 % 10;
      return remainder < 10 ? remainder : 0;
    }
    function isEAN(str) {
      (0, _assertString.default)(str);
      var actualCheckDigit = Number(str.slice(-1));
      return validEanRegex.test(str) && actualCheckDigit === calculateCheckDigit(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isISIN.js
var require_isISIN = __commonJS({
  "node_modules/validator/lib/isISIN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISIN;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
    function isISIN(str) {
      (0, _assertString.default)(str);
      if (!isin.test(str)) {
        return false;
      }
      var double = true;
      var sum = 0;
      for (var i = str.length - 2; i >= 0; i--) {
        if (str[i] >= "A" && str[i] <= "Z") {
          var value = str[i].charCodeAt(0) - 55;
          var lo = value % 10;
          var hi = Math.trunc(value / 10);
          for (var _i = 0, _arr = [lo, hi]; _i < _arr.length; _i++) {
            var digit = _arr[_i];
            if (double) {
              if (digit >= 5) {
                sum += 1 + (digit - 5) * 2;
              } else {
                sum += digit * 2;
              }
            } else {
              sum += digit;
            }
            double = !double;
          }
        } else {
          var _digit = str[i].charCodeAt(0) - "0".charCodeAt(0);
          if (double) {
            if (_digit >= 5) {
              sum += 1 + (_digit - 5) * 2;
            } else {
              sum += _digit * 2;
            }
          } else {
            sum += _digit;
          }
          double = !double;
        }
      }
      var check = Math.trunc((sum + 9) / 10) * 10 - sum;
      return +str[str.length - 1] === check;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isISBN.js
var require_isISBN = __commonJS({
  "node_modules/validator/lib/isISBN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISBN;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;
    var possibleIsbn13 = /^(?:[0-9]{13})$/;
    var factor = [1, 3];
    function isISBN(isbn, options) {
      (0, _assertString.default)(isbn);
      var version3 = String((options === null || options === void 0 ? void 0 : options.version) || options);
      if (!(options !== null && options !== void 0 && options.version || options)) {
        return isISBN(isbn, {
          version: 10
        }) || isISBN(isbn, {
          version: 13
        });
      }
      var sanitizedIsbn = isbn.replace(/[\s-]+/g, "");
      var checksum2 = 0;
      if (version3 === "10") {
        if (!possibleIsbn10.test(sanitizedIsbn)) {
          return false;
        }
        for (var i = 0; i < version3 - 1; i++) {
          checksum2 += (i + 1) * sanitizedIsbn.charAt(i);
        }
        if (sanitizedIsbn.charAt(9) === "X") {
          checksum2 += 10 * 10;
        } else {
          checksum2 += 10 * sanitizedIsbn.charAt(9);
        }
        if (checksum2 % 11 === 0) {
          return true;
        }
      } else if (version3 === "13") {
        if (!possibleIsbn13.test(sanitizedIsbn)) {
          return false;
        }
        for (var _i = 0; _i < 12; _i++) {
          checksum2 += factor[_i % 2] * sanitizedIsbn.charAt(_i);
        }
        if (sanitizedIsbn.charAt(12) - (10 - checksum2 % 10) % 10 === 0) {
          return true;
        }
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isISSN.js
var require_isISSN = __commonJS({
  "node_modules/validator/lib/isISSN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISSN;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var issn = "^\\d{4}-?\\d{3}[\\dX]$";
    function isISSN(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(str);
      var testIssn = issn;
      testIssn = options.require_hyphen ? testIssn.replace("?", "") : testIssn;
      testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, "i");
      if (!testIssn.test(str)) {
        return false;
      }
      var digits = str.replace("-", "").toUpperCase();
      var checksum2 = 0;
      for (var i = 0; i < digits.length; i++) {
        var digit = digits[i];
        checksum2 += (digit === "X" ? 10 : +digit) * (8 - i);
      }
      return checksum2 % 11 === 0;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/util/algorithms.js
var require_algorithms = __commonJS({
  "node_modules/validator/lib/util/algorithms.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.iso7064Check = iso7064Check;
    exports.luhnCheck = luhnCheck;
    exports.reverseMultiplyAndSum = reverseMultiplyAndSum;
    exports.verhoeffCheck = verhoeffCheck;
    function iso7064Check(str) {
      var checkvalue = 10;
      for (var i = 0; i < str.length - 1; i++) {
        checkvalue = (parseInt(str[i], 10) + checkvalue) % 10 === 0 ? 10 * 2 % 11 : (parseInt(str[i], 10) + checkvalue) % 10 * 2 % 11;
      }
      checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;
      return checkvalue === parseInt(str[10], 10);
    }
    function luhnCheck(str) {
      var checksum2 = 0;
      var second = false;
      for (var i = str.length - 1; i >= 0; i--) {
        if (second) {
          var product = parseInt(str[i], 10) * 2;
          if (product > 9) {
            checksum2 += product.toString().split("").map(function(a) {
              return parseInt(a, 10);
            }).reduce(function(a, b2) {
              return a + b2;
            }, 0);
          } else {
            checksum2 += product;
          }
        } else {
          checksum2 += parseInt(str[i], 10);
        }
        second = !second;
      }
      return checksum2 % 10 === 0;
    }
    function reverseMultiplyAndSum(digits, base) {
      var total = 0;
      for (var i = 0; i < digits.length; i++) {
        total += digits[i] * (base - i);
      }
      return total;
    }
    function verhoeffCheck(str) {
      var d_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
      var p_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
      var str_copy = str.split("").reverse().join("");
      var checksum2 = 0;
      for (var i = 0; i < str_copy.length; i++) {
        checksum2 = d_table[checksum2][p_table[i % 8][parseInt(str_copy[i], 10)]];
      }
      return checksum2 === 0;
    }
  }
});

// node_modules/validator/lib/isTaxID.js
var require_isTaxID = __commonJS({
  "node_modules/validator/lib/isTaxID.js"(exports, module) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isTaxID;
    var _assertString = _interopRequireDefault(require_assertString());
    var algorithms = _interopRequireWildcard(require_algorithms());
    var _isDate = _interopRequireDefault(require_isDate());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n2, u, i) : n2[u] = e[u];
      }
      return n2.default = e, t && t.set(e, n2), n2;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function bgBgCheck(tin) {
      var century_year = tin.slice(0, 2);
      var month = parseInt(tin.slice(2, 4), 10);
      if (month > 40) {
        month -= 40;
        century_year = "20".concat(century_year);
      } else if (month > 20) {
        month -= 20;
        century_year = "18".concat(century_year);
      } else {
        century_year = "19".concat(century_year);
      }
      if (month < 10) {
        month = "0".concat(month);
      }
      var date = "".concat(century_year, "/").concat(month, "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
      var checksum2 = 0;
      for (var i = 0; i < multip_lookup.length; i++) {
        checksum2 += digits[i] * multip_lookup[i];
      }
      checksum2 = checksum2 % 11 === 10 ? 0 : checksum2 % 11;
      return checksum2 === digits[9];
    }
    function isCanadianSIN(input) {
      var digitsArray = input.split("");
      var even = digitsArray.filter(function(_, idx) {
        return idx % 2;
      }).map(function(i) {
        return Number(i) * 2;
      }).join("").split("");
      var total = digitsArray.filter(function(_, idx) {
        return !(idx % 2);
      }).concat(even).map(function(i) {
        return Number(i);
      }).reduce(function(acc, cur) {
        return acc + cur;
      });
      return total % 10 === 0;
    }
    function csCzCheck(tin) {
      tin = tin.replace(/\W/, "");
      var full_year = parseInt(tin.slice(0, 2), 10);
      if (tin.length === 10) {
        if (full_year < 54) {
          full_year = "20".concat(full_year);
        } else {
          full_year = "19".concat(full_year);
        }
      } else {
        if (tin.slice(6) === "000") {
          return false;
        }
        if (full_year < 54) {
          full_year = "19".concat(full_year);
        } else {
          return false;
        }
      }
      if (full_year.length === 3) {
        full_year = [full_year.slice(0, 2), "0", full_year.slice(2)].join("");
      }
      var month = parseInt(tin.slice(2, 4), 10);
      if (month > 50) {
        month -= 50;
      }
      if (month > 20) {
        if (parseInt(full_year, 10) < 2004) {
          return false;
        }
        month -= 20;
      }
      if (month < 10) {
        month = "0".concat(month);
      }
      var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      if (tin.length === 10) {
        if (parseInt(tin, 10) % 11 !== 0) {
          var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;
          if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {
            if (parseInt(tin.slice(9), 10) !== 0) {
              return false;
            }
          } else {
            return false;
          }
        }
      }
      return true;
    }
    function deAtCheck(tin) {
      return algorithms.luhnCheck(tin);
    }
    function deDeCheck(tin) {
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var occurences = [];
      for (var i = 0; i < digits.length - 1; i++) {
        occurences.push("");
        for (var j = 0; j < digits.length - 1; j++) {
          if (digits[i] === digits[j]) {
            occurences[i] += j;
          }
        }
      }
      occurences = occurences.filter(function(a) {
        return a.length > 1;
      });
      if (occurences.length !== 2 && occurences.length !== 3) {
        return false;
      }
      if (occurences[0].length === 3) {
        var trip_locations = occurences[0].split("").map(function(a) {
          return parseInt(a, 10);
        });
        var recurrent = 0;
        for (var _i = 0; _i < trip_locations.length - 1; _i++) {
          if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {
            recurrent += 1;
          }
        }
        if (recurrent === 2) {
          return false;
        }
      }
      return algorithms.iso7064Check(tin);
    }
    function dkDkCheck(tin) {
      tin = tin.replace(/\W/, "");
      var year = parseInt(tin.slice(4, 6), 10);
      var century_digit = tin.slice(6, 7);
      switch (century_digit) {
        case "0":
        case "1":
        case "2":
        case "3":
          year = "19".concat(year);
          break;
        case "4":
        case "9":
          if (year < 37) {
            year = "20".concat(year);
          } else {
            year = "19".concat(year);
          }
          break;
        default:
          if (year < 37) {
            year = "20".concat(year);
          } else if (year > 58) {
            year = "18".concat(year);
          } else {
            return false;
          }
          break;
      }
      if (year.length === 3) {
        year = [year.slice(0, 2), "0", year.slice(2)].join("");
      }
      var date = "".concat(year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var checksum2 = 0;
      var weight = 4;
      for (var i = 0; i < 9; i++) {
        checksum2 += digits[i] * weight;
        weight -= 1;
        if (weight === 1) {
          weight = 7;
        }
      }
      checksum2 %= 11;
      if (checksum2 === 1) {
        return false;
      }
      return checksum2 === 0 ? digits[9] === 0 : digits[9] === 11 - checksum2;
    }
    function elCyCheck(tin) {
      var digits = tin.slice(0, 8).split("").map(function(a) {
        return parseInt(a, 10);
      });
      var checksum2 = 0;
      for (var i = 1; i < digits.length; i += 2) {
        checksum2 += digits[i];
      }
      for (var _i2 = 0; _i2 < digits.length; _i2 += 2) {
        if (digits[_i2] < 2) {
          checksum2 += 1 - digits[_i2];
        } else {
          checksum2 += 2 * (digits[_i2] - 2) + 5;
          if (digits[_i2] > 4) {
            checksum2 += 2;
          }
        }
      }
      return String.fromCharCode(checksum2 % 26 + 65) === tin.charAt(8);
    }
    function elGrCheck(tin) {
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var checksum2 = 0;
      for (var i = 0; i < 8; i++) {
        checksum2 += digits[i] * Math.pow(2, 8 - i);
      }
      return checksum2 % 11 % 10 === digits[8];
    }
    function enIeCheck(tin) {
      var checksum2 = algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a) {
        return parseInt(a, 10);
      }), 8);
      if (tin.length === 9 && tin[8] !== "W") {
        checksum2 += (tin[8].charCodeAt(0) - 64) * 9;
      }
      checksum2 %= 23;
      if (checksum2 === 0) {
        return tin[7].toUpperCase() === "W";
      }
      return tin[7].toUpperCase() === String.fromCharCode(64 + checksum2);
    }
    var enUsCampusPrefix = {
      andover: ["10", "12"],
      atlanta: ["60", "67"],
      austin: ["50", "53"],
      brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"],
      cincinnati: ["30", "32", "35", "36", "37", "38", "61"],
      fresno: ["15", "24"],
      internet: ["20", "26", "27", "45", "46", "47"],
      kansas: ["40", "44"],
      memphis: ["94", "95"],
      ogden: ["80", "90"],
      philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"],
      sba: ["31"]
    };
    function enUsGetPrefixes() {
      var prefixes = [];
      for (var location in enUsCampusPrefix) {
        if (enUsCampusPrefix.hasOwnProperty(location)) {
          prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location]));
        }
      }
      return prefixes;
    }
    function enUsCheck(tin) {
      return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;
    }
    function esArCheck(tin) {
      var accum = 0;
      var digits = tin.split("");
      var digit = parseInt(digits.pop(), 10);
      for (var i = 0; i < digits.length; i++) {
        accum += digits[9 - i] * (2 + i % 6);
      }
      var verif = 11 - accum % 11;
      if (verif === 11) {
        verif = 0;
      } else if (verif === 10) {
        verif = 9;
      }
      return digit === verif;
    }
    function esEsCheck(tin) {
      var chars = tin.toUpperCase().split("");
      if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {
        var lead_replace = 0;
        switch (chars[0]) {
          case "Y":
            lead_replace = 1;
            break;
          case "Z":
            lead_replace = 2;
            break;
          default:
        }
        chars.splice(0, 1, lead_replace);
      } else {
        while (chars.length < 9) {
          chars.unshift(0);
        }
      }
      var lookup = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
      chars = chars.join("");
      var checksum2 = parseInt(chars.slice(0, 8), 10) % 23;
      return chars[8] === lookup[checksum2];
    }
    function etEeCheck(tin) {
      var full_year = tin.slice(1, 3);
      var century_digit = tin.slice(0, 1);
      switch (century_digit) {
        case "1":
        case "2":
          full_year = "18".concat(full_year);
          break;
        case "3":
        case "4":
          full_year = "19".concat(full_year);
          break;
        default:
          full_year = "20".concat(full_year);
          break;
      }
      var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var checksum2 = 0;
      var weight = 1;
      for (var i = 0; i < 10; i++) {
        checksum2 += digits[i] * weight;
        weight += 1;
        if (weight === 10) {
          weight = 1;
        }
      }
      if (checksum2 % 11 === 10) {
        checksum2 = 0;
        weight = 3;
        for (var _i3 = 0; _i3 < 10; _i3++) {
          checksum2 += digits[_i3] * weight;
          weight += 1;
          if (weight === 10) {
            weight = 1;
          }
        }
        if (checksum2 % 11 === 10) {
          return digits[10] === 0;
        }
      }
      return checksum2 % 11 === digits[10];
    }
    function fiFiCheck(tin) {
      var full_year = tin.slice(4, 6);
      var century_symbol = tin.slice(6, 7);
      switch (century_symbol) {
        case "+":
          full_year = "18".concat(full_year);
          break;
        case "-":
          full_year = "19".concat(full_year);
          break;
        default:
          full_year = "20".concat(full_year);
          break;
      }
      var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var checksum2 = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
      if (checksum2 < 10) {
        return checksum2 === parseInt(tin.slice(10), 10);
      }
      checksum2 -= 10;
      var letters_lookup = ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"];
      return letters_lookup[checksum2] === tin.slice(10);
    }
    function frBeCheck(tin) {
      if (tin.slice(2, 4) !== "00" || tin.slice(4, 6) !== "00") {
        var date = "".concat(tin.slice(0, 2), "/").concat(tin.slice(2, 4), "/").concat(tin.slice(4, 6));
        if (!(0, _isDate.default)(date, "YY/MM/DD")) {
          return false;
        }
      }
      var checksum2 = 97 - parseInt(tin.slice(0, 9), 10) % 97;
      var checkdigits = parseInt(tin.slice(9, 11), 10);
      if (checksum2 !== checkdigits) {
        checksum2 = 97 - parseInt("2".concat(tin.slice(0, 9)), 10) % 97;
        if (checksum2 !== checkdigits) {
          return false;
        }
      }
      return true;
    }
    function frFrCheck(tin) {
      tin = tin.replace(/\s/g, "");
      var checksum2 = parseInt(tin.slice(0, 10), 10) % 511;
      var checkdigits = parseInt(tin.slice(10, 13), 10);
      return checksum2 === checkdigits;
    }
    function frLuCheck(tin) {
      var date = "".concat(tin.slice(0, 4), "/").concat(tin.slice(4, 6), "/").concat(tin.slice(6, 8));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      if (!algorithms.luhnCheck(tin.slice(0, 12))) {
        return false;
      }
      return algorithms.verhoeffCheck("".concat(tin.slice(0, 11)).concat(tin[12]));
    }
    function hrHrCheck(tin) {
      return algorithms.iso7064Check(tin);
    }
    function huHuCheck(tin) {
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var checksum2 = 8;
      for (var i = 1; i < 9; i++) {
        checksum2 += digits[i] * (i + 1);
      }
      return checksum2 % 11 === digits[9];
    }
    function itItNameCheck(name) {
      var vowelflag = false;
      var xflag = false;
      for (var i = 0; i < 3; i++) {
        if (!vowelflag && /[AEIOU]/.test(name[i])) {
          vowelflag = true;
        } else if (!xflag && vowelflag && name[i] === "X") {
          xflag = true;
        } else if (i > 0) {
          if (vowelflag && !xflag) {
            if (!/[AEIOU]/.test(name[i])) {
              return false;
            }
          }
          if (xflag) {
            if (!/X/.test(name[i])) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function itItCheck(tin) {
      var chars = tin.toUpperCase().split("");
      if (!itItNameCheck(chars.slice(0, 3))) {
        return false;
      }
      if (!itItNameCheck(chars.slice(3, 6))) {
        return false;
      }
      var number_locations = [6, 7, 9, 10, 12, 13, 14];
      var number_replace = {
        L: "0",
        M: "1",
        N: "2",
        P: "3",
        Q: "4",
        R: "5",
        S: "6",
        T: "7",
        U: "8",
        V: "9"
      };
      for (var _i4 = 0, _number_locations = number_locations; _i4 < _number_locations.length; _i4++) {
        var i = _number_locations[_i4];
        if (chars[i] in number_replace) {
          chars.splice(i, 1, number_replace[chars[i]]);
        }
      }
      var month_replace = {
        A: "01",
        B: "02",
        C: "03",
        D: "04",
        E: "05",
        H: "06",
        L: "07",
        M: "08",
        P: "09",
        R: "10",
        S: "11",
        T: "12"
      };
      var month = month_replace[chars[8]];
      var day = parseInt(chars[9] + chars[10], 10);
      if (day > 40) {
        day -= 40;
      }
      if (day < 10) {
        day = "0".concat(day);
      }
      var date = "".concat(chars[6]).concat(chars[7], "/").concat(month, "/").concat(day);
      if (!(0, _isDate.default)(date, "YY/MM/DD")) {
        return false;
      }
      var checksum2 = 0;
      for (var _i5 = 1; _i5 < chars.length - 1; _i5 += 2) {
        var char_to_int = parseInt(chars[_i5], 10);
        if (isNaN(char_to_int)) {
          char_to_int = chars[_i5].charCodeAt(0) - 65;
        }
        checksum2 += char_to_int;
      }
      var odd_convert = {
        // Maps of characters at odd places
        A: 1,
        B: 0,
        C: 5,
        D: 7,
        E: 9,
        F: 13,
        G: 15,
        H: 17,
        I: 19,
        J: 21,
        K: 2,
        L: 4,
        M: 18,
        N: 20,
        O: 11,
        P: 3,
        Q: 6,
        R: 8,
        S: 12,
        T: 14,
        U: 16,
        V: 10,
        W: 22,
        X: 25,
        Y: 24,
        Z: 23,
        0: 1,
        1: 0
      };
      for (var _i6 = 0; _i6 < chars.length - 1; _i6 += 2) {
        var _char_to_int = 0;
        if (chars[_i6] in odd_convert) {
          _char_to_int = odd_convert[chars[_i6]];
        } else {
          var multiplier = parseInt(chars[_i6], 10);
          _char_to_int = 2 * multiplier + 1;
          if (multiplier > 4) {
            _char_to_int += 2;
          }
        }
        checksum2 += _char_to_int;
      }
      if (String.fromCharCode(65 + checksum2 % 26) !== chars[15]) {
        return false;
      }
      return true;
    }
    function lvLvCheck(tin) {
      tin = tin.replace(/\W/, "");
      var day = tin.slice(0, 2);
      if (day !== "32") {
        var month = tin.slice(2, 4);
        if (month !== "00") {
          var full_year = tin.slice(4, 6);
          switch (tin[6]) {
            case "0":
              full_year = "18".concat(full_year);
              break;
            case "1":
              full_year = "19".concat(full_year);
              break;
            default:
              full_year = "20".concat(full_year);
              break;
          }
          var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(day);
          if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
            return false;
          }
        }
        var checksum2 = 1101;
        var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
        for (var i = 0; i < tin.length - 1; i++) {
          checksum2 -= parseInt(tin[i], 10) * multip_lookup[i];
        }
        return parseInt(tin[10], 10) === checksum2 % 11;
      }
      return true;
    }
    function mtMtCheck(tin) {
      if (tin.length !== 9) {
        var chars = tin.toUpperCase().split("");
        while (chars.length < 8) {
          chars.unshift(0);
        }
        switch (tin[7]) {
          case "A":
          case "P":
            if (parseInt(chars[6], 10) === 0) {
              return false;
            }
            break;
          default: {
            var first_part = parseInt(chars.join("").slice(0, 5), 10);
            if (first_part > 32e3) {
              return false;
            }
            var second_part = parseInt(chars.join("").slice(5, 7), 10);
            if (first_part === second_part) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function nlNlCheck(tin) {
      return algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
        return parseInt(a, 10);
      }), 9) % 11 === parseInt(tin[8], 10);
    }
    function plPlCheck(tin) {
      if (tin.length === 10) {
        var lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];
        var _checksum2 = 0;
        for (var i = 0; i < lookup.length; i++) {
          _checksum2 += parseInt(tin[i], 10) * lookup[i];
        }
        _checksum2 %= 11;
        if (_checksum2 === 10) {
          return false;
        }
        return _checksum2 === parseInt(tin[9], 10);
      }
      var full_year = tin.slice(0, 2);
      var month = parseInt(tin.slice(2, 4), 10);
      if (month > 80) {
        full_year = "18".concat(full_year);
        month -= 80;
      } else if (month > 60) {
        full_year = "22".concat(full_year);
        month -= 60;
      } else if (month > 40) {
        full_year = "21".concat(full_year);
        month -= 40;
      } else if (month > 20) {
        full_year = "20".concat(full_year);
        month -= 20;
      } else {
        full_year = "19".concat(full_year);
      }
      if (month < 10) {
        month = "0".concat(month);
      }
      var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      var checksum2 = 0;
      var multiplier = 1;
      for (var _i7 = 0; _i7 < tin.length - 1; _i7++) {
        checksum2 += parseInt(tin[_i7], 10) * multiplier % 10;
        multiplier += 2;
        if (multiplier > 10) {
          multiplier = 1;
        } else if (multiplier === 5) {
          multiplier += 2;
        }
      }
      checksum2 = 10 - checksum2 % 10;
      return checksum2 === parseInt(tin[10], 10);
    }
    function ptBrCheck(tin) {
      if (tin.length === 11) {
        var _sum;
        var remainder;
        _sum = 0;
        if (
          // Reject known invalid CPFs
          tin === "11111111111" || tin === "22222222222" || tin === "33333333333" || tin === "44444444444" || tin === "55555555555" || tin === "66666666666" || tin === "77777777777" || tin === "88888888888" || tin === "99999999999" || tin === "00000000000"
        ) return false;
        for (var i = 1; i <= 9; i++) _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);
        remainder = _sum * 10 % 11;
        if (remainder === 10) remainder = 0;
        if (remainder !== parseInt(tin.substring(9, 10), 10)) return false;
        _sum = 0;
        for (var _i8 = 1; _i8 <= 10; _i8++) _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);
        remainder = _sum * 10 % 11;
        if (remainder === 10) remainder = 0;
        if (remainder !== parseInt(tin.substring(10, 11), 10)) return false;
        return true;
      }
      if (
        // Reject know invalid CNPJs
        tin === "00000000000000" || tin === "11111111111111" || tin === "22222222222222" || tin === "33333333333333" || tin === "44444444444444" || tin === "55555555555555" || tin === "66666666666666" || tin === "77777777777777" || tin === "88888888888888" || tin === "99999999999999"
      ) {
        return false;
      }
      var length = tin.length - 2;
      var identifiers = tin.substring(0, length);
      var verificators = tin.substring(length);
      var sum = 0;
      var pos = length - 7;
      for (var _i9 = length; _i9 >= 1; _i9--) {
        sum += identifiers.charAt(length - _i9) * pos;
        pos -= 1;
        if (pos < 2) {
          pos = 9;
        }
      }
      var result = sum % 11 < 2 ? 0 : 11 - sum % 11;
      if (result !== parseInt(verificators.charAt(0), 10)) {
        return false;
      }
      length += 1;
      identifiers = tin.substring(0, length);
      sum = 0;
      pos = length - 7;
      for (var _i10 = length; _i10 >= 1; _i10--) {
        sum += identifiers.charAt(length - _i10) * pos;
        pos -= 1;
        if (pos < 2) {
          pos = 9;
        }
      }
      result = sum % 11 < 2 ? 0 : 11 - sum % 11;
      if (result !== parseInt(verificators.charAt(1), 10)) {
        return false;
      }
      return true;
    }
    function ptPtCheck(tin) {
      var checksum2 = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
        return parseInt(a, 10);
      }), 9) % 11;
      if (checksum2 > 9) {
        return parseInt(tin[8], 10) === 0;
      }
      return checksum2 === parseInt(tin[8], 10);
    }
    function roRoCheck(tin) {
      if (tin.slice(0, 4) !== "9000") {
        var full_year = tin.slice(1, 3);
        switch (tin[0]) {
          case "1":
          case "2":
            full_year = "19".concat(full_year);
            break;
          case "3":
          case "4":
            full_year = "18".concat(full_year);
            break;
          case "5":
          case "6":
            full_year = "20".concat(full_year);
            break;
          default:
        }
        var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
        if (date.length === 8) {
          if (!(0, _isDate.default)(date, "YY/MM/DD")) {
            return false;
          }
        } else if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
        var digits = tin.split("").map(function(a) {
          return parseInt(a, 10);
        });
        var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
        var checksum2 = 0;
        for (var i = 0; i < multipliers.length; i++) {
          checksum2 += digits[i] * multipliers[i];
        }
        if (checksum2 % 11 === 10) {
          return digits[12] === 1;
        }
        return digits[12] === checksum2 % 11;
      }
      return true;
    }
    function skSkCheck(tin) {
      if (tin.length === 9) {
        tin = tin.replace(/\W/, "");
        if (tin.slice(6) === "000") {
          return false;
        }
        var full_year = parseInt(tin.slice(0, 2), 10);
        if (full_year > 53) {
          return false;
        }
        if (full_year < 10) {
          full_year = "190".concat(full_year);
        } else {
          full_year = "19".concat(full_year);
        }
        var month = parseInt(tin.slice(2, 4), 10);
        if (month > 50) {
          month -= 50;
        }
        if (month < 10) {
          month = "0".concat(month);
        }
        var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
        if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
          return false;
        }
      }
      return true;
    }
    function slSiCheck(tin) {
      var checksum2 = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a) {
        return parseInt(a, 10);
      }), 8) % 11;
      if (checksum2 === 10) {
        return parseInt(tin[7], 10) === 0;
      }
      return checksum2 === parseInt(tin[7], 10);
    }
    function svSeCheck(tin) {
      var tin_copy = tin.slice(0);
      if (tin.length > 11) {
        tin_copy = tin_copy.slice(2);
      }
      var full_year = "";
      var month = tin_copy.slice(2, 4);
      var day = parseInt(tin_copy.slice(4, 6), 10);
      if (tin.length > 11) {
        full_year = tin.slice(0, 4);
      } else {
        full_year = tin.slice(0, 2);
        if (tin.length === 11 && day < 60) {
          var current_year = (/* @__PURE__ */ new Date()).getFullYear().toString();
          var current_century = parseInt(current_year.slice(0, 2), 10);
          current_year = parseInt(current_year, 10);
          if (tin[6] === "-") {
            if (parseInt("".concat(current_century).concat(full_year), 10) > current_year) {
              full_year = "".concat(current_century - 1).concat(full_year);
            } else {
              full_year = "".concat(current_century).concat(full_year);
            }
          } else {
            full_year = "".concat(current_century - 1).concat(full_year);
            if (current_year - parseInt(full_year, 10) < 100) {
              return false;
            }
          }
        }
      }
      if (day > 60) {
        day -= 60;
      }
      if (day < 10) {
        day = "0".concat(day);
      }
      var date = "".concat(full_year, "/").concat(month, "/").concat(day);
      if (date.length === 8) {
        if (!(0, _isDate.default)(date, "YY/MM/DD")) {
          return false;
        }
      } else if (!(0, _isDate.default)(date, "YYYY/MM/DD")) {
        return false;
      }
      return algorithms.luhnCheck(tin.replace(/\W/, ""));
    }
    function ukUaCheck(tin) {
      var digits = tin.split("").map(function(a) {
        return parseInt(a, 10);
      });
      var multipliers = [-1, 5, 7, 9, 4, 6, 10, 5, 7];
      var checksum2 = 0;
      for (var i = 0; i < multipliers.length; i++) {
        checksum2 += digits[i] * multipliers[i];
      }
      return checksum2 % 11 === 10 ? digits[9] === 0 : digits[9] === checksum2 % 11;
    }
    var taxIdFormat = {
      "bg-BG": /^\d{10}$/,
      "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/,
      "de-AT": /^\d{9}$/,
      "de-DE": /^[1-9]\d{10}$/,
      "dk-DK": /^\d{6}-{0,1}\d{4}$/,
      "el-CY": /^[09]\d{7}[A-Z]$/,
      "el-GR": /^([0-4]|[7-9])\d{8}$/,
      "en-CA": /^\d{9}$/,
      "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
      "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i,
      "en-US": /^\d{2}[- ]{0,1}\d{7}$/,
      "es-AR": /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,
      "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
      "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
      "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
      "fr-BE": /^\d{11}$/,
      "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
      // Conforms both to official spec and provided example
      "fr-LU": /^\d{13}$/,
      "hr-HR": /^\d{11}$/,
      "hu-HU": /^8\d{9}$/,
      "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
      "lv-LV": /^\d{6}-{0,1}\d{5}$/,
      // Conforms both to DG TAXUD spec and original research
      "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
      "nl-NL": /^\d{9}$/,
      "pl-PL": /^\d{10,11}$/,
      "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/,
      "pt-PT": /^\d{9}$/,
      "ro-RO": /^\d{13}$/,
      "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/,
      "sl-SI": /^[1-9]\d{7}$/,
      "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/,
      "uk-UA": /^\d{10}$/
    };
    taxIdFormat["lb-LU"] = taxIdFormat["fr-LU"];
    taxIdFormat["lt-LT"] = taxIdFormat["et-EE"];
    taxIdFormat["nl-BE"] = taxIdFormat["fr-BE"];
    taxIdFormat["fr-CA"] = taxIdFormat["en-CA"];
    var taxIdCheck = {
      "bg-BG": bgBgCheck,
      "cs-CZ": csCzCheck,
      "de-AT": deAtCheck,
      "de-DE": deDeCheck,
      "dk-DK": dkDkCheck,
      "el-CY": elCyCheck,
      "el-GR": elGrCheck,
      "en-CA": isCanadianSIN,
      "en-IE": enIeCheck,
      "en-US": enUsCheck,
      "es-AR": esArCheck,
      "es-ES": esEsCheck,
      "et-EE": etEeCheck,
      "fi-FI": fiFiCheck,
      "fr-BE": frBeCheck,
      "fr-FR": frFrCheck,
      "fr-LU": frLuCheck,
      "hr-HR": hrHrCheck,
      "hu-HU": huHuCheck,
      "it-IT": itItCheck,
      "lv-LV": lvLvCheck,
      "mt-MT": mtMtCheck,
      "nl-NL": nlNlCheck,
      "pl-PL": plPlCheck,
      "pt-BR": ptBrCheck,
      "pt-PT": ptPtCheck,
      "ro-RO": roRoCheck,
      "sk-SK": skSkCheck,
      "sl-SI": slSiCheck,
      "sv-SE": svSeCheck,
      "uk-UA": ukUaCheck
    };
    taxIdCheck["lb-LU"] = taxIdCheck["fr-LU"];
    taxIdCheck["lt-LT"] = taxIdCheck["et-EE"];
    taxIdCheck["nl-BE"] = taxIdCheck["fr-BE"];
    taxIdCheck["fr-CA"] = taxIdCheck["en-CA"];
    var allsymbols = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g;
    var sanitizeRegexes = {
      "de-AT": allsymbols,
      "de-DE": /[\/\\]/g,
      "fr-BE": allsymbols
    };
    sanitizeRegexes["nl-BE"] = sanitizeRegexes["fr-BE"];
    function isTaxID(str) {
      var locale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en-US";
      (0, _assertString.default)(str);
      var strcopy = str.slice(0);
      if (locale in taxIdFormat) {
        if (locale in sanitizeRegexes) {
          strcopy = strcopy.replace(sanitizeRegexes[locale], "");
        }
        if (!taxIdFormat[locale].test(strcopy)) {
          return false;
        }
        if (locale in taxIdCheck) {
          return taxIdCheck[locale](strcopy);
        }
        return true;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isMobilePhone.js
var require_isMobilePhone = __commonJS({
  "node_modules/validator/lib/isMobilePhone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMobilePhone;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var phones = {
      "am-AM": /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
      "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
      "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
      "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
      "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
      "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
      "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
      "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
      "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
      "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
      "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
      "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/,
      "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
      "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
      "ar-SD": /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
      "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
      "ar-TN": /^(\+?216)?[2459]\d{7}$/,
      "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
      "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
      "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
      "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
      "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
      "ca-AD": /^(\+376)?[346]\d{5}$/,
      "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
      "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
      "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
      "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
      "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
      "de-LU": /^(\+352)?((6\d1)\d{6})$/,
      "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
      "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
      "el-CY": /^(\+?357?)?(9(9|6)\d{6})$/,
      "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
      "en-AU": /^(\+?61|0)4\d{8}$/,
      "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
      "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
      "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
      "en-GB": /^(\+?44|0)7\d{9}$/,
      "en-GG": /^(\+?44|0)1481\d{6}$/,
      "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
      "en-GY": /^(\+592|0)6\d{6}$/,
      "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
      "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
      "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
      "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
      "en-JM": /^(\+?876)?\d{7}$/,
      "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
      "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
      "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
      "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
      "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
      "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
      "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
      "en-MU": /^(\+?230|0)?\d{8}$/,
      "en-MW": /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
      "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
      "en-NG": /^(\+?234|0)?[789]\d{9}$/,
      "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
      "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
      "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
      "en-PH": /^(09|\+639)\d{9}$/,
      "en-RW": /^(\+?250|0)?[7]\d{8}$/,
      "en-SG": /^(\+65)?[3689]\d{7}$/,
      "en-SL": /^(\+?232|0)\d{8}$/,
      "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
      "en-UG": /^(\+?256|0)?[7]\d{8}$/,
      "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
      "en-ZA": /^(\+?27|0)\d{9}$/,
      "en-ZM": /^(\+?26)?09[567]\d{7}$/,
      "en-ZW": /^(\+263)[0-9]{9}$/,
      "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
      "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
      "es-BO": /^(\+?591)?(6|7)\d{7}$/,
      "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
      "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
      "es-CR": /^(\+506)?[2-8]\d{7}$/,
      "es-CU": /^(\+53|0053)?5\d{7}$/,
      "es-DO": /^(\+?1)?8[024]9\d{7}$/,
      "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
      "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
      "es-ES": /^(\+?34)?[6|7]\d{8}$/,
      "es-PE": /^(\+?51)?9\d{8}$/,
      "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
      "es-NI": /^(\+?505)\d{7,8}$/,
      "es-PA": /^(\+?507)\d{7,8}$/,
      "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
      "es-SV": /^(\+?503)?[67]\d{7}$/,
      "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
      "es-VE": /^(\+?58)?(2|4)\d{9}$/,
      "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
      "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
      "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
      "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
      "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
      "fr-BF": /^(\+226|0)[67]\d{7}$/,
      "fr-BJ": /^(\+229)\d{8}$/,
      "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
      "fr-CM": /^(\+?237)6[0-9]{8}$/,
      "fr-FR": /^(\+?33|0)[67]\d{8}$/,
      "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
      "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
      "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
      "fr-PF": /^(\+?689)?8[789]\d{6}$/,
      "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
      "fr-WF": /^(\+681)?\d{6}$/,
      "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
      "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
      "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
      "ir-IR": /^(\+98|0)?9\d{9}$/,
      "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
      "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
      "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
      "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
      "kk-KZ": /^(\+?7|8)?7\d{9}$/,
      "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
      "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
      "ky-KG": /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
      "lt-LT": /^(\+370|8)\d{8}$/,
      "lv-LV": /^(\+?371)2\d{7}$/,
      "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
      "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
      "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
      "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
      "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
      "nb-NO": /^(\+?47)?[49]\d{7}$/,
      "ne-NP": /^(\+?977)?9[78]\d{8}$/,
      "nl-BE": /^(\+?32|0)4\d{8}$/,
      "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
      "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
      "nn-NO": /^(\+?47)?[49]\d{7}$/,
      "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
      "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
      "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
      "pt-AO": /^(\+244)\d{9}$/,
      "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
      "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
      "ru-RU": /^(\+?7|8)?9\d{9}$/,
      "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
      "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
      "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
      "so-SO": /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
      "sq-AL": /^(\+355|0)6[789]\d{6}$/,
      "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
      "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
      "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
      "th-TH": /^(\+66|66|0)\d{9}$/,
      "tr-TR": /^(\+?90|0)?5\d{9}$/,
      "tk-TM": /^(\+993|993|8)\d{8}$/,
      "uk-UA": /^(\+?38|8)?0\d{9}$/,
      "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
      "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
      "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
      "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
      "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
      "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
      "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
      "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
    };
    phones["en-CA"] = phones["en-US"];
    phones["fr-CA"] = phones["en-CA"];
    phones["fr-BE"] = phones["nl-BE"];
    phones["zh-HK"] = phones["en-HK"];
    phones["zh-MO"] = phones["en-MO"];
    phones["ga-IE"] = phones["en-IE"];
    phones["fr-CH"] = phones["de-CH"];
    phones["it-CH"] = phones["fr-CH"];
    function isMobilePhone(str, locale, options) {
      (0, _assertString.default)(str);
      if (options && options.strictMode && !str.startsWith("+")) {
        return false;
      }
      if (Array.isArray(locale)) {
        return locale.some(function(key2) {
          if (phones.hasOwnProperty(key2)) {
            var phone2 = phones[key2];
            if (phone2.test(str)) {
              return true;
            }
          }
          return false;
        });
      } else if (locale in phones) {
        return phones[locale].test(str);
      } else if (!locale || locale === "any") {
        for (var key in phones) {
          if (phones.hasOwnProperty(key)) {
            var phone = phones[key];
            if (phone.test(str)) {
              return true;
            }
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    var locales = exports.locales = Object.keys(phones);
  }
});

// node_modules/validator/lib/isEthereumAddress.js
var require_isEthereumAddress = __commonJS({
  "node_modules/validator/lib/isEthereumAddress.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isEthereumAddress;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var eth = /^(0x)[0-9a-f]{40}$/i;
    function isEthereumAddress(str) {
      (0, _assertString.default)(str);
      return eth.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isCurrency.js
var require_isCurrency = __commonJS({
  "node_modules/validator/lib/isCurrency.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isCurrency;
    var _merge = _interopRequireDefault(require_merge());
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function currencyRegex(options) {
      var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
      options.digits_after_decimal.forEach(function(digit, index) {
        if (index !== 0) decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
      });
      var symbol = "(".concat(options.symbol.replace(/\W/, function(m) {
        return "\\".concat(m);
      }), ")").concat(options.require_symbol ? "" : "?"), negative = "-?", whole_dollar_amount_without_sep = "[1-9]\\d*", whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"), valid_whole_dollar_amounts = ["0", whole_dollar_amount_without_sep, whole_dollar_amount_with_sep], whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join("|"), ")?"), decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? "" : "?");
      var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : "");
      if (options.allow_negatives && !options.parens_for_negatives) {
        if (options.negative_sign_after_digits) {
          pattern += negative;
        } else if (options.negative_sign_before_digits) {
          pattern = negative + pattern;
        }
      }
      if (options.allow_negative_sign_placeholder) {
        pattern = "( (?!\\-))?".concat(pattern);
      } else if (options.allow_space_after_symbol) {
        pattern = " ?".concat(pattern);
      } else if (options.allow_space_after_digits) {
        pattern += "( (?!$))?";
      }
      if (options.symbol_after_digits) {
        pattern += symbol;
      } else {
        pattern = symbol + pattern;
      }
      if (options.allow_negatives) {
        if (options.parens_for_negatives) {
          pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
        } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
          pattern = negative + pattern;
        }
      }
      return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
    }
    var default_currency_options = {
      symbol: "$",
      require_symbol: false,
      allow_space_after_symbol: false,
      symbol_after_digits: false,
      allow_negatives: true,
      parens_for_negatives: false,
      negative_sign_before_digits: false,
      negative_sign_after_digits: false,
      allow_negative_sign_placeholder: false,
      thousands_separator: ",",
      decimal_separator: ".",
      allow_decimal: true,
      require_decimal: false,
      digits_after_decimal: [2],
      allow_space_after_digits: false
    };
    function isCurrency(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_currency_options);
      return currencyRegex(options).test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isBtcAddress.js
var require_isBtcAddress = __commonJS({
  "node_modules/validator/lib/isBtcAddress.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBtcAddress;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var bech32 = /^(bc1)[a-z0-9]{25,39}$/;
    var base58 = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
    function isBtcAddress(str) {
      (0, _assertString.default)(str);
      return bech32.test(str) || base58.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isISO6346.js
var require_isISO6346 = __commonJS({
  "node_modules/validator/lib/isISO6346.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isFreightContainerID = void 0;
    exports.isISO6346 = isISO6346;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;
    var isDigit = /^[0-9]$/;
    function isISO6346(str) {
      (0, _assertString.default)(str);
      str = str.toUpperCase();
      if (!isISO6346Str.test(str)) return false;
      if (str.length === 11) {
        var sum = 0;
        for (var i = 0; i < str.length - 1; i++) {
          if (!isDigit.test(str[i])) {
            var convertedCode = void 0;
            var letterCode = str.charCodeAt(i) - 55;
            if (letterCode < 11) convertedCode = letterCode;
            else if (letterCode >= 11 && letterCode <= 20) convertedCode = 12 + letterCode % 11;
            else if (letterCode >= 21 && letterCode <= 30) convertedCode = 23 + letterCode % 21;
            else convertedCode = 34 + letterCode % 31;
            sum += convertedCode * Math.pow(2, i);
          } else sum += str[i] * Math.pow(2, i);
        }
        var checkSumDigit = sum % 11;
        return Number(str[str.length - 1]) === checkSumDigit;
      }
      return true;
    }
    var isFreightContainerID = exports.isFreightContainerID = isISO6346;
  }
});

// node_modules/validator/lib/isISO6391.js
var require_isISO6391 = __commonJS({
  "node_modules/validator/lib/isISO6391.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISO6391;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isISO6391Set = /* @__PURE__ */ new Set(["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"]);
    function isISO6391(str) {
      (0, _assertString.default)(str);
      return isISO6391Set.has(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isISO8601.js
var require_isISO8601 = __commonJS({
  "node_modules/validator/lib/isISO8601.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISO8601;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    var isValidDate = function isValidDate2(str) {
      var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
      if (ordinalMatch) {
        var oYear = Number(ordinalMatch[1]);
        var oDay = Number(ordinalMatch[2]);
        if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0) return oDay <= 366;
        return oDay <= 365;
      }
      var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
      var year = match[1];
      var month = match[2];
      var day = match[3];
      var monthString = month ? "0".concat(month).slice(-2) : month;
      var dayString = day ? "0".concat(day).slice(-2) : day;
      var d = new Date("".concat(year, "-").concat(monthString || "01", "-").concat(dayString || "01"));
      if (month && day) {
        return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
      }
      return true;
    };
    function isISO8601(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(str);
      var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
      if (check && options.strict) return isValidDate(str);
      return check;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isRFC3339.js
var require_isRFC3339 = __commonJS({
  "node_modules/validator/lib/isRFC3339.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isRFC3339;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var dateFullYear = /[0-9]{4}/;
    var dateMonth = /(0[1-9]|1[0-2])/;
    var dateMDay = /([12]\d|0[1-9]|3[01])/;
    var timeHour = /([01][0-9]|2[0-3])/;
    var timeMinute = /[0-5][0-9]/;
    var timeSecond = /([0-5][0-9]|60)/;
    var timeSecFrac = /(\.[0-9]+)?/;
    var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
    var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
    var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
    var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
    var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
    var rfc3339 = new RegExp("^".concat(fullDate.source, "[ tT]").concat(fullTime.source, "$"));
    function isRFC3339(str) {
      (0, _assertString.default)(str);
      return rfc3339.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isISO31661Alpha3.js
var require_isISO31661Alpha3 = __commonJS({
  "node_modules/validator/lib/isISO31661Alpha3.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISO31661Alpha3;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validISO31661Alpha3CountriesCodes = /* @__PURE__ */ new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
    function isISO31661Alpha3(str) {
      (0, _assertString.default)(str);
      return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isISO4217.js
var require_isISO4217 = __commonJS({
  "node_modules/validator/lib/isISO4217.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CurrencyCodes = void 0;
    exports.default = isISO4217;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validISO4217CurrencyCodes = /* @__PURE__ */ new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLE", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]);
    function isISO4217(str) {
      (0, _assertString.default)(str);
      return validISO4217CurrencyCodes.has(str.toUpperCase());
    }
    var CurrencyCodes = exports.CurrencyCodes = validISO4217CurrencyCodes;
  }
});

// node_modules/validator/lib/isBase32.js
var require_isBase32 = __commonJS({
  "node_modules/validator/lib/isBase32.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBase32;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var base32 = /^[A-Z2-7]+=*$/;
    var crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;
    var defaultBase32Options = {
      crockford: false
    };
    function isBase32(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultBase32Options);
      if (options.crockford) {
        return crockfordBase32.test(str);
      }
      var len = str.length;
      if (len % 8 === 0 && base32.test(str)) {
        return true;
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isBase58.js
var require_isBase58 = __commonJS({
  "node_modules/validator/lib/isBase58.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBase58;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;
    function isBase58(str) {
      (0, _assertString.default)(str);
      if (base58Reg.test(str)) {
        return true;
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isDataURI.js
var require_isDataURI = __commonJS({
  "node_modules/validator/lib/isDataURI.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isDataURI;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validMediaType = /^[a-z]+\/[a-z0-9\-\+\._]+$/i;
    var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
    var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
    function isDataURI(str) {
      (0, _assertString.default)(str);
      var data = str.split(",");
      if (data.length < 2) {
        return false;
      }
      var attributes = data.shift().trim().split(";");
      var schemeAndMediaType = attributes.shift();
      if (schemeAndMediaType.slice(0, 5) !== "data:") {
        return false;
      }
      var mediaType = schemeAndMediaType.slice(5);
      if (mediaType !== "" && !validMediaType.test(mediaType)) {
        return false;
      }
      for (var i = 0; i < attributes.length; i++) {
        if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === "base64") && !validAttribute.test(attributes[i])) {
          return false;
        }
      }
      for (var _i = 0; _i < data.length; _i++) {
        if (!validData.test(data[_i])) {
          return false;
        }
      }
      return true;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isMagnetURI.js
var require_isMagnetURI = __commonJS({
  "node_modules/validator/lib/isMagnetURI.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMagnetURI;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var magnetURIComponent = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
    function isMagnetURI(url) {
      (0, _assertString.default)(url);
      if (url.indexOf("magnet:?") !== 0) {
        return false;
      }
      return magnetURIComponent.test(url);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/rtrim.js
var require_rtrim = __commonJS({
  "node_modules/validator/lib/rtrim.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rtrim;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function rtrim(str, chars) {
      (0, _assertString.default)(str);
      if (chars) {
        var pattern = new RegExp("[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"), "g");
        return str.replace(pattern, "");
      }
      var strIndex = str.length - 1;
      while (/\s/.test(str.charAt(strIndex))) {
        strIndex -= 1;
      }
      return str.slice(0, strIndex + 1);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/ltrim.js
var require_ltrim = __commonJS({
  "node_modules/validator/lib/ltrim.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = ltrim;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ltrim(str, chars) {
      (0, _assertString.default)(str);
      var pattern = chars ? new RegExp("^[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"), "g") : /^\s+/g;
      return str.replace(pattern, "");
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/trim.js
var require_trim = __commonJS({
  "node_modules/validator/lib/trim.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = trim2;
    var _rtrim = _interopRequireDefault(require_rtrim());
    var _ltrim = _interopRequireDefault(require_ltrim());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function trim2(str, chars) {
      return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isMailtoURI.js
var require_isMailtoURI = __commonJS({
  "node_modules/validator/lib/isMailtoURI.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMailtoURI;
    var _trim = _interopRequireDefault(require_trim());
    var _isEmail = _interopRequireDefault(require_isEmail());
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n2, i, u, a = [], f2 = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f2 = false;
          } else for (; !(f2 = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f2 = true) ;
        } catch (r2) {
          o = true, n2 = r2;
        } finally {
          try {
            if (!f2 && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f2() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function parseMailtoQueryString(queryString) {
      var allowedParams = /* @__PURE__ */ new Set(["subject", "body", "cc", "bcc"]), query = {
        cc: "",
        bcc: ""
      };
      var isParseFailed = false;
      var queryParams = queryString.split("&");
      if (queryParams.length > 4) {
        return false;
      }
      var _iterator = _createForOfIteratorHelper(queryParams), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var q = _step.value;
          var _q$split = q.split("="), _q$split2 = _slicedToArray(_q$split, 2), key = _q$split2[0], value = _q$split2[1];
          if (key && !allowedParams.has(key)) {
            isParseFailed = true;
            break;
          }
          if (value && (key === "cc" || key === "bcc")) {
            query[key] = value;
          }
          if (key) {
            allowedParams.delete(key);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return isParseFailed ? false : query;
    }
    function isMailtoURI(url, options) {
      (0, _assertString.default)(url);
      if (url.indexOf("mailto:") !== 0) {
        return false;
      }
      var _url$replace$split = url.replace("mailto:", "").split("?"), _url$replace$split2 = _slicedToArray(_url$replace$split, 2), to = _url$replace$split2[0], _url$replace$split2$ = _url$replace$split2[1], queryString = _url$replace$split2$ === void 0 ? "" : _url$replace$split2$;
      if (!to && !queryString) {
        return true;
      }
      var query = parseMailtoQueryString(queryString);
      if (!query) {
        return false;
      }
      return "".concat(to, ",").concat(query.cc, ",").concat(query.bcc).split(",").every(function(email) {
        email = (0, _trim.default)(email, " ");
        if (email) {
          return (0, _isEmail.default)(email, options);
        }
        return true;
      });
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isMimeType.js
var require_isMimeType = __commonJS({
  "node_modules/validator/lib/isMimeType.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isMimeType;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i;
    var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i;
    var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
    function isMimeType(str) {
      (0, _assertString.default)(str);
      return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isLatLong.js
var require_isLatLong = __commonJS({
  "node_modules/validator/lib/isLatLong.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLatLong;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
    var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
    var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
    var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
    var defaultLatLongOptions = {
      checkDMS: false
    };
    function isLatLong(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultLatLongOptions);
      if (!str.includes(",")) return false;
      var pair = str.split(",");
      if (pair[0].startsWith("(") && !pair[1].endsWith(")") || pair[1].endsWith(")") && !pair[0].startsWith("(")) return false;
      if (options.checkDMS) {
        return latDMS.test(pair[0]) && longDMS.test(pair[1]);
      }
      return lat.test(pair[0]) && long.test(pair[1]);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isPostalCode.js
var require_isPostalCode = __commonJS({
  "node_modules/validator/lib/isPostalCode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPostalCode;
    exports.locales = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var threeDigit = /^\d{3}$/;
    var fourDigit = /^\d{4}$/;
    var fiveDigit = /^\d{5}$/;
    var sixDigit = /^\d{6}$/;
    var patterns = {
      AD: /^AD\d{3}$/,
      AT: fourDigit,
      AU: fourDigit,
      AZ: /^AZ\d{4}$/,
      BA: /^([7-8]\d{4}$)/,
      BE: fourDigit,
      BG: fourDigit,
      BR: /^\d{5}-\d{3}$/,
      BY: /^2[1-4]\d{4}$/,
      CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
      CH: fourDigit,
      CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
      CZ: /^\d{3}\s?\d{2}$/,
      DE: fiveDigit,
      DK: fourDigit,
      DO: fiveDigit,
      DZ: fiveDigit,
      EE: fiveDigit,
      ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
      FI: fiveDigit,
      FR: /^\d{2}\s?\d{3}$/,
      GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
      GR: /^\d{3}\s?\d{2}$/,
      HR: /^([1-5]\d{4}$)/,
      HT: /^HT\d{4}$/,
      HU: fourDigit,
      ID: fiveDigit,
      IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
      IL: /^(\d{5}|\d{7})$/,
      IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
      IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
      IS: threeDigit,
      IT: fiveDigit,
      JP: /^\d{3}\-\d{4}$/,
      KE: fiveDigit,
      KR: /^(\d{5}|\d{6})$/,
      LI: /^(948[5-9]|949[0-7])$/,
      LT: /^LT\-\d{5}$/,
      LU: fourDigit,
      LV: /^LV\-\d{4}$/,
      LK: fiveDigit,
      MG: threeDigit,
      MX: fiveDigit,
      MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
      MY: fiveDigit,
      NL: /^[1-9]\d{3}\s?(?!sa|sd|ss)[a-z]{2}$/i,
      NO: fourDigit,
      NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
      NZ: fourDigit,
      PL: /^\d{2}\-\d{3}$/,
      PR: /^00[679]\d{2}([ -]\d{4})?$/,
      PT: /^\d{4}\-\d{3}?$/,
      RO: sixDigit,
      RU: sixDigit,
      SA: fiveDigit,
      SE: /^[1-9]\d{2}\s?\d{2}$/,
      SG: sixDigit,
      SI: fourDigit,
      SK: /^\d{3}\s?\d{2}$/,
      TH: fiveDigit,
      TN: fourDigit,
      TW: /^\d{3}(\d{2})?$/,
      UA: fiveDigit,
      US: /^\d{5}(-\d{4})?$/,
      ZA: fourDigit,
      ZM: fiveDigit
    };
    var locales = exports.locales = Object.keys(patterns);
    function isPostalCode(str, locale) {
      (0, _assertString.default)(str);
      if (locale in patterns) {
        return patterns[locale].test(str);
      } else if (locale === "any") {
        for (var key in patterns) {
          if (patterns.hasOwnProperty(key)) {
            var pattern = patterns[key];
            if (pattern.test(str)) {
              return true;
            }
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
  }
});

// node_modules/validator/lib/escape.js
var require_escape = __commonJS({
  "node_modules/validator/lib/escape.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = escape;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function escape(str) {
      (0, _assertString.default)(str);
      return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/unescape.js
var require_unescape = __commonJS({
  "node_modules/validator/lib/unescape.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = unescape2;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function unescape2(str) {
      (0, _assertString.default)(str);
      return str.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&");
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/blacklist.js
var require_blacklist = __commonJS({
  "node_modules/validator/lib/blacklist.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = blacklist;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function blacklist(str, chars) {
      (0, _assertString.default)(str);
      return str.replace(new RegExp("[".concat(chars, "]+"), "g"), "");
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/stripLow.js
var require_stripLow = __commonJS({
  "node_modules/validator/lib/stripLow.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = stripLow;
    var _assertString = _interopRequireDefault(require_assertString());
    var _blacklist = _interopRequireDefault(require_blacklist());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stripLow(str, keep_new_lines) {
      (0, _assertString.default)(str);
      var chars = keep_new_lines ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
      return (0, _blacklist.default)(str, chars);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/whitelist.js
var require_whitelist = __commonJS({
  "node_modules/validator/lib/whitelist.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = whitelist;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function whitelist(str, chars) {
      (0, _assertString.default)(str);
      return str.replace(new RegExp("[^".concat(chars, "]+"), "g"), "");
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isWhitelisted.js
var require_isWhitelisted = __commonJS({
  "node_modules/validator/lib/isWhitelisted.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isWhitelisted;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isWhitelisted(str, chars) {
      (0, _assertString.default)(str);
      for (var i = str.length - 1; i >= 0; i--) {
        if (chars.indexOf(str[i]) === -1) {
          return false;
        }
      }
      return true;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/normalizeEmail.js
var require_normalizeEmail = __commonJS({
  "node_modules/validator/lib/normalizeEmail.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = normalizeEmail;
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_normalize_email_options = {
      // The following options apply to all email addresses
      // Lowercases the local part of the email address.
      // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
      // The domain is always lowercased, as per RFC 1035
      all_lowercase: true,
      // The following conversions are specific to GMail
      // Lowercases the local part of the GMail address (known to be case-insensitive)
      gmail_lowercase: true,
      // Removes dots from the local part of the email address, as that's ignored by GMail
      gmail_remove_dots: true,
      // Removes the subaddress (e.g. "+foo") from the email address
      gmail_remove_subaddress: true,
      // Conversts the googlemail.com domain to gmail.com
      gmail_convert_googlemaildotcom: true,
      // The following conversions are specific to Outlook.com / Windows Live / Hotmail
      // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
      outlookdotcom_lowercase: true,
      // Removes the subaddress (e.g. "+foo") from the email address
      outlookdotcom_remove_subaddress: true,
      // The following conversions are specific to Yahoo
      // Lowercases the local part of the Yahoo address (known to be case-insensitive)
      yahoo_lowercase: true,
      // Removes the subaddress (e.g. "-foo") from the email address
      yahoo_remove_subaddress: true,
      // The following conversions are specific to Yandex
      // Lowercases the local part of the Yandex address (known to be case-insensitive)
      yandex_lowercase: true,
      // The following conversions are specific to iCloud
      // Lowercases the local part of the iCloud address (known to be case-insensitive)
      icloud_lowercase: true,
      // Removes the subaddress (e.g. "+foo") from the email address
      icloud_remove_subaddress: true
    };
    var icloud_domains = ["icloud.com", "me.com"];
    var outlookdotcom_domains = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"];
    var yahoo_domains = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"];
    var yandex_domains = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
    function dotsReplacer(match) {
      if (match.length > 1) {
        return match;
      }
      return "";
    }
    function normalizeEmail(email, options) {
      options = (0, _merge.default)(options, default_normalize_email_options);
      var raw_parts = email.split("@");
      var domain = raw_parts.pop();
      var user = raw_parts.join("@");
      var parts = [user, domain];
      parts[1] = parts[1].toLowerCase();
      if (parts[1] === "gmail.com" || parts[1] === "googlemail.com") {
        if (options.gmail_remove_subaddress) {
          parts[0] = parts[0].split("+")[0];
        }
        if (options.gmail_remove_dots) {
          parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
        }
        if (!parts[0].length) {
          return false;
        }
        if (options.all_lowercase || options.gmail_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
        parts[1] = options.gmail_convert_googlemaildotcom ? "gmail.com" : parts[1];
      } else if (icloud_domains.indexOf(parts[1]) >= 0) {
        if (options.icloud_remove_subaddress) {
          parts[0] = parts[0].split("+")[0];
        }
        if (!parts[0].length) {
          return false;
        }
        if (options.all_lowercase || options.icloud_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
      } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
        if (options.outlookdotcom_remove_subaddress) {
          parts[0] = parts[0].split("+")[0];
        }
        if (!parts[0].length) {
          return false;
        }
        if (options.all_lowercase || options.outlookdotcom_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
      } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
        if (options.yahoo_remove_subaddress) {
          var components = parts[0].split("-");
          parts[0] = components.length > 1 ? components.slice(0, -1).join("-") : components[0];
        }
        if (!parts[0].length) {
          return false;
        }
        if (options.all_lowercase || options.yahoo_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
      } else if (yandex_domains.indexOf(parts[1]) >= 0) {
        if (options.all_lowercase || options.yandex_lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
        parts[1] = "yandex.ru";
      } else if (options.all_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
      return parts.join("@");
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isSlug.js
var require_isSlug = __commonJS({
  "node_modules/validator/lib/isSlug.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isSlug;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var charsetRegex = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
    function isSlug(str) {
      (0, _assertString.default)(str);
      return charsetRegex.test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isLicensePlate.js
var require_isLicensePlate = __commonJS({
  "node_modules/validator/lib/isLicensePlate.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isLicensePlate;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var validators3 = {
      "cs-CZ": function csCZ(str) {
        return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(str);
      },
      "de-DE": function deDE(str) {
        return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|AÖ|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|BÖ|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|FÜ|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|GÖ|GP|GR|GS|GT|GÜ|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|LÖ|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|MÜ|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|NÖ|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|TÜ|ÜB|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|WÜ|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BÜD|BUL|BÜR|BÜS|BÜZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DÜW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FLÖ|FOR|FRG|FRI|FRW|FTL|FÜS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HMÜ|HOG|HOH|HOL|HOM|HOR|HÖS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JÜL|KEH|KEL|KEM|KIB|KLE|KLZ|KÖN|KÖT|KÖZ|KRU|KÜN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LÖB|LOS|LRO|LSZ|LÜN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MÜB|MÜR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|ÖHR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PLÖ|PRÜ|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RÜD|RÜG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SLÜ|SLZ|SMÜ|SOB|SOG|SOK|SÖM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SÜW|SWA|SZB|TBB|TDO|TET|TIR|TÖL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WÜM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(str);
      },
      "de-LI": function deLI(str) {
        return /^FL[- ]?\d{1,5}[UZ]?$/.test(str);
      },
      "en-IN": function enIN(str) {
        return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(str);
      },
      "es-AR": function esAR(str) {
        return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(str);
      },
      "fi-FI": function fiFI(str) {
        return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(str);
      },
      "hu-HU": function huHU(str) {
        return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(str);
      },
      "pt-BR": function ptBR(str) {
        return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(str);
      },
      "pt-PT": function ptPT(str) {
        return /^([A-Z]{2}|[0-9]{2})[ -·]?([A-Z]{2}|[0-9]{2})[ -·]?([A-Z]{2}|[0-9]{2})$/.test(str);
      },
      "sq-AL": function sqAL(str) {
        return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(str);
      },
      "sv-SE": function svSE(str) {
        return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-ZÅÄÖ ]{2,7}$)/.test(str.trim());
      },
      "en-PK": function enPK(str) {
        return /(^[A-Z]{2}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{3}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{4}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]((\s|-){0,1})[0-9]{4}((\s|-)[0-9]{2}){0,1}$)/.test(str.trim());
      }
    };
    function isLicensePlate(str, locale) {
      (0, _assertString.default)(str);
      if (locale in validators3) {
        return validators3[locale](str);
      } else if (locale === "any") {
        for (var key in validators3) {
          var validator2 = validators3[key];
          if (validator2(str)) {
            return true;
          }
        }
        return false;
      }
      throw new Error("Invalid locale '".concat(locale, "'"));
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isStrongPassword.js
var require_isStrongPassword = __commonJS({
  "node_modules/validator/lib/isStrongPassword.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isStrongPassword;
    var _merge = _interopRequireDefault(require_merge());
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var upperCaseRegex = /^[A-Z]$/;
    var lowerCaseRegex = /^[a-z]$/;
    var numberRegex = /^[0-9]$/;
    var symbolRegex = /^[-#!$@£%^&*()_+|~=`{}\[\]:";'<>?,.\/\\ ]$/;
    var defaultOptions2 = {
      minLength: 8,
      minLowercase: 1,
      minUppercase: 1,
      minNumbers: 1,
      minSymbols: 1,
      returnScore: false,
      pointsPerUnique: 1,
      pointsPerRepeat: 0.5,
      pointsForContainingLower: 10,
      pointsForContainingUpper: 10,
      pointsForContainingNumber: 10,
      pointsForContainingSymbol: 10
    };
    function countChars(str) {
      var result = {};
      Array.from(str).forEach(function(char) {
        var curVal = result[char];
        if (curVal) {
          result[char] += 1;
        } else {
          result[char] = 1;
        }
      });
      return result;
    }
    function analyzePassword(password) {
      var charMap = countChars(password);
      var analysis = {
        length: password.length,
        uniqueChars: Object.keys(charMap).length,
        uppercaseCount: 0,
        lowercaseCount: 0,
        numberCount: 0,
        symbolCount: 0
      };
      Object.keys(charMap).forEach(function(char) {
        if (upperCaseRegex.test(char)) {
          analysis.uppercaseCount += charMap[char];
        } else if (lowerCaseRegex.test(char)) {
          analysis.lowercaseCount += charMap[char];
        } else if (numberRegex.test(char)) {
          analysis.numberCount += charMap[char];
        } else if (symbolRegex.test(char)) {
          analysis.symbolCount += charMap[char];
        }
      });
      return analysis;
    }
    function scorePassword(analysis, scoringOptions) {
      var points = 0;
      points += analysis.uniqueChars * scoringOptions.pointsPerUnique;
      points += (analysis.length - analysis.uniqueChars) * scoringOptions.pointsPerRepeat;
      if (analysis.lowercaseCount > 0) {
        points += scoringOptions.pointsForContainingLower;
      }
      if (analysis.uppercaseCount > 0) {
        points += scoringOptions.pointsForContainingUpper;
      }
      if (analysis.numberCount > 0) {
        points += scoringOptions.pointsForContainingNumber;
      }
      if (analysis.symbolCount > 0) {
        points += scoringOptions.pointsForContainingSymbol;
      }
      return points;
    }
    function isStrongPassword(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      (0, _assertString.default)(str);
      var analysis = analyzePassword(str);
      options = (0, _merge.default)(options || {}, defaultOptions2);
      if (options.returnScore) {
        return scorePassword(analysis, options);
      }
      return analysis.length >= options.minLength && analysis.lowercaseCount >= options.minLowercase && analysis.uppercaseCount >= options.minUppercase && analysis.numberCount >= options.minNumbers && analysis.symbolCount >= options.minSymbols;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/validator/lib/isVAT.js
var require_isVAT = __commonJS({
  "node_modules/validator/lib/isVAT.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isVAT;
    exports.vatMatchers = void 0;
    var _assertString = _interopRequireDefault(require_assertString());
    var algorithms = _interopRequireWildcard(require_algorithms());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n2, u, i) : n2[u] = e[u];
      }
      return n2.default = e, t && t.set(e, n2), n2;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var AU = function AU2(str) {
      var match = str.match(/^(AU)?(\d{11})$/);
      if (!match) {
        return false;
      }
      var weights = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
      str = str.replace(/^AU/, "");
      var ABN = (parseInt(str.slice(0, 1), 10) - 1).toString() + str.slice(1);
      var total = 0;
      for (var i = 0; i < 11; i++) {
        total += weights[i] * ABN.charAt(i);
      }
      return total !== 0 && total % 89 === 0;
    };
    var CH = function CH2(str) {
      var hasValidCheckNumber = function hasValidCheckNumber2(digits) {
        var lastDigit = digits.pop();
        var weights = [5, 4, 3, 2, 7, 6, 5, 4];
        var calculatedCheckNumber = (11 - digits.reduce(function(acc, el, idx) {
          return acc + el * weights[idx];
        }, 0) % 11) % 11;
        return lastDigit === calculatedCheckNumber;
      };
      return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(str) && hasValidCheckNumber(str.match(/\d/g).map(function(el) {
        return +el;
      }));
    };
    var PT = function PT2(str) {
      var match = str.match(/^(PT)?(\d{9})$/);
      if (!match) {
        return false;
      }
      var tin = match[2];
      var checksum2 = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a) {
        return parseInt(a, 10);
      }), 9) % 11;
      if (checksum2 > 9) {
        return parseInt(tin[8], 10) === 0;
      }
      return checksum2 === parseInt(tin[8], 10);
    };
    var vatMatchers = exports.vatMatchers = {
      /**
       * European Union VAT identification numbers
       */
      AT: function AT(str) {
        return /^(AT)?U\d{8}$/.test(str);
      },
      BE: function BE(str) {
        return /^(BE)?\d{10}$/.test(str);
      },
      BG: function BG(str) {
        return /^(BG)?\d{9,10}$/.test(str);
      },
      HR: function HR(str) {
        return /^(HR)?\d{11}$/.test(str);
      },
      CY: function CY(str) {
        return /^(CY)?\w{9}$/.test(str);
      },
      CZ: function CZ(str) {
        return /^(CZ)?\d{8,10}$/.test(str);
      },
      DK: function DK(str) {
        return /^(DK)?\d{8}$/.test(str);
      },
      EE: function EE(str) {
        return /^(EE)?\d{9}$/.test(str);
      },
      FI: function FI(str) {
        return /^(FI)?\d{8}$/.test(str);
      },
      FR: function FR(str) {
        return /^(FR)?\w{2}\d{9}$/.test(str);
      },
      DE: function DE(str) {
        return /^(DE)?\d{9}$/.test(str);
      },
      EL: function EL(str) {
        return /^(EL)?\d{9}$/.test(str);
      },
      HU: function HU(str) {
        return /^(HU)?\d{8}$/.test(str);
      },
      IE: function IE(str) {
        return /^(IE)?\d{7}\w{1}(W)?$/.test(str);
      },
      IT: function IT(str) {
        return /^(IT)?\d{11}$/.test(str);
      },
      LV: function LV(str) {
        return /^(LV)?\d{11}$/.test(str);
      },
      LT: function LT(str) {
        return /^(LT)?\d{9,12}$/.test(str);
      },
      LU: function LU(str) {
        return /^(LU)?\d{8}$/.test(str);
      },
      MT: function MT(str) {
        return /^(MT)?\d{8}$/.test(str);
      },
      NL: function NL(str) {
        return /^(NL)?\d{9}B\d{2}$/.test(str);
      },
      PL: function PL(str) {
        return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(str);
      },
      PT,
      RO: function RO(str) {
        return /^(RO)?\d{2,10}$/.test(str);
      },
      SK: function SK(str) {
        return /^(SK)?\d{10}$/.test(str);
      },
      SI: function SI(str) {
        return /^(SI)?\d{8}$/.test(str);
      },
      ES: function ES(str) {
        return /^(ES)?\w\d{7}[A-Z]$/.test(str);
      },
      SE: function SE(str) {
        return /^(SE)?\d{12}$/.test(str);
      },
      /**
       * VAT numbers of non-EU countries
       */
      AL: function AL(str) {
        return /^(AL)?\w{9}[A-Z]$/.test(str);
      },
      MK: function MK(str) {
        return /^(MK)?\d{13}$/.test(str);
      },
      AU,
      BY: function BY(str) {
        return /^(УНП )?\d{9}$/.test(str);
      },
      CA: function CA(str) {
        return /^(CA)?\d{9}$/.test(str);
      },
      IS: function IS(str) {
        return /^(IS)?\d{5,6}$/.test(str);
      },
      IN: function IN(str) {
        return /^(IN)?\d{15}$/.test(str);
      },
      ID: function ID(str) {
        return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(str);
      },
      IL: function IL(str) {
        return /^(IL)?\d{9}$/.test(str);
      },
      KZ: function KZ(str) {
        return /^(KZ)?\d{12}$/.test(str);
      },
      NZ: function NZ(str) {
        return /^(NZ)?\d{9}$/.test(str);
      },
      NG: function NG(str) {
        return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(str);
      },
      NO: function NO(str) {
        return /^(NO)?\d{9}MVA$/.test(str);
      },
      PH: function PH(str) {
        return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(str);
      },
      RU: function RU(str) {
        return /^(RU)?(\d{10}|\d{12})$/.test(str);
      },
      SM: function SM(str) {
        return /^(SM)?\d{5}$/.test(str);
      },
      SA: function SA(str) {
        return /^(SA)?\d{15}$/.test(str);
      },
      RS: function RS(str) {
        return /^(RS)?\d{9}$/.test(str);
      },
      CH,
      TR: function TR(str) {
        return /^(TR)?\d{10}$/.test(str);
      },
      UA: function UA(str) {
        return /^(UA)?\d{12}$/.test(str);
      },
      GB: function GB(str) {
        return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(str);
      },
      UZ: function UZ(str) {
        return /^(UZ)?\d{9}$/.test(str);
      },
      /**
       * VAT numbers of Latin American countries
       */
      AR: function AR(str) {
        return /^(AR)?\d{11}$/.test(str);
      },
      BO: function BO(str) {
        return /^(BO)?\d{7}$/.test(str);
      },
      BR: function BR(str) {
        return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(str);
      },
      CL: function CL(str) {
        return /^(CL)?\d{8}-\d{1}$/.test(str);
      },
      CO: function CO(str) {
        return /^(CO)?\d{10}$/.test(str);
      },
      CR: function CR(str) {
        return /^(CR)?\d{9,12}$/.test(str);
      },
      EC: function EC(str) {
        return /^(EC)?\d{13}$/.test(str);
      },
      SV: function SV(str) {
        return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(str);
      },
      GT: function GT(str) {
        return /^(GT)?\d{7}-\d{1}$/.test(str);
      },
      HN: function HN(str) {
        return /^(HN)?$/.test(str);
      },
      MX: function MX(str) {
        return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(str);
      },
      NI: function NI(str) {
        return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(str);
      },
      PA: function PA(str) {
        return /^(PA)?$/.test(str);
      },
      PY: function PY(str) {
        return /^(PY)?\d{6,8}-\d{1}$/.test(str);
      },
      PE: function PE(str) {
        return /^(PE)?\d{11}$/.test(str);
      },
      DO: function DO(str) {
        return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(str);
      },
      UY: function UY(str) {
        return /^(UY)?\d{12}$/.test(str);
      },
      VE: function VE(str) {
        return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(str);
      }
    };
    function isVAT(str, countryCode) {
      (0, _assertString.default)(str);
      (0, _assertString.default)(countryCode);
      if (countryCode in vatMatchers) {
        return vatMatchers[countryCode](str);
      }
      throw new Error("Invalid country code: '".concat(countryCode, "'"));
    }
  }
});

// node_modules/validator/index.js
var require_validator = __commonJS({
  "node_modules/validator/index.js"(exports, module) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _toDate = _interopRequireDefault(require_toDate());
    var _toFloat = _interopRequireDefault(require_toFloat());
    var _toInt = _interopRequireDefault(require_toInt());
    var _toBoolean = _interopRequireDefault(require_toBoolean());
    var _equals = _interopRequireDefault(require_equals());
    var _contains = _interopRequireDefault(require_contains());
    var _matches = _interopRequireDefault(require_matches());
    var _isEmail = _interopRequireDefault(require_isEmail());
    var _isURL = _interopRequireDefault(require_isURL());
    var _isMACAddress = _interopRequireDefault(require_isMACAddress());
    var _isIP = _interopRequireDefault(require_isIP());
    var _isIPRange = _interopRequireDefault(require_isIPRange());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isDate = _interopRequireDefault(require_isDate());
    var _isTime = _interopRequireDefault(require_isTime());
    var _isBoolean = _interopRequireDefault(require_isBoolean());
    var _isLocale = _interopRequireDefault(require_isLocale());
    var _isAbaRouting = _interopRequireDefault(require_isAbaRouting());
    var _isAlpha = _interopRequireWildcard(require_isAlpha());
    var _isAlphanumeric = _interopRequireWildcard(require_isAlphanumeric());
    var _isNumeric = _interopRequireDefault(require_isNumeric());
    var _isPassportNumber = _interopRequireDefault(require_isPassportNumber());
    var _isPort = _interopRequireDefault(require_isPort());
    var _isLowercase = _interopRequireDefault(require_isLowercase());
    var _isUppercase = _interopRequireDefault(require_isUppercase());
    var _isIMEI = _interopRequireDefault(require_isIMEI());
    var _isAscii = _interopRequireDefault(require_isAscii());
    var _isFullWidth = _interopRequireDefault(require_isFullWidth());
    var _isHalfWidth = _interopRequireDefault(require_isHalfWidth());
    var _isVariableWidth = _interopRequireDefault(require_isVariableWidth());
    var _isMultibyte = _interopRequireDefault(require_isMultibyte());
    var _isSemVer = _interopRequireDefault(require_isSemVer());
    var _isSurrogatePair = _interopRequireDefault(require_isSurrogatePair());
    var _isInt = _interopRequireDefault(require_isInt());
    var _isFloat = _interopRequireWildcard(require_isFloat());
    var _isDecimal = _interopRequireDefault(require_isDecimal());
    var _isHexadecimal = _interopRequireDefault(require_isHexadecimal());
    var _isOctal = _interopRequireDefault(require_isOctal());
    var _isDivisibleBy = _interopRequireDefault(require_isDivisibleBy());
    var _isHexColor = _interopRequireDefault(require_isHexColor());
    var _isRgbColor = _interopRequireDefault(require_isRgbColor());
    var _isHSL = _interopRequireDefault(require_isHSL());
    var _isISRC = _interopRequireDefault(require_isISRC());
    var _isIBAN = _interopRequireWildcard(require_isIBAN());
    var _isBIC = _interopRequireDefault(require_isBIC());
    var _isMD = _interopRequireDefault(require_isMD5());
    var _isHash = _interopRequireDefault(require_isHash());
    var _isJWT = _interopRequireDefault(require_isJWT());
    var _isJSON = _interopRequireDefault(require_isJSON());
    var _isEmpty = _interopRequireDefault(require_isEmpty());
    var _isLength = _interopRequireDefault(require_isLength());
    var _isByteLength = _interopRequireDefault(require_isByteLength());
    var _isUUID = _interopRequireDefault(require_isUUID());
    var _isMongoId = _interopRequireDefault(require_isMongoId());
    var _isAfter = _interopRequireDefault(require_isAfter());
    var _isBefore = _interopRequireDefault(require_isBefore());
    var _isIn = _interopRequireDefault(require_isIn());
    var _isLuhnNumber = _interopRequireDefault(require_isLuhnNumber());
    var _isCreditCard = _interopRequireDefault(require_isCreditCard());
    var _isIdentityCard = _interopRequireDefault(require_isIdentityCard());
    var _isEAN = _interopRequireDefault(require_isEAN());
    var _isISIN = _interopRequireDefault(require_isISIN());
    var _isISBN = _interopRequireDefault(require_isISBN());
    var _isISSN = _interopRequireDefault(require_isISSN());
    var _isTaxID = _interopRequireDefault(require_isTaxID());
    var _isMobilePhone = _interopRequireWildcard(require_isMobilePhone());
    var _isEthereumAddress = _interopRequireDefault(require_isEthereumAddress());
    var _isCurrency = _interopRequireDefault(require_isCurrency());
    var _isBtcAddress = _interopRequireDefault(require_isBtcAddress());
    var _isISO = require_isISO6346();
    var _isISO2 = _interopRequireDefault(require_isISO6391());
    var _isISO3 = _interopRequireDefault(require_isISO8601());
    var _isRFC = _interopRequireDefault(require_isRFC3339());
    var _isISO31661Alpha = _interopRequireDefault(require_isISO31661Alpha2());
    var _isISO31661Alpha2 = _interopRequireDefault(require_isISO31661Alpha3());
    var _isISO4 = _interopRequireDefault(require_isISO4217());
    var _isBase = _interopRequireDefault(require_isBase32());
    var _isBase2 = _interopRequireDefault(require_isBase58());
    var _isBase3 = _interopRequireDefault(require_isBase64());
    var _isDataURI = _interopRequireDefault(require_isDataURI());
    var _isMagnetURI = _interopRequireDefault(require_isMagnetURI());
    var _isMailtoURI = _interopRequireDefault(require_isMailtoURI());
    var _isMimeType = _interopRequireDefault(require_isMimeType());
    var _isLatLong = _interopRequireDefault(require_isLatLong());
    var _isPostalCode = _interopRequireWildcard(require_isPostalCode());
    var _ltrim = _interopRequireDefault(require_ltrim());
    var _rtrim = _interopRequireDefault(require_rtrim());
    var _trim = _interopRequireDefault(require_trim());
    var _escape = _interopRequireDefault(require_escape());
    var _unescape = _interopRequireDefault(require_unescape());
    var _stripLow = _interopRequireDefault(require_stripLow());
    var _whitelist = _interopRequireDefault(require_whitelist());
    var _blacklist = _interopRequireDefault(require_blacklist());
    var _isWhitelisted = _interopRequireDefault(require_isWhitelisted());
    var _normalizeEmail = _interopRequireDefault(require_normalizeEmail());
    var _isSlug = _interopRequireDefault(require_isSlug());
    var _isLicensePlate = _interopRequireDefault(require_isLicensePlate());
    var _isStrongPassword = _interopRequireDefault(require_isStrongPassword());
    var _isVAT = _interopRequireDefault(require_isVAT());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n2 = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n2, u, i) : n2[u] = e[u];
      }
      return n2.default = e, t && t.set(e, n2), n2;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var version3 = "13.12.0";
    var validator2 = {
      version: version3,
      toDate: _toDate.default,
      toFloat: _toFloat.default,
      toInt: _toInt.default,
      toBoolean: _toBoolean.default,
      equals: _equals.default,
      contains: _contains.default,
      matches: _matches.default,
      isEmail: _isEmail.default,
      isURL: _isURL.default,
      isMACAddress: _isMACAddress.default,
      isIP: _isIP.default,
      isIPRange: _isIPRange.default,
      isFQDN: _isFQDN.default,
      isBoolean: _isBoolean.default,
      isIBAN: _isIBAN.default,
      isBIC: _isBIC.default,
      isAbaRouting: _isAbaRouting.default,
      isAlpha: _isAlpha.default,
      isAlphaLocales: _isAlpha.locales,
      isAlphanumeric: _isAlphanumeric.default,
      isAlphanumericLocales: _isAlphanumeric.locales,
      isNumeric: _isNumeric.default,
      isPassportNumber: _isPassportNumber.default,
      isPort: _isPort.default,
      isLowercase: _isLowercase.default,
      isUppercase: _isUppercase.default,
      isAscii: _isAscii.default,
      isFullWidth: _isFullWidth.default,
      isHalfWidth: _isHalfWidth.default,
      isVariableWidth: _isVariableWidth.default,
      isMultibyte: _isMultibyte.default,
      isSemVer: _isSemVer.default,
      isSurrogatePair: _isSurrogatePair.default,
      isInt: _isInt.default,
      isIMEI: _isIMEI.default,
      isFloat: _isFloat.default,
      isFloatLocales: _isFloat.locales,
      isDecimal: _isDecimal.default,
      isHexadecimal: _isHexadecimal.default,
      isOctal: _isOctal.default,
      isDivisibleBy: _isDivisibleBy.default,
      isHexColor: _isHexColor.default,
      isRgbColor: _isRgbColor.default,
      isHSL: _isHSL.default,
      isISRC: _isISRC.default,
      isMD5: _isMD.default,
      isHash: _isHash.default,
      isJWT: _isJWT.default,
      isJSON: _isJSON.default,
      isEmpty: _isEmpty.default,
      isLength: _isLength.default,
      isLocale: _isLocale.default,
      isByteLength: _isByteLength.default,
      isUUID: _isUUID.default,
      isMongoId: _isMongoId.default,
      isAfter: _isAfter.default,
      isBefore: _isBefore.default,
      isIn: _isIn.default,
      isLuhnNumber: _isLuhnNumber.default,
      isCreditCard: _isCreditCard.default,
      isIdentityCard: _isIdentityCard.default,
      isEAN: _isEAN.default,
      isISIN: _isISIN.default,
      isISBN: _isISBN.default,
      isISSN: _isISSN.default,
      isMobilePhone: _isMobilePhone.default,
      isMobilePhoneLocales: _isMobilePhone.locales,
      isPostalCode: _isPostalCode.default,
      isPostalCodeLocales: _isPostalCode.locales,
      isEthereumAddress: _isEthereumAddress.default,
      isCurrency: _isCurrency.default,
      isBtcAddress: _isBtcAddress.default,
      isISO6346: _isISO.isISO6346,
      isFreightContainerID: _isISO.isFreightContainerID,
      isISO6391: _isISO2.default,
      isISO8601: _isISO3.default,
      isRFC3339: _isRFC.default,
      isISO31661Alpha2: _isISO31661Alpha.default,
      isISO31661Alpha3: _isISO31661Alpha2.default,
      isISO4217: _isISO4.default,
      isBase32: _isBase.default,
      isBase58: _isBase2.default,
      isBase64: _isBase3.default,
      isDataURI: _isDataURI.default,
      isMagnetURI: _isMagnetURI.default,
      isMailtoURI: _isMailtoURI.default,
      isMimeType: _isMimeType.default,
      isLatLong: _isLatLong.default,
      ltrim: _ltrim.default,
      rtrim: _rtrim.default,
      trim: _trim.default,
      escape: _escape.default,
      unescape: _unescape.default,
      stripLow: _stripLow.default,
      whitelist: _whitelist.default,
      blacklist: _blacklist.default,
      isWhitelisted: _isWhitelisted.default,
      normalizeEmail: _normalizeEmail.default,
      toString,
      isSlug: _isSlug.default,
      isStrongPassword: _isStrongPassword.default,
      isTaxID: _isTaxID.default,
      isDate: _isDate.default,
      isTime: _isTime.default,
      isLicensePlate: _isLicensePlate.default,
      isVAT: _isVAT.default,
      ibanLocales: _isIBAN.locales
    };
    var _default = exports.default = validator2;
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/tronweb/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/tronweb/node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/tronweb/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/tronweb/node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/tronweb/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/tronweb/node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/tronweb/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/tronweb/node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/tronweb/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/tronweb/node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b2) => {
      const anum2 = numeric.test(a);
      const bnum = numeric.test(b2);
      if (anum2 && bnum) {
        a = +a;
        b2 = +b2;
      }
      return a === b2 ? 0 : anum2 && !bnum ? -1 : bnum && !anum2 ? 1 : a < b2 ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b2) => compareIdentifiers(b2, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/tronweb/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/tronweb/node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = require_constants();
    var { safeRe: re, safeSrc: src, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version3, options) {
        options = parseOptions(options);
        if (version3 instanceof _SemVer) {
          if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
            return version3;
          } else {
            version3 = version3.version;
          }
        } else if (typeof version3 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
        }
        if (version3.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version3, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version3}`);
        }
        this.raw = version3;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id2) => {
            if (/^[0-9]+$/.test(id2)) {
              const num = +id2;
              if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                return num;
              }
            }
            return id2;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b2 = other.prerelease[i];
          debug("prerelease compare", i, a, b2);
          if (a === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b2) {
            continue;
          } else {
            return compareIdentifiers(a, b2);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b2 = other.build[i];
          debug("build compare", i, a, b2);
          if (a === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b2) {
            continue;
          } else {
            return compareIdentifiers(a, b2);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
            const match = `-${identifier}`.match(r);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/tronweb/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver();
    var parse = (version3, options, throwErrors = false) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse;
  }
});

// node_modules/tronweb/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/valid.js"(exports, module) {
    var parse = require_parse();
    var valid = (version3, options) => {
      const v = parse(version3, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/tronweb/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/clean.js"(exports, module) {
    var parse = require_parse();
    var clean = (version3, options) => {
      const s = parse(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/tronweb/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version3, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version3 instanceof SemVer ? version3.version : version3,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/tronweb/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/diff.js"(exports, module) {
    var parse = require_parse();
    var diff = (version1, version22) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/tronweb/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  }
});

// node_modules/tronweb/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  }
});

// node_modules/tronweb/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});

// node_modules/tronweb/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse = require_parse();
    var prerelease = (version3, options) => {
      const parsed = parse(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/tronweb/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare2 = (a, b2, loose) => new SemVer(a, loose).compare(new SemVer(b2, loose));
    module.exports = compare2;
  }
});

// node_modules/tronweb/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare2 = require_compare();
    var rcompare = (a, b2, loose) => compare2(b2, a, loose);
    module.exports = rcompare;
  }
});

// node_modules/tronweb/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare2 = require_compare();
    var compareLoose = (a, b2) => compare2(a, b2, true);
    module.exports = compareLoose;
  }
});

// node_modules/tronweb/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a, b2, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b2, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/tronweb/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b2) => compareBuild(a, b2, loose));
    module.exports = sort;
  }
});

// node_modules/tronweb/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b2) => compareBuild(b2, a, loose));
    module.exports = rsort;
  }
});

// node_modules/tronweb/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/gt.js"(exports, module) {
    var compare2 = require_compare();
    var gt = (a, b2, loose) => compare2(a, b2, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/tronweb/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/lt.js"(exports, module) {
    var compare2 = require_compare();
    var lt = (a, b2, loose) => compare2(a, b2, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/tronweb/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/eq.js"(exports, module) {
    var compare2 = require_compare();
    var eq = (a, b2, loose) => compare2(a, b2, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/tronweb/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/neq.js"(exports, module) {
    var compare2 = require_compare();
    var neq = (a, b2, loose) => compare2(a, b2, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/tronweb/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/gte.js"(exports, module) {
    var compare2 = require_compare();
    var gte = (a, b2, loose) => compare2(a, b2, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/tronweb/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/lte.js"(exports, module) {
    var compare2 = require_compare();
    var lte = (a, b2, loose) => compare2(a, b2, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/tronweb/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b2, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a === b2;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a !== b2;
        case "":
        case "=":
        case "==":
          return eq(a, b2, loose);
        case "!=":
          return neq(a, b2, loose);
        case ">":
          return gt(a, b2, loose);
        case ">=":
          return gte(a, b2, loose);
        case "<":
          return lt(a, b2, loose);
        case "<=":
          return lte(a, b2, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/tronweb/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version3, options) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version3.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/tronweb/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/tronweb/node_modules/semver/internal/lrucache.js"(exports, module) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/tronweb/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/tronweb/node_modules/semver/classes/range.js"(exports, module) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version3) {
        if (!version3) {
          return false;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version3, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version3, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/tronweb/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/tronweb/node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version3) {
        debug("Comparator.test", version3, this.options.loose);
        if (this.semver === ANY || version3 === ANY) {
          return true;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version3, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/tronweb/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/tronweb/node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range();
    var satisfies = (version3, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    };
    module.exports = satisfies;
  }
});

// node_modules/tronweb/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/tronweb/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/tronweb/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/tronweb/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/tronweb/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/tronweb/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version3, range, hilo, options) => {
      version3 = new SemVer(version3, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/tronweb/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version3, range, options) => outside(version3, range, ">", options);
    module.exports = gtr;
  }
});

// node_modules/tronweb/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version3, range, options) => outside(version3, range, "<", options);
    module.exports = ltr;
  }
});

// node_modules/tronweb/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  }
});

// node_modules/tronweb/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b2) => compare2(a, b2, options));
      for (const version3 of v) {
        const included = satisfies(version3, range, options);
        if (included) {
          prev = version3;
          if (!first) {
            first = version3;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/tronweb/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/tronweb/node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b2, options) => {
      if (!a) {
        return b2;
      }
      const comp = compare2(a.semver, b2.semver, options);
      return comp > 0 ? a : comp < 0 ? b2 : b2.operator === ">" && a.operator === ">=" ? b2 : a;
    };
    var lowerLT = (a, b2, options) => {
      if (!a) {
        return b2;
      }
      const comp = compare2(a.semver, b2.semver, options);
      return comp < 0 ? a : comp > 0 ? b2 : b2.operator === "<" && a.operator === "<=" ? b2 : a;
    };
    module.exports = subset;
  }
});

// node_modules/tronweb/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/tronweb/node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/google-protobuf/google-protobuf.js
var require_google_protobuf = __commonJS({
  "node_modules/google-protobuf/google-protobuf.js"(exports) {
    var aa = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b2, c) {
      a != Array.prototype && a != Object.prototype && (a[b2] = c.value);
    };
    var e = "undefined" != typeof window && window === exports ? exports : "undefined" != typeof global && null != global ? global : exports;
    function ba(a, b2) {
      if (b2) {
        var c = e;
        a = a.split(".");
        for (var d = 0; d < a.length - 1; d++) {
          var f2 = a[d];
          f2 in c || (c[f2] = {});
          c = c[f2];
        }
        a = a[a.length - 1];
        d = c[a];
        b2 = b2(d);
        b2 != d && null != b2 && aa(c, a, { configurable: true, writable: true, value: b2 });
      }
    }
    function ca(a) {
      var b2 = 0;
      return function() {
        return b2 < a.length ? { done: false, value: a[b2++] } : { done: true };
      };
    }
    function da() {
      da = function() {
      };
      e.Symbol || (e.Symbol = ea);
    }
    function fa(a, b2) {
      this.a = a;
      aa(this, "description", { configurable: true, writable: true, value: b2 });
    }
    fa.prototype.toString = function() {
      return this.a;
    };
    var ea = /* @__PURE__ */ function() {
      function a(c) {
        if (this instanceof a) throw new TypeError("Symbol is not a constructor");
        return new fa("jscomp_symbol_" + (c || "") + "_" + b2++, c);
      }
      var b2 = 0;
      return a;
    }();
    function ha() {
      da();
      var a = e.Symbol.iterator;
      a || (a = e.Symbol.iterator = e.Symbol("Symbol.iterator"));
      "function" != typeof Array.prototype[a] && aa(Array.prototype, a, { configurable: true, writable: true, value: function() {
        return ia(ca(this));
      } });
      ha = function() {
      };
    }
    function ia(a) {
      ha();
      a = { next: a };
      a[e.Symbol.iterator] = function() {
        return this;
      };
      return a;
    }
    function ja(a, b2) {
      ha();
      a instanceof String && (a += "");
      var c = 0, d = { next: function() {
        if (c < a.length) {
          var f2 = c++;
          return { value: b2(f2, a[f2]), done: false };
        }
        d.next = function() {
          return { done: true, value: void 0 };
        };
        return d.next();
      } };
      d[Symbol.iterator] = function() {
        return d;
      };
      return d;
    }
    ba("Array.prototype.entries", function(a) {
      return a ? a : function() {
        return ja(this, function(b2, c) {
          return [b2, c];
        });
      };
    });
    var ka = exports || self;
    function g(a, b2, c) {
      a = a.split(".");
      c = c || ka;
      a[0] in c || "undefined" == typeof c.execScript || c.execScript("var " + a[0]);
      for (var d; a.length && (d = a.shift()); ) a.length || void 0 === b2 ? c[d] && c[d] !== Object.prototype[d] ? c = c[d] : c = c[d] = {} : c[d] = b2;
    }
    function k(a) {
      var b2 = typeof a;
      if ("object" == b2) if (a) {
        if (a instanceof Array) return "array";
        if (a instanceof Object) return b2;
        var c = Object.prototype.toString.call(a);
        if ("[object Window]" == c) return "object";
        if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";
        if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function";
      } else return "null";
      else if ("function" == b2 && "undefined" == typeof a.call) return "object";
      return b2;
    }
    function la(a) {
      var b2 = typeof a;
      return "object" == b2 && null != a || "function" == b2;
    }
    function ma(a, b2, c) {
      g(a, b2, c);
    }
    function na(a, b2) {
      function c() {
      }
      c.prototype = b2.prototype;
      a.prototype = new c();
      a.prototype.constructor = a;
    }
    var oa = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    function pa(a, b2) {
      for (var c, d, f2 = 1; f2 < arguments.length; f2++) {
        d = arguments[f2];
        for (c in d) a[c] = d[c];
        for (var h = 0; h < oa.length; h++) c = oa[h], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
      }
    }
    var qa = Array.prototype.forEach ? function(a, b2) {
      Array.prototype.forEach.call(a, b2, void 0);
    } : function(a, b2) {
      for (var c = a.length, d = "string" === typeof a ? a.split("") : a, f2 = 0; f2 < c; f2++) f2 in d && b2.call(void 0, d[f2], f2, a);
    };
    var l = Array.prototype.map ? function(a, b2) {
      return Array.prototype.map.call(a, b2, void 0);
    } : function(a, b2) {
      for (var c = a.length, d = Array(c), f2 = "string" === typeof a ? a.split("") : a, h = 0; h < c; h++) h in f2 && (d[h] = b2.call(void 0, f2[h], h, a));
      return d;
    };
    function ra(a, b2, c) {
      return 2 >= arguments.length ? Array.prototype.slice.call(a, b2) : Array.prototype.slice.call(a, b2, c);
    }
    function sa(a, b2, c, d) {
      var f2 = "Assertion failed";
      if (c) {
        f2 += ": " + c;
        var h = d;
      } else a && (f2 += ": " + a, h = b2);
      throw Error(f2, h || []);
    }
    function n2(a, b2, c) {
      for (var d = [], f2 = 2; f2 < arguments.length; ++f2) d[f2 - 2] = arguments[f2];
      a || sa("", null, b2, d);
      return a;
    }
    function ta(a, b2, c) {
      for (var d = [], f2 = 2; f2 < arguments.length; ++f2) d[f2 - 2] = arguments[f2];
      "string" !== typeof a && sa("Expected string but got %s: %s.", [k(a), a], b2, d);
    }
    function ua(a, b2, c) {
      for (var d = [], f2 = 2; f2 < arguments.length; ++f2) d[f2 - 2] = arguments[f2];
      Array.isArray(a) || sa("Expected array but got %s: %s.", [k(a), a], b2, d);
    }
    function p(a, b2) {
      for (var c = [], d = 1; d < arguments.length; ++d) c[d - 1] = arguments[d];
      throw Error("Failure" + (a ? ": " + a : ""), c);
    }
    function q(a, b2, c, d) {
      for (var f2 = [], h = 3; h < arguments.length; ++h) f2[h - 3] = arguments[h];
      a instanceof b2 || sa("Expected instanceof %s but got %s.", [va(b2), va(a)], c, f2);
    }
    function va(a) {
      return a instanceof Function ? a.displayName || a.name || "unknown type name" : a instanceof Object ? a.constructor.displayName || a.constructor.name || Object.prototype.toString.call(a) : null === a ? "null" : typeof a;
    }
    function r(a, b2) {
      this.c = a;
      this.b = b2;
      this.a = {};
      this.arrClean = true;
      if (0 < this.c.length) {
        for (a = 0; a < this.c.length; a++) {
          b2 = this.c[a];
          var c = b2[0];
          this.a[c.toString()] = new wa(c, b2[1]);
        }
        this.arrClean = true;
      }
    }
    g("jspb.Map", r, void 0);
    r.prototype.g = function() {
      if (this.arrClean) {
        if (this.b) {
          var a = this.a, b2;
          for (b2 in a) if (Object.prototype.hasOwnProperty.call(a, b2)) {
            var c = a[b2].a;
            c && c.g();
          }
        }
      } else {
        this.c.length = 0;
        a = u(this);
        a.sort();
        for (b2 = 0; b2 < a.length; b2++) {
          var d = this.a[a[b2]];
          (c = d.a) && c.g();
          this.c.push([d.key, d.value]);
        }
        this.arrClean = true;
      }
      return this.c;
    };
    r.prototype.toArray = r.prototype.g;
    r.prototype.Mc = function(a, b2) {
      for (var c = this.g(), d = [], f2 = 0; f2 < c.length; f2++) {
        var h = this.a[c[f2][0].toString()];
        v(this, h);
        var m = h.a;
        m ? (n2(b2), d.push([h.key, b2(a, m)])) : d.push([h.key, h.value]);
      }
      return d;
    };
    r.prototype.toObject = r.prototype.Mc;
    r.fromObject = function(a, b2, c) {
      b2 = new r([], b2);
      for (var d = 0; d < a.length; d++) {
        var f2 = a[d][0], h = c(a[d][1]);
        b2.set(f2, h);
      }
      return b2;
    };
    function w(a) {
      this.a = 0;
      this.b = a;
    }
    w.prototype.next = function() {
      return this.a < this.b.length ? { done: false, value: this.b[this.a++] } : { done: true, value: void 0 };
    };
    "undefined" != typeof Symbol && (w.prototype[Symbol.iterator] = function() {
      return this;
    });
    r.prototype.Jb = function() {
      return u(this).length;
    };
    r.prototype.getLength = r.prototype.Jb;
    r.prototype.clear = function() {
      this.a = {};
      this.arrClean = false;
    };
    r.prototype.clear = r.prototype.clear;
    r.prototype.Cb = function(a) {
      a = a.toString();
      var b2 = this.a.hasOwnProperty(a);
      delete this.a[a];
      this.arrClean = false;
      return b2;
    };
    r.prototype.del = r.prototype.Cb;
    r.prototype.Eb = function() {
      var a = [], b2 = u(this);
      b2.sort();
      for (var c = 0; c < b2.length; c++) {
        var d = this.a[b2[c]];
        a.push([d.key, d.value]);
      }
      return a;
    };
    r.prototype.getEntryList = r.prototype.Eb;
    r.prototype.entries = function() {
      var a = [], b2 = u(this);
      b2.sort();
      for (var c = 0; c < b2.length; c++) {
        var d = this.a[b2[c]];
        a.push([d.key, v(this, d)]);
      }
      return new w(a);
    };
    r.prototype.entries = r.prototype.entries;
    r.prototype.keys = function() {
      var a = [], b2 = u(this);
      b2.sort();
      for (var c = 0; c < b2.length; c++) a.push(this.a[b2[c]].key);
      return new w(a);
    };
    r.prototype.keys = r.prototype.keys;
    r.prototype.values = function() {
      var a = [], b2 = u(this);
      b2.sort();
      for (var c = 0; c < b2.length; c++) a.push(v(this, this.a[b2[c]]));
      return new w(a);
    };
    r.prototype.values = r.prototype.values;
    r.prototype.forEach = function(a, b2) {
      var c = u(this);
      c.sort();
      for (var d = 0; d < c.length; d++) {
        var f2 = this.a[c[d]];
        a.call(b2, v(this, f2), f2.key, this);
      }
    };
    r.prototype.forEach = r.prototype.forEach;
    r.prototype.set = function(a, b2) {
      var c = new wa(a);
      this.b ? (c.a = b2, c.value = b2.g()) : c.value = b2;
      this.a[a.toString()] = c;
      this.arrClean = false;
      return this;
    };
    r.prototype.set = r.prototype.set;
    function v(a, b2) {
      return a.b ? (b2.a || (b2.a = new a.b(b2.value)), b2.a) : b2.value;
    }
    r.prototype.get = function(a) {
      if (a = this.a[a.toString()]) return v(this, a);
    };
    r.prototype.get = r.prototype.get;
    r.prototype.has = function(a) {
      return a.toString() in this.a;
    };
    r.prototype.has = r.prototype.has;
    r.prototype.Jc = function(a, b2, c, d, f2) {
      var h = u(this);
      h.sort();
      for (var m = 0; m < h.length; m++) {
        var t = this.a[h[m]];
        b2.Va(a);
        c.call(b2, 1, t.key);
        this.b ? d.call(b2, 2, v(this, t), f2) : d.call(b2, 2, t.value);
        b2.Ya();
      }
    };
    r.prototype.serializeBinary = r.prototype.Jc;
    r.deserializeBinary = function(a, b2, c, d, f2, h, m) {
      for (; b2.oa() && !b2.bb(); ) {
        var t = b2.c;
        1 == t ? h = c.call(b2) : 2 == t && (a.b ? (n2(f2), m || (m = new a.b()), d.call(b2, m, f2)) : m = d.call(b2));
      }
      n2(void 0 != h);
      n2(void 0 != m);
      a.set(h, m);
    };
    function u(a) {
      a = a.a;
      var b2 = [], c;
      for (c in a) Object.prototype.hasOwnProperty.call(a, c) && b2.push(c);
      return b2;
    }
    function wa(a, b2) {
      this.key = a;
      this.value = b2;
      this.a = void 0;
    }
    function xa(a) {
      if (8192 >= a.length) return String.fromCharCode.apply(null, a);
      for (var b2 = "", c = 0; c < a.length; c += 8192) b2 += String.fromCharCode.apply(null, ra(a, c, c + 8192));
      return b2;
    }
    var ya = { "\0": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\x0B", '"': '\\"', "\\": "\\\\", "<": "\\u003C" };
    var za = { "'": "\\'" };
    var Aa = {};
    var x = null;
    function Ba(a, b2) {
      void 0 === b2 && (b2 = 0);
      Ca();
      b2 = Aa[b2];
      for (var c = [], d = 0; d < a.length; d += 3) {
        var f2 = a[d], h = d + 1 < a.length, m = h ? a[d + 1] : 0, t = d + 2 < a.length, B = t ? a[d + 2] : 0, M = f2 >> 2;
        f2 = (f2 & 3) << 4 | m >> 4;
        m = (m & 15) << 2 | B >> 6;
        B &= 63;
        t || (B = 64, h || (m = 64));
        c.push(b2[M], b2[f2], b2[m] || "", b2[B] || "");
      }
      return c.join("");
    }
    function Da(a) {
      var b2 = a.length, c = 3 * b2 / 4;
      c % 3 ? c = Math.floor(c) : -1 != "=.".indexOf(a[b2 - 1]) && (c = -1 != "=.".indexOf(a[b2 - 2]) ? c - 2 : c - 1);
      var d = new Uint8Array(c), f2 = 0;
      Ea(a, function(h) {
        d[f2++] = h;
      });
      return d.subarray(0, f2);
    }
    function Ea(a, b2) {
      function c(B) {
        for (; d < a.length; ) {
          var M = a.charAt(d++), La = x[M];
          if (null != La) return La;
          if (!/^[\s\xa0]*$/.test(M)) throw Error("Unknown base64 encoding at char: " + M);
        }
        return B;
      }
      Ca();
      for (var d = 0; ; ) {
        var f2 = c(-1), h = c(0), m = c(64), t = c(64);
        if (64 === t && -1 === f2) break;
        b2(f2 << 2 | h >> 4);
        64 != m && (b2(h << 4 & 240 | m >> 2), 64 != t && b2(m << 6 & 192 | t));
      }
    }
    function Ca() {
      if (!x) {
        x = {};
        for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b2 = ["+/=", "+/", "-_=", "-_.", "-_"], c = 0; 5 > c; c++) {
          var d = a.concat(b2[c].split(""));
          Aa[c] = d;
          for (var f2 = 0; f2 < d.length; f2++) {
            var h = d[f2];
            void 0 === x[h] && (x[h] = f2);
          }
        }
      }
    }
    g("jspb.ConstBinaryMessage", function() {
    }, void 0);
    g("jspb.BinaryMessage", function() {
    }, void 0);
    g("jspb.BinaryConstants.FieldType", { yb: -1, ee: 1, FLOAT: 2, ke: 3, te: 4, je: 5, xb: 6, wb: 7, BOOL: 8, re: 9, ie: 10, le: 11, ce: 12, se: 13, ge: 14, me: 15, ne: 16, oe: 17, pe: 18, he: 30, ve: 31 }, void 0);
    g("jspb.BinaryConstants.WireType", { yb: -1, ue: 0, xb: 1, de: 2, qe: 3, fe: 4, wb: 5 }, void 0);
    g("jspb.BinaryConstants.FieldTypeToWireType", function(a) {
      switch (a) {
        case 5:
        case 3:
        case 13:
        case 4:
        case 17:
        case 18:
        case 8:
        case 14:
        case 31:
          return 0;
        case 1:
        case 6:
        case 16:
        case 30:
          return 1;
        case 9:
        case 11:
        case 12:
          return 2;
        case 2:
        case 7:
        case 15:
          return 5;
        default:
          return -1;
      }
    }, void 0);
    g("jspb.BinaryConstants.INVALID_FIELD_NUMBER", -1, void 0);
    g("jspb.BinaryConstants.FLOAT32_EPS", 1401298464324817e-60, void 0);
    g("jspb.BinaryConstants.FLOAT32_MIN", 11754943508222875e-54, void 0);
    g("jspb.BinaryConstants.FLOAT32_MAX", 34028234663852886e22, void 0);
    g("jspb.BinaryConstants.FLOAT64_EPS", 5e-324, void 0);
    g("jspb.BinaryConstants.FLOAT64_MIN", 22250738585072014e-324, void 0);
    g("jspb.BinaryConstants.FLOAT64_MAX", 17976931348623157e292, void 0);
    g("jspb.BinaryConstants.TWO_TO_20", 1048576, void 0);
    g("jspb.BinaryConstants.TWO_TO_23", 8388608, void 0);
    g("jspb.BinaryConstants.TWO_TO_31", 2147483648, void 0);
    g("jspb.BinaryConstants.TWO_TO_32", 4294967296, void 0);
    g("jspb.BinaryConstants.TWO_TO_52", 4503599627370496, void 0);
    g("jspb.BinaryConstants.TWO_TO_63", 9223372036854776e3, void 0);
    g("jspb.BinaryConstants.TWO_TO_64", 18446744073709552e3, void 0);
    g("jspb.BinaryConstants.ZERO_HASH", "\0\0\0\0\0\0\0\0", void 0);
    var y = 0;
    var z = 0;
    g("jspb.utils.getSplit64Low", function() {
      return y;
    }, void 0);
    g("jspb.utils.getSplit64High", function() {
      return z;
    }, void 0);
    function Fa(a) {
      var b2 = a >>> 0;
      a = Math.floor((a - b2) / 4294967296) >>> 0;
      y = b2;
      z = a;
    }
    g("jspb.utils.splitUint64", Fa, void 0);
    function A(a) {
      var b2 = 0 > a;
      a = Math.abs(a);
      var c = a >>> 0;
      a = Math.floor((a - c) / 4294967296);
      a >>>= 0;
      b2 && (a = ~a >>> 0, c = (~c >>> 0) + 1, 4294967295 < c && (c = 0, a++, 4294967295 < a && (a = 0)));
      y = c;
      z = a;
    }
    g("jspb.utils.splitInt64", A, void 0);
    function Ga(a) {
      var b2 = 0 > a;
      a = 2 * Math.abs(a);
      Fa(a);
      a = y;
      var c = z;
      b2 && (0 == a ? 0 == c ? c = a = 4294967295 : (c--, a = 4294967295) : a--);
      y = a;
      z = c;
    }
    g("jspb.utils.splitZigzag64", Ga, void 0);
    function Ha(a) {
      var b2 = 0 > a ? 1 : 0;
      a = b2 ? -a : a;
      if (0 === a) 0 < 1 / a ? y = z = 0 : (z = 0, y = 2147483648);
      else if (isNaN(a)) z = 0, y = 2147483647;
      else if (34028234663852886e22 < a) z = 0, y = (b2 << 31 | 2139095040) >>> 0;
      else if (11754943508222875e-54 > a) a = Math.round(a / Math.pow(2, -149)), z = 0, y = (b2 << 31 | a) >>> 0;
      else {
        var c = Math.floor(Math.log(a) / Math.LN2);
        a *= Math.pow(2, -c);
        a = Math.round(8388608 * a);
        16777216 <= a && ++c;
        z = 0;
        y = (b2 << 31 | c + 127 << 23 | a & 8388607) >>> 0;
      }
    }
    g("jspb.utils.splitFloat32", Ha, void 0);
    function Ia(a) {
      var b2 = 0 > a ? 1 : 0;
      a = b2 ? -a : a;
      if (0 === a) z = 0 < 1 / a ? 0 : 2147483648, y = 0;
      else if (isNaN(a)) z = 2147483647, y = 4294967295;
      else if (17976931348623157e292 < a) z = (b2 << 31 | 2146435072) >>> 0, y = 0;
      else if (22250738585072014e-324 > a) a /= Math.pow(2, -1074), z = (b2 << 31 | a / 4294967296) >>> 0, y = a >>> 0;
      else {
        var c = a, d = 0;
        if (2 <= c) for (; 2 <= c && 1023 > d; ) d++, c /= 2;
        else for (; 1 > c && -1022 < d; ) c *= 2, d--;
        a *= Math.pow(2, -d);
        z = (b2 << 31 | d + 1023 << 20 | 1048576 * a & 1048575) >>> 0;
        y = 4503599627370496 * a >>> 0;
      }
    }
    g("jspb.utils.splitFloat64", Ia, void 0);
    function C(a) {
      var b2 = a.charCodeAt(4), c = a.charCodeAt(5), d = a.charCodeAt(6), f2 = a.charCodeAt(7);
      y = a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24) >>> 0;
      z = b2 + (c << 8) + (d << 16) + (f2 << 24) >>> 0;
    }
    g("jspb.utils.splitHash64", C, void 0);
    function D(a, b2) {
      return 4294967296 * b2 + (a >>> 0);
    }
    g("jspb.utils.joinUint64", D, void 0);
    function E(a, b2) {
      var c = b2 & 2147483648;
      c && (a = ~a + 1 >>> 0, b2 = ~b2 >>> 0, 0 == a && (b2 = b2 + 1 >>> 0));
      a = D(a, b2);
      return c ? -a : a;
    }
    g("jspb.utils.joinInt64", E, void 0);
    function Ja(a, b2, c) {
      var d = b2 >> 31;
      return c(a << 1 ^ d, (b2 << 1 | a >>> 31) ^ d);
    }
    g("jspb.utils.toZigzag64", Ja, void 0);
    function Ka(a, b2) {
      return Ma(a, b2, E);
    }
    g("jspb.utils.joinZigzag64", Ka, void 0);
    function Ma(a, b2, c) {
      var d = -(a & 1);
      return c((a >>> 1 | b2 << 31) ^ d, b2 >>> 1 ^ d);
    }
    g("jspb.utils.fromZigzag64", Ma, void 0);
    function Na(a) {
      var b2 = 2 * (a >> 31) + 1, c = a >>> 23 & 255;
      a &= 8388607;
      return 255 == c ? a ? NaN : Infinity * b2 : 0 == c ? b2 * Math.pow(2, -149) * a : b2 * Math.pow(2, c - 150) * (a + Math.pow(2, 23));
    }
    g("jspb.utils.joinFloat32", Na, void 0);
    function Oa(a, b2) {
      var c = 2 * (b2 >> 31) + 1, d = b2 >>> 20 & 2047;
      a = 4294967296 * (b2 & 1048575) + a;
      return 2047 == d ? a ? NaN : Infinity * c : 0 == d ? c * Math.pow(2, -1074) * a : c * Math.pow(2, d - 1075) * (a + 4503599627370496);
    }
    g("jspb.utils.joinFloat64", Oa, void 0);
    function Pa(a, b2) {
      return String.fromCharCode(a >>> 0 & 255, a >>> 8 & 255, a >>> 16 & 255, a >>> 24 & 255, b2 >>> 0 & 255, b2 >>> 8 & 255, b2 >>> 16 & 255, b2 >>> 24 & 255);
    }
    g("jspb.utils.joinHash64", Pa, void 0);
    g("jspb.utils.DIGITS", "0123456789abcdef".split(""), void 0);
    function F(a, b2) {
      function c(f2, h) {
        f2 = f2 ? String(f2) : "";
        return h ? "0000000".slice(f2.length) + f2 : f2;
      }
      if (2097151 >= b2) return "" + D(a, b2);
      var d = (a >>> 24 | b2 << 8) >>> 0 & 16777215;
      b2 = b2 >> 16 & 65535;
      a = (a & 16777215) + 6777216 * d + 6710656 * b2;
      d += 8147497 * b2;
      b2 *= 2;
      1e7 <= a && (d += Math.floor(a / 1e7), a %= 1e7);
      1e7 <= d && (b2 += Math.floor(d / 1e7), d %= 1e7);
      return c(b2, 0) + c(d, b2) + c(a, 1);
    }
    g("jspb.utils.joinUnsignedDecimalString", F, void 0);
    function G(a, b2) {
      var c = b2 & 2147483648;
      c && (a = ~a + 1 >>> 0, b2 = ~b2 + (0 == a ? 1 : 0) >>> 0);
      a = F(a, b2);
      return c ? "-" + a : a;
    }
    g("jspb.utils.joinSignedDecimalString", G, void 0);
    function Qa(a, b2) {
      C(a);
      a = y;
      var c = z;
      return b2 ? G(a, c) : F(a, c);
    }
    g("jspb.utils.hash64ToDecimalString", Qa, void 0);
    g("jspb.utils.hash64ArrayToDecimalStrings", function(a, b2) {
      for (var c = Array(a.length), d = 0; d < a.length; d++) c[d] = Qa(a[d], b2);
      return c;
    }, void 0);
    function H(a) {
      function b2(m, t) {
        for (var B = 0; 8 > B && (1 !== m || 0 < t); B++) t = m * f2[B] + t, f2[B] = t & 255, t >>>= 8;
      }
      function c() {
        for (var m = 0; 8 > m; m++) f2[m] = ~f2[m] & 255;
      }
      n2(0 < a.length);
      var d = false;
      "-" === a[0] && (d = true, a = a.slice(1));
      for (var f2 = [0, 0, 0, 0, 0, 0, 0, 0], h = 0; h < a.length; h++) b2(10, a.charCodeAt(h) - 48);
      d && (c(), b2(1, 1));
      return xa(f2);
    }
    g("jspb.utils.decimalStringToHash64", H, void 0);
    g("jspb.utils.splitDecimalString", function(a) {
      C(H(a));
    }, void 0);
    function Ra(a) {
      return String.fromCharCode(10 > a ? 48 + a : 87 + a);
    }
    function Sa(a) {
      return 97 <= a ? a - 97 + 10 : a - 48;
    }
    g("jspb.utils.hash64ToHexString", function(a) {
      var b2 = Array(18);
      b2[0] = "0";
      b2[1] = "x";
      for (var c = 0; 8 > c; c++) {
        var d = a.charCodeAt(7 - c);
        b2[2 * c + 2] = Ra(d >> 4);
        b2[2 * c + 3] = Ra(d & 15);
      }
      return b2.join("");
    }, void 0);
    g("jspb.utils.hexStringToHash64", function(a) {
      a = a.toLowerCase();
      n2(18 == a.length);
      n2("0" == a[0]);
      n2("x" == a[1]);
      for (var b2 = "", c = 0; 8 > c; c++) b2 = String.fromCharCode(16 * Sa(a.charCodeAt(2 * c + 2)) + Sa(a.charCodeAt(2 * c + 3))) + b2;
      return b2;
    }, void 0);
    g("jspb.utils.hash64ToNumber", function(a, b2) {
      C(a);
      a = y;
      var c = z;
      return b2 ? E(a, c) : D(a, c);
    }, void 0);
    g("jspb.utils.numberToHash64", function(a) {
      A(a);
      return Pa(y, z);
    }, void 0);
    g("jspb.utils.countVarints", function(a, b2, c) {
      for (var d = 0, f2 = b2; f2 < c; f2++) d += a[f2] >> 7;
      return c - b2 - d;
    }, void 0);
    g("jspb.utils.countVarintFields", function(a, b2, c, d) {
      var f2 = 0;
      d *= 8;
      if (128 > d) for (; b2 < c && a[b2++] == d; ) for (f2++; ; ) {
        var h = a[b2++];
        if (0 == (h & 128)) break;
      }
      else for (; b2 < c; ) {
        for (h = d; 128 < h; ) {
          if (a[b2] != (h & 127 | 128)) return f2;
          b2++;
          h >>= 7;
        }
        if (a[b2++] != h) break;
        for (f2++; h = a[b2++], 0 != (h & 128); ) ;
      }
      return f2;
    }, void 0);
    function Ta(a, b2, c, d, f2) {
      var h = 0;
      if (128 > d) for (; b2 < c && a[b2++] == d; ) h++, b2 += f2;
      else for (; b2 < c; ) {
        for (var m = d; 128 < m; ) {
          if (a[b2++] != (m & 127 | 128)) return h;
          m >>= 7;
        }
        if (a[b2++] != m) break;
        h++;
        b2 += f2;
      }
      return h;
    }
    g("jspb.utils.countFixed32Fields", function(a, b2, c, d) {
      return Ta(a, b2, c, 8 * d + 5, 4);
    }, void 0);
    g("jspb.utils.countFixed64Fields", function(a, b2, c, d) {
      return Ta(a, b2, c, 8 * d + 1, 8);
    }, void 0);
    g("jspb.utils.countDelimitedFields", function(a, b2, c, d) {
      var f2 = 0;
      for (d = 8 * d + 2; b2 < c; ) {
        for (var h = d; 128 < h; ) {
          if (a[b2++] != (h & 127 | 128)) return f2;
          h >>= 7;
        }
        if (a[b2++] != h) break;
        f2++;
        for (var m = 0, t = 1; h = a[b2++], m += (h & 127) * t, t *= 128, 0 != (h & 128); ) ;
        b2 += m;
      }
      return f2;
    }, void 0);
    g("jspb.utils.debugBytesToTextFormat", function(a) {
      var b2 = '"';
      if (a) {
        a = Ua(a);
        for (var c = 0; c < a.length; c++) b2 += "\\x", 16 > a[c] && (b2 += "0"), b2 += a[c].toString(16);
      }
      return b2 + '"';
    }, void 0);
    g("jspb.utils.debugScalarToTextFormat", function(a) {
      if ("string" === typeof a) {
        a = String(a);
        for (var b2 = ['"'], c = 0; c < a.length; c++) {
          var d = a.charAt(c), f2 = d.charCodeAt(0), h = c + 1, m;
          if (!(m = ya[d])) {
            if (!(31 < f2 && 127 > f2)) if (f2 = d, f2 in za) d = za[f2];
            else if (f2 in ya) d = za[f2] = ya[f2];
            else {
              m = f2.charCodeAt(0);
              if (31 < m && 127 > m) d = f2;
              else {
                if (256 > m) {
                  if (d = "\\x", 16 > m || 256 < m) d += "0";
                } else d = "\\u", 4096 > m && (d += "0");
                d += m.toString(16).toUpperCase();
              }
              d = za[f2] = d;
            }
            m = d;
          }
          b2[h] = m;
        }
        b2.push('"');
        a = b2.join("");
      } else a = a.toString();
      return a;
    }, void 0);
    g("jspb.utils.stringToByteArray", function(a) {
      for (var b2 = new Uint8Array(a.length), c = 0; c < a.length; c++) {
        var d = a.charCodeAt(c);
        if (255 < d) throw Error("Conversion error: string contains codepoint outside of byte range");
        b2[c] = d;
      }
      return b2;
    }, void 0);
    function Ua(a) {
      if (a.constructor === Uint8Array) return a;
      if (a.constructor === ArrayBuffer) return new Uint8Array(a);
      if (a.constructor === Array) return new Uint8Array(a);
      if (a.constructor === String) return Da(a);
      if (a instanceof Uint8Array) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
      p("Type not convertible to Uint8Array.");
      return new Uint8Array(0);
    }
    g("jspb.utils.byteSourceToUint8Array", Ua, void 0);
    function I(a, b2, c) {
      this.b = null;
      this.a = this.c = this.h = 0;
      this.v = false;
      a && this.H(a, b2, c);
    }
    g("jspb.BinaryDecoder", I, void 0);
    var Va = [];
    I.getInstanceCacheLength = function() {
      return Va.length;
    };
    function Wa(a, b2, c) {
      if (Va.length) {
        var d = Va.pop();
        a && d.H(a, b2, c);
        return d;
      }
      return new I(a, b2, c);
    }
    I.alloc = Wa;
    I.prototype.Ca = function() {
      this.clear();
      100 > Va.length && Va.push(this);
    };
    I.prototype.free = I.prototype.Ca;
    I.prototype.clone = function() {
      return Wa(this.b, this.h, this.c - this.h);
    };
    I.prototype.clone = I.prototype.clone;
    I.prototype.clear = function() {
      this.b = null;
      this.a = this.c = this.h = 0;
      this.v = false;
    };
    I.prototype.clear = I.prototype.clear;
    I.prototype.Y = function() {
      return this.b;
    };
    I.prototype.getBuffer = I.prototype.Y;
    I.prototype.H = function(a, b2, c) {
      this.b = Ua(a);
      this.h = void 0 !== b2 ? b2 : 0;
      this.c = void 0 !== c ? this.h + c : this.b.length;
      this.a = this.h;
    };
    I.prototype.setBlock = I.prototype.H;
    I.prototype.Db = function() {
      return this.c;
    };
    I.prototype.getEnd = I.prototype.Db;
    I.prototype.setEnd = function(a) {
      this.c = a;
    };
    I.prototype.setEnd = I.prototype.setEnd;
    I.prototype.reset = function() {
      this.a = this.h;
    };
    I.prototype.reset = I.prototype.reset;
    I.prototype.B = function() {
      return this.a;
    };
    I.prototype.getCursor = I.prototype.B;
    I.prototype.Ma = function(a) {
      this.a = a;
    };
    I.prototype.setCursor = I.prototype.Ma;
    I.prototype.advance = function(a) {
      this.a += a;
      n2(this.a <= this.c);
    };
    I.prototype.advance = I.prototype.advance;
    I.prototype.ya = function() {
      return this.a == this.c;
    };
    I.prototype.atEnd = I.prototype.ya;
    I.prototype.Qb = function() {
      return this.a > this.c;
    };
    I.prototype.pastEnd = I.prototype.Qb;
    I.prototype.getError = function() {
      return this.v || 0 > this.a || this.a > this.c;
    };
    I.prototype.getError = I.prototype.getError;
    I.prototype.w = function(a) {
      for (var b2 = 128, c = 0, d = 0, f2 = 0; 4 > f2 && 128 <= b2; f2++) b2 = this.b[this.a++], c |= (b2 & 127) << 7 * f2;
      128 <= b2 && (b2 = this.b[this.a++], c |= (b2 & 127) << 28, d |= (b2 & 127) >> 4);
      if (128 <= b2) for (f2 = 0; 5 > f2 && 128 <= b2; f2++) b2 = this.b[this.a++], d |= (b2 & 127) << 7 * f2 + 3;
      if (128 > b2) return a(c >>> 0, d >>> 0);
      p("Failed to read varint, encoding is invalid.");
      this.v = true;
    };
    I.prototype.readSplitVarint64 = I.prototype.w;
    I.prototype.ea = function(a) {
      return this.w(function(b2, c) {
        return Ma(b2, c, a);
      });
    };
    I.prototype.readSplitZigzagVarint64 = I.prototype.ea;
    I.prototype.ta = function(a) {
      var b2 = this.b, c = this.a;
      this.a += 8;
      for (var d = 0, f2 = 0, h = c + 7; h >= c; h--) d = d << 8 | b2[h], f2 = f2 << 8 | b2[h + 4];
      return a(d, f2);
    };
    I.prototype.readSplitFixed64 = I.prototype.ta;
    I.prototype.kb = function() {
      for (; this.b[this.a] & 128; ) this.a++;
      this.a++;
    };
    I.prototype.skipVarint = I.prototype.kb;
    I.prototype.mb = function(a) {
      for (; 128 < a; ) this.a--, a >>>= 7;
      this.a--;
    };
    I.prototype.unskipVarint = I.prototype.mb;
    I.prototype.o = function() {
      var a = this.b;
      var b2 = a[this.a];
      var c = b2 & 127;
      if (128 > b2) return this.a += 1, n2(this.a <= this.c), c;
      b2 = a[this.a + 1];
      c |= (b2 & 127) << 7;
      if (128 > b2) return this.a += 2, n2(this.a <= this.c), c;
      b2 = a[this.a + 2];
      c |= (b2 & 127) << 14;
      if (128 > b2) return this.a += 3, n2(this.a <= this.c), c;
      b2 = a[this.a + 3];
      c |= (b2 & 127) << 21;
      if (128 > b2) return this.a += 4, n2(this.a <= this.c), c;
      b2 = a[this.a + 4];
      c |= (b2 & 15) << 28;
      if (128 > b2) return this.a += 5, n2(this.a <= this.c), c >>> 0;
      this.a += 5;
      128 <= a[this.a++] && 128 <= a[this.a++] && 128 <= a[this.a++] && 128 <= a[this.a++] && 128 <= a[this.a++] && n2(false);
      n2(this.a <= this.c);
      return c;
    };
    I.prototype.readUnsignedVarint32 = I.prototype.o;
    I.prototype.da = function() {
      return ~~this.o();
    };
    I.prototype.readSignedVarint32 = I.prototype.da;
    I.prototype.O = function() {
      return this.o().toString();
    };
    I.prototype.Ea = function() {
      return this.da().toString();
    };
    I.prototype.readSignedVarint32String = I.prototype.Ea;
    I.prototype.Ia = function() {
      var a = this.o();
      return a >>> 1 ^ -(a & 1);
    };
    I.prototype.readZigzagVarint32 = I.prototype.Ia;
    I.prototype.Ga = function() {
      return this.w(D);
    };
    I.prototype.readUnsignedVarint64 = I.prototype.Ga;
    I.prototype.Ha = function() {
      return this.w(F);
    };
    I.prototype.readUnsignedVarint64String = I.prototype.Ha;
    I.prototype.sa = function() {
      return this.w(E);
    };
    I.prototype.readSignedVarint64 = I.prototype.sa;
    I.prototype.Fa = function() {
      return this.w(G);
    };
    I.prototype.readSignedVarint64String = I.prototype.Fa;
    I.prototype.Ja = function() {
      return this.w(Ka);
    };
    I.prototype.readZigzagVarint64 = I.prototype.Ja;
    I.prototype.fb = function() {
      return this.ea(Pa);
    };
    I.prototype.readZigzagVarintHash64 = I.prototype.fb;
    I.prototype.Ka = function() {
      return this.ea(G);
    };
    I.prototype.readZigzagVarint64String = I.prototype.Ka;
    I.prototype.Gc = function() {
      var a = this.b[this.a];
      this.a += 1;
      n2(this.a <= this.c);
      return a;
    };
    I.prototype.readUint8 = I.prototype.Gc;
    I.prototype.Ec = function() {
      var a = this.b[this.a], b2 = this.b[this.a + 1];
      this.a += 2;
      n2(this.a <= this.c);
      return a << 0 | b2 << 8;
    };
    I.prototype.readUint16 = I.prototype.Ec;
    I.prototype.m = function() {
      var a = this.b[this.a], b2 = this.b[this.a + 1], c = this.b[this.a + 2], d = this.b[this.a + 3];
      this.a += 4;
      n2(this.a <= this.c);
      return (a << 0 | b2 << 8 | c << 16 | d << 24) >>> 0;
    };
    I.prototype.readUint32 = I.prototype.m;
    I.prototype.ga = function() {
      var a = this.m(), b2 = this.m();
      return D(a, b2);
    };
    I.prototype.readUint64 = I.prototype.ga;
    I.prototype.ha = function() {
      var a = this.m(), b2 = this.m();
      return F(a, b2);
    };
    I.prototype.readUint64String = I.prototype.ha;
    I.prototype.Xb = function() {
      var a = this.b[this.a];
      this.a += 1;
      n2(this.a <= this.c);
      return a << 24 >> 24;
    };
    I.prototype.readInt8 = I.prototype.Xb;
    I.prototype.Vb = function() {
      var a = this.b[this.a], b2 = this.b[this.a + 1];
      this.a += 2;
      n2(this.a <= this.c);
      return (a << 0 | b2 << 8) << 16 >> 16;
    };
    I.prototype.readInt16 = I.prototype.Vb;
    I.prototype.P = function() {
      var a = this.b[this.a], b2 = this.b[this.a + 1], c = this.b[this.a + 2], d = this.b[this.a + 3];
      this.a += 4;
      n2(this.a <= this.c);
      return a << 0 | b2 << 8 | c << 16 | d << 24;
    };
    I.prototype.readInt32 = I.prototype.P;
    I.prototype.ba = function() {
      var a = this.m(), b2 = this.m();
      return E(a, b2);
    };
    I.prototype.readInt64 = I.prototype.ba;
    I.prototype.ca = function() {
      var a = this.m(), b2 = this.m();
      return G(a, b2);
    };
    I.prototype.readInt64String = I.prototype.ca;
    I.prototype.aa = function() {
      var a = this.m();
      return Na(a, 0);
    };
    I.prototype.readFloat = I.prototype.aa;
    I.prototype.Z = function() {
      var a = this.m(), b2 = this.m();
      return Oa(a, b2);
    };
    I.prototype.readDouble = I.prototype.Z;
    I.prototype.pa = function() {
      return !!this.b[this.a++];
    };
    I.prototype.readBool = I.prototype.pa;
    I.prototype.ra = function() {
      return this.da();
    };
    I.prototype.readEnum = I.prototype.ra;
    I.prototype.fa = function(a) {
      var b2 = this.b, c = this.a;
      a = c + a;
      for (var d = [], f2 = ""; c < a; ) {
        var h = b2[c++];
        if (128 > h) d.push(h);
        else if (192 > h) continue;
        else if (224 > h) {
          var m = b2[c++];
          d.push((h & 31) << 6 | m & 63);
        } else if (240 > h) {
          m = b2[c++];
          var t = b2[c++];
          d.push((h & 15) << 12 | (m & 63) << 6 | t & 63);
        } else if (248 > h) {
          m = b2[c++];
          t = b2[c++];
          var B = b2[c++];
          h = (h & 7) << 18 | (m & 63) << 12 | (t & 63) << 6 | B & 63;
          h -= 65536;
          d.push((h >> 10 & 1023) + 55296, (h & 1023) + 56320);
        }
        8192 <= d.length && (f2 += String.fromCharCode.apply(null, d), d.length = 0);
      }
      f2 += xa(d);
      this.a = c;
      return f2;
    };
    I.prototype.readString = I.prototype.fa;
    I.prototype.Dc = function() {
      var a = this.o();
      return this.fa(a);
    };
    I.prototype.readStringWithLength = I.prototype.Dc;
    I.prototype.qa = function(a) {
      if (0 > a || this.a + a > this.b.length) return this.v = true, p("Invalid byte length!"), new Uint8Array(0);
      var b2 = this.b.subarray(this.a, this.a + a);
      this.a += a;
      n2(this.a <= this.c);
      return b2;
    };
    I.prototype.readBytes = I.prototype.qa;
    I.prototype.ia = function() {
      return this.w(Pa);
    };
    I.prototype.readVarintHash64 = I.prototype.ia;
    I.prototype.$ = function() {
      var a = this.b, b2 = this.a, c = a[b2], d = a[b2 + 1], f2 = a[b2 + 2], h = a[b2 + 3], m = a[b2 + 4], t = a[b2 + 5], B = a[b2 + 6];
      a = a[b2 + 7];
      this.a += 8;
      return String.fromCharCode(c, d, f2, h, m, t, B, a);
    };
    I.prototype.readFixedHash64 = I.prototype.$;
    function J(a, b2, c) {
      this.a = Wa(a, b2, c);
      this.O = this.a.B();
      this.b = this.c = -1;
      this.h = false;
      this.v = null;
    }
    g("jspb.BinaryReader", J, void 0);
    var K = [];
    J.clearInstanceCache = function() {
      K = [];
    };
    J.getInstanceCacheLength = function() {
      return K.length;
    };
    function Xa(a, b2, c) {
      if (K.length) {
        var d = K.pop();
        a && d.a.H(a, b2, c);
        return d;
      }
      return new J(a, b2, c);
    }
    J.alloc = Xa;
    J.prototype.zb = Xa;
    J.prototype.alloc = J.prototype.zb;
    J.prototype.Ca = function() {
      this.a.clear();
      this.b = this.c = -1;
      this.h = false;
      this.v = null;
      100 > K.length && K.push(this);
    };
    J.prototype.free = J.prototype.Ca;
    J.prototype.Fb = function() {
      return this.O;
    };
    J.prototype.getFieldCursor = J.prototype.Fb;
    J.prototype.B = function() {
      return this.a.B();
    };
    J.prototype.getCursor = J.prototype.B;
    J.prototype.Y = function() {
      return this.a.Y();
    };
    J.prototype.getBuffer = J.prototype.Y;
    J.prototype.Hb = function() {
      return this.c;
    };
    J.prototype.getFieldNumber = J.prototype.Hb;
    J.prototype.Lb = function() {
      return this.b;
    };
    J.prototype.getWireType = J.prototype.Lb;
    J.prototype.Mb = function() {
      return 2 == this.b;
    };
    J.prototype.isDelimited = J.prototype.Mb;
    J.prototype.bb = function() {
      return 4 == this.b;
    };
    J.prototype.isEndGroup = J.prototype.bb;
    J.prototype.getError = function() {
      return this.h || this.a.getError();
    };
    J.prototype.getError = J.prototype.getError;
    J.prototype.H = function(a, b2, c) {
      this.a.H(a, b2, c);
      this.b = this.c = -1;
    };
    J.prototype.setBlock = J.prototype.H;
    J.prototype.reset = function() {
      this.a.reset();
      this.b = this.c = -1;
    };
    J.prototype.reset = J.prototype.reset;
    J.prototype.advance = function(a) {
      this.a.advance(a);
    };
    J.prototype.advance = J.prototype.advance;
    J.prototype.oa = function() {
      if (this.a.ya()) return false;
      if (this.getError()) return p("Decoder hit an error"), false;
      this.O = this.a.B();
      var a = this.a.o(), b2 = a >>> 3;
      a &= 7;
      if (0 != a && 5 != a && 1 != a && 2 != a && 3 != a && 4 != a) return p("Invalid wire type: %s (at position %s)", a, this.O), this.h = true, false;
      this.c = b2;
      this.b = a;
      return true;
    };
    J.prototype.nextField = J.prototype.oa;
    J.prototype.Oa = function() {
      this.a.mb(this.c << 3 | this.b);
    };
    J.prototype.unskipHeader = J.prototype.Oa;
    J.prototype.Lc = function() {
      var a = this.c;
      for (this.Oa(); this.oa() && this.c == a; ) this.C();
      this.a.ya() || this.Oa();
    };
    J.prototype.skipMatchingFields = J.prototype.Lc;
    J.prototype.lb = function() {
      0 != this.b ? (p("Invalid wire type for skipVarintField"), this.C()) : this.a.kb();
    };
    J.prototype.skipVarintField = J.prototype.lb;
    J.prototype.gb = function() {
      if (2 != this.b) p("Invalid wire type for skipDelimitedField"), this.C();
      else {
        var a = this.a.o();
        this.a.advance(a);
      }
    };
    J.prototype.skipDelimitedField = J.prototype.gb;
    J.prototype.hb = function() {
      5 != this.b ? (p("Invalid wire type for skipFixed32Field"), this.C()) : this.a.advance(4);
    };
    J.prototype.skipFixed32Field = J.prototype.hb;
    J.prototype.ib = function() {
      1 != this.b ? (p("Invalid wire type for skipFixed64Field"), this.C()) : this.a.advance(8);
    };
    J.prototype.skipFixed64Field = J.prototype.ib;
    J.prototype.jb = function() {
      var a = this.c;
      do {
        if (!this.oa()) {
          p("Unmatched start-group tag: stream EOF");
          this.h = true;
          break;
        }
        if (4 == this.b) {
          this.c != a && (p("Unmatched end-group tag"), this.h = true);
          break;
        }
        this.C();
      } while (1);
    };
    J.prototype.skipGroup = J.prototype.jb;
    J.prototype.C = function() {
      switch (this.b) {
        case 0:
          this.lb();
          break;
        case 1:
          this.ib();
          break;
        case 2:
          this.gb();
          break;
        case 5:
          this.hb();
          break;
        case 3:
          this.jb();
          break;
        default:
          p("Invalid wire encoding for field.");
      }
    };
    J.prototype.skipField = J.prototype.C;
    J.prototype.Hc = function(a, b2) {
      null === this.v && (this.v = {});
      n2(!this.v[a]);
      this.v[a] = b2;
    };
    J.prototype.registerReadCallback = J.prototype.Hc;
    J.prototype.Ic = function(a) {
      n2(null !== this.v);
      a = this.v[a];
      n2(a);
      return a(this);
    };
    J.prototype.runReadCallback = J.prototype.Ic;
    J.prototype.Yb = function(a, b2) {
      n2(2 == this.b);
      var c = this.a.c, d = this.a.o();
      d = this.a.B() + d;
      this.a.setEnd(d);
      b2(a, this);
      this.a.Ma(d);
      this.a.setEnd(c);
    };
    J.prototype.readMessage = J.prototype.Yb;
    J.prototype.Ub = function(a, b2, c) {
      n2(3 == this.b);
      n2(this.c == a);
      c(b2, this);
      this.h || 4 == this.b || (p("Group submessage did not end with an END_GROUP tag"), this.h = true);
    };
    J.prototype.readGroup = J.prototype.Ub;
    J.prototype.Gb = function() {
      n2(2 == this.b);
      var a = this.a.o(), b2 = this.a.B(), c = b2 + a;
      a = Wa(this.a.Y(), b2, a);
      this.a.Ma(c);
      return a;
    };
    J.prototype.getFieldDecoder = J.prototype.Gb;
    J.prototype.P = function() {
      n2(0 == this.b);
      return this.a.da();
    };
    J.prototype.readInt32 = J.prototype.P;
    J.prototype.Wb = function() {
      n2(0 == this.b);
      return this.a.Ea();
    };
    J.prototype.readInt32String = J.prototype.Wb;
    J.prototype.ba = function() {
      n2(0 == this.b);
      return this.a.sa();
    };
    J.prototype.readInt64 = J.prototype.ba;
    J.prototype.ca = function() {
      n2(0 == this.b);
      return this.a.Fa();
    };
    J.prototype.readInt64String = J.prototype.ca;
    J.prototype.m = function() {
      n2(0 == this.b);
      return this.a.o();
    };
    J.prototype.readUint32 = J.prototype.m;
    J.prototype.Fc = function() {
      n2(0 == this.b);
      return this.a.O();
    };
    J.prototype.readUint32String = J.prototype.Fc;
    J.prototype.ga = function() {
      n2(0 == this.b);
      return this.a.Ga();
    };
    J.prototype.readUint64 = J.prototype.ga;
    J.prototype.ha = function() {
      n2(0 == this.b);
      return this.a.Ha();
    };
    J.prototype.readUint64String = J.prototype.ha;
    J.prototype.zc = function() {
      n2(0 == this.b);
      return this.a.Ia();
    };
    J.prototype.readSint32 = J.prototype.zc;
    J.prototype.Ac = function() {
      n2(0 == this.b);
      return this.a.Ja();
    };
    J.prototype.readSint64 = J.prototype.Ac;
    J.prototype.Bc = function() {
      n2(0 == this.b);
      return this.a.Ka();
    };
    J.prototype.readSint64String = J.prototype.Bc;
    J.prototype.Rb = function() {
      n2(5 == this.b);
      return this.a.m();
    };
    J.prototype.readFixed32 = J.prototype.Rb;
    J.prototype.Sb = function() {
      n2(1 == this.b);
      return this.a.ga();
    };
    J.prototype.readFixed64 = J.prototype.Sb;
    J.prototype.Tb = function() {
      n2(1 == this.b);
      return this.a.ha();
    };
    J.prototype.readFixed64String = J.prototype.Tb;
    J.prototype.vc = function() {
      n2(5 == this.b);
      return this.a.P();
    };
    J.prototype.readSfixed32 = J.prototype.vc;
    J.prototype.wc = function() {
      n2(5 == this.b);
      return this.a.P().toString();
    };
    J.prototype.readSfixed32String = J.prototype.wc;
    J.prototype.xc = function() {
      n2(1 == this.b);
      return this.a.ba();
    };
    J.prototype.readSfixed64 = J.prototype.xc;
    J.prototype.yc = function() {
      n2(1 == this.b);
      return this.a.ca();
    };
    J.prototype.readSfixed64String = J.prototype.yc;
    J.prototype.aa = function() {
      n2(5 == this.b);
      return this.a.aa();
    };
    J.prototype.readFloat = J.prototype.aa;
    J.prototype.Z = function() {
      n2(1 == this.b);
      return this.a.Z();
    };
    J.prototype.readDouble = J.prototype.Z;
    J.prototype.pa = function() {
      n2(0 == this.b);
      return !!this.a.o();
    };
    J.prototype.readBool = J.prototype.pa;
    J.prototype.ra = function() {
      n2(0 == this.b);
      return this.a.sa();
    };
    J.prototype.readEnum = J.prototype.ra;
    J.prototype.fa = function() {
      n2(2 == this.b);
      var a = this.a.o();
      return this.a.fa(a);
    };
    J.prototype.readString = J.prototype.fa;
    J.prototype.qa = function() {
      n2(2 == this.b);
      var a = this.a.o();
      return this.a.qa(a);
    };
    J.prototype.readBytes = J.prototype.qa;
    J.prototype.ia = function() {
      n2(0 == this.b);
      return this.a.ia();
    };
    J.prototype.readVarintHash64 = J.prototype.ia;
    J.prototype.Cc = function() {
      n2(0 == this.b);
      return this.a.fb();
    };
    J.prototype.readSintHash64 = J.prototype.Cc;
    J.prototype.w = function(a) {
      n2(0 == this.b);
      return this.a.w(a);
    };
    J.prototype.readSplitVarint64 = J.prototype.w;
    J.prototype.ea = function(a) {
      n2(0 == this.b);
      return this.a.w(function(b2, c) {
        return Ma(b2, c, a);
      });
    };
    J.prototype.readSplitZigzagVarint64 = J.prototype.ea;
    J.prototype.$ = function() {
      n2(1 == this.b);
      return this.a.$();
    };
    J.prototype.readFixedHash64 = J.prototype.$;
    J.prototype.ta = function(a) {
      n2(1 == this.b);
      return this.a.ta(a);
    };
    J.prototype.readSplitFixed64 = J.prototype.ta;
    function L(a, b2) {
      n2(2 == a.b);
      var c = a.a.o();
      c = a.a.B() + c;
      for (var d = []; a.a.B() < c; ) d.push(b2.call(a.a));
      return d;
    }
    J.prototype.gc = function() {
      return L(this, this.a.da);
    };
    J.prototype.readPackedInt32 = J.prototype.gc;
    J.prototype.hc = function() {
      return L(this, this.a.Ea);
    };
    J.prototype.readPackedInt32String = J.prototype.hc;
    J.prototype.ic = function() {
      return L(this, this.a.sa);
    };
    J.prototype.readPackedInt64 = J.prototype.ic;
    J.prototype.jc = function() {
      return L(this, this.a.Fa);
    };
    J.prototype.readPackedInt64String = J.prototype.jc;
    J.prototype.qc = function() {
      return L(this, this.a.o);
    };
    J.prototype.readPackedUint32 = J.prototype.qc;
    J.prototype.rc = function() {
      return L(this, this.a.O);
    };
    J.prototype.readPackedUint32String = J.prototype.rc;
    J.prototype.sc = function() {
      return L(this, this.a.Ga);
    };
    J.prototype.readPackedUint64 = J.prototype.sc;
    J.prototype.tc = function() {
      return L(this, this.a.Ha);
    };
    J.prototype.readPackedUint64String = J.prototype.tc;
    J.prototype.nc = function() {
      return L(this, this.a.Ia);
    };
    J.prototype.readPackedSint32 = J.prototype.nc;
    J.prototype.oc = function() {
      return L(this, this.a.Ja);
    };
    J.prototype.readPackedSint64 = J.prototype.oc;
    J.prototype.pc = function() {
      return L(this, this.a.Ka);
    };
    J.prototype.readPackedSint64String = J.prototype.pc;
    J.prototype.bc = function() {
      return L(this, this.a.m);
    };
    J.prototype.readPackedFixed32 = J.prototype.bc;
    J.prototype.cc = function() {
      return L(this, this.a.ga);
    };
    J.prototype.readPackedFixed64 = J.prototype.cc;
    J.prototype.dc = function() {
      return L(this, this.a.ha);
    };
    J.prototype.readPackedFixed64String = J.prototype.dc;
    J.prototype.kc = function() {
      return L(this, this.a.P);
    };
    J.prototype.readPackedSfixed32 = J.prototype.kc;
    J.prototype.lc = function() {
      return L(this, this.a.ba);
    };
    J.prototype.readPackedSfixed64 = J.prototype.lc;
    J.prototype.mc = function() {
      return L(this, this.a.ca);
    };
    J.prototype.readPackedSfixed64String = J.prototype.mc;
    J.prototype.fc = function() {
      return L(this, this.a.aa);
    };
    J.prototype.readPackedFloat = J.prototype.fc;
    J.prototype.$b = function() {
      return L(this, this.a.Z);
    };
    J.prototype.readPackedDouble = J.prototype.$b;
    J.prototype.Zb = function() {
      return L(this, this.a.pa);
    };
    J.prototype.readPackedBool = J.prototype.Zb;
    J.prototype.ac = function() {
      return L(this, this.a.ra);
    };
    J.prototype.readPackedEnum = J.prototype.ac;
    J.prototype.uc = function() {
      return L(this, this.a.ia);
    };
    J.prototype.readPackedVarintHash64 = J.prototype.uc;
    J.prototype.ec = function() {
      return L(this, this.a.$);
    };
    J.prototype.readPackedFixedHash64 = J.prototype.ec;
    function Ya(a, b2, c, d, f2) {
      this.ma = a;
      this.Ba = b2;
      this.la = c;
      this.Na = d;
      this.na = f2;
    }
    g("jspb.ExtensionFieldInfo", Ya, void 0);
    function Za(a, b2, c, d, f2, h) {
      this.Za = a;
      this.za = b2;
      this.Aa = c;
      this.Wa = d;
      this.Ab = f2;
      this.Nb = h;
    }
    g("jspb.ExtensionFieldBinaryInfo", Za, void 0);
    Ya.prototype.F = function() {
      return !!this.la;
    };
    Ya.prototype.isMessageType = Ya.prototype.F;
    function N3() {
    }
    g("jspb.Message", N3, void 0);
    N3.GENERATE_TO_OBJECT = true;
    N3.GENERATE_FROM_OBJECT = true;
    var $a = "function" == typeof Uint8Array;
    N3.prototype.Ib = function() {
      return this.b;
    };
    N3.prototype.getJsPbMessageId = N3.prototype.Ib;
    N3.initialize = function(a, b2, c, d, f2, h) {
      a.f = null;
      b2 || (b2 = c ? [c] : []);
      a.b = c ? String(c) : void 0;
      a.D = 0 === c ? -1 : 0;
      a.u = b2;
      a: {
        c = a.u.length;
        b2 = -1;
        if (c && (b2 = c - 1, c = a.u[b2], !(null === c || "object" != typeof c || Array.isArray(c) || $a && c instanceof Uint8Array))) {
          a.G = b2 - a.D;
          a.i = c;
          break a;
        }
        -1 < d ? (a.G = Math.max(d, b2 + 1 - a.D), a.i = null) : a.G = Number.MAX_VALUE;
      }
      a.a = {};
      if (f2) for (d = 0; d < f2.length; d++) b2 = f2[d], b2 < a.G ? (b2 += a.D, a.u[b2] = a.u[b2] || ab) : (bb(a), a.i[b2] = a.i[b2] || ab);
      if (h && h.length) for (d = 0; d < h.length; d++) cb(a, h[d]);
    };
    var ab = Object.freeze ? Object.freeze([]) : [];
    function bb(a) {
      var b2 = a.G + a.D;
      a.u[b2] || (a.i = a.u[b2] = {});
    }
    function db(a, b2, c) {
      for (var d = [], f2 = 0; f2 < a.length; f2++) d[f2] = b2.call(a[f2], c, a[f2]);
      return d;
    }
    N3.toObjectList = db;
    N3.toObjectExtension = function(a, b2, c, d, f2) {
      for (var h in c) {
        var m = c[h], t = d.call(a, m);
        if (null != t) {
          for (var B in m.Ba) if (m.Ba.hasOwnProperty(B)) break;
          b2[B] = m.Na ? m.na ? db(t, m.Na, f2) : m.Na(f2, t) : t;
        }
      }
    };
    N3.serializeBinaryExtensions = function(a, b2, c, d) {
      for (var f2 in c) {
        var h = c[f2], m = h.Za;
        if (!h.Aa) throw Error("Message extension present that was generated without binary serialization support");
        var t = d.call(a, m);
        if (null != t) if (m.F()) if (h.Wa) h.Aa.call(b2, m.ma, t, h.Wa);
        else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
        else h.Aa.call(b2, m.ma, t);
      }
    };
    N3.readBinaryExtension = function(a, b2, c, d, f2) {
      var h = c[b2.c];
      if (h) {
        c = h.Za;
        if (!h.za) throw Error("Deserializing extension whose generated code does not support binary format");
        if (c.F()) {
          var m = new c.la();
          h.za.call(b2, m, h.Ab);
        } else m = h.za.call(b2);
        c.na && !h.Nb ? (b2 = d.call(a, c)) ? b2.push(m) : f2.call(a, c, [m]) : f2.call(a, c, m);
      } else b2.C();
    };
    function O(a, b2) {
      if (b2 < a.G) {
        b2 += a.D;
        var c = a.u[b2];
        return c === ab ? a.u[b2] = [] : c;
      }
      if (a.i) return c = a.i[b2], c === ab ? a.i[b2] = [] : c;
    }
    N3.getField = O;
    N3.getRepeatedField = function(a, b2) {
      return O(a, b2);
    };
    function eb(a, b2) {
      a = O(a, b2);
      return null == a ? a : +a;
    }
    N3.getOptionalFloatingPointField = eb;
    function fb(a, b2) {
      a = O(a, b2);
      return null == a ? a : !!a;
    }
    N3.getBooleanField = fb;
    N3.getRepeatedFloatingPointField = function(a, b2) {
      var c = O(a, b2);
      a.a || (a.a = {});
      if (!a.a[b2]) {
        for (var d = 0; d < c.length; d++) c[d] = +c[d];
        a.a[b2] = true;
      }
      return c;
    };
    N3.getRepeatedBooleanField = function(a, b2) {
      var c = O(a, b2);
      a.a || (a.a = {});
      if (!a.a[b2]) {
        for (var d = 0; d < c.length; d++) c[d] = !!c[d];
        a.a[b2] = true;
      }
      return c;
    };
    function gb(a) {
      if (null == a || "string" === typeof a) return a;
      if ($a && a instanceof Uint8Array) return Ba(a);
      p("Cannot coerce to b64 string: " + k(a));
      return null;
    }
    N3.bytesAsB64 = gb;
    function hb(a) {
      if (null == a || a instanceof Uint8Array) return a;
      if ("string" === typeof a) return Da(a);
      p("Cannot coerce to Uint8Array: " + k(a));
      return null;
    }
    N3.bytesAsU8 = hb;
    N3.bytesListAsB64 = function(a) {
      ib(a);
      return a.length && "string" !== typeof a[0] ? l(a, gb) : a;
    };
    N3.bytesListAsU8 = function(a) {
      ib(a);
      return !a.length || a[0] instanceof Uint8Array ? a : l(a, hb);
    };
    function ib(a) {
      if (a && 1 < a.length) {
        var b2 = k(a[0]);
        qa(a, function(c) {
          k(c) != b2 && p("Inconsistent type in JSPB repeated field array. Got " + k(c) + " expected " + b2);
        });
      }
    }
    function jb(a, b2, c) {
      a = O(a, b2);
      return null == a ? c : a;
    }
    N3.getFieldWithDefault = jb;
    N3.getBooleanFieldWithDefault = function(a, b2, c) {
      a = fb(a, b2);
      return null == a ? c : a;
    };
    N3.getFloatingPointFieldWithDefault = function(a, b2, c) {
      a = eb(a, b2);
      return null == a ? c : a;
    };
    N3.getFieldProto3 = jb;
    N3.getMapField = function(a, b2, c, d) {
      a.f || (a.f = {});
      if (b2 in a.f) return a.f[b2];
      var f2 = O(a, b2);
      if (!f2) {
        if (c) return;
        f2 = [];
        P(a, b2, f2);
      }
      return a.f[b2] = new r(f2, d);
    };
    function P(a, b2, c) {
      q(a, N3);
      b2 < a.G ? a.u[b2 + a.D] = c : (bb(a), a.i[b2] = c);
      return a;
    }
    N3.setField = P;
    N3.setProto3IntField = function(a, b2, c) {
      return Q(a, b2, c, 0);
    };
    N3.setProto3FloatField = function(a, b2, c) {
      return Q(a, b2, c, 0);
    };
    N3.setProto3BooleanField = function(a, b2, c) {
      return Q(a, b2, c, false);
    };
    N3.setProto3StringField = function(a, b2, c) {
      return Q(a, b2, c, "");
    };
    N3.setProto3BytesField = function(a, b2, c) {
      return Q(a, b2, c, "");
    };
    N3.setProto3EnumField = function(a, b2, c) {
      return Q(a, b2, c, 0);
    };
    N3.setProto3StringIntField = function(a, b2, c) {
      return Q(a, b2, c, "0");
    };
    function Q(a, b2, c, d) {
      q(a, N3);
      c !== d ? P(a, b2, c) : b2 < a.G ? a.u[b2 + a.D] = null : (bb(a), delete a.i[b2]);
      return a;
    }
    N3.addToRepeatedField = function(a, b2, c, d) {
      q(a, N3);
      b2 = O(a, b2);
      void 0 != d ? b2.splice(d, 0, c) : b2.push(c);
      return a;
    };
    function kb(a, b2, c, d) {
      q(a, N3);
      (c = cb(a, c)) && c !== b2 && void 0 !== d && (a.f && c in a.f && (a.f[c] = void 0), P(a, c, void 0));
      return P(a, b2, d);
    }
    N3.setOneofField = kb;
    function cb(a, b2) {
      for (var c, d, f2 = 0; f2 < b2.length; f2++) {
        var h = b2[f2], m = O(a, h);
        null != m && (c = h, d = m, P(a, h, void 0));
      }
      return c ? (P(a, c, d), c) : 0;
    }
    N3.computeOneofCase = cb;
    N3.getWrapperField = function(a, b2, c, d) {
      a.f || (a.f = {});
      if (!a.f[c]) {
        var f2 = O(a, c);
        if (d || f2) a.f[c] = new b2(f2);
      }
      return a.f[c];
    };
    N3.getRepeatedWrapperField = function(a, b2, c) {
      lb(a, b2, c);
      b2 = a.f[c];
      b2 == ab && (b2 = a.f[c] = []);
      return b2;
    };
    function lb(a, b2, c) {
      a.f || (a.f = {});
      if (!a.f[c]) {
        for (var d = O(a, c), f2 = [], h = 0; h < d.length; h++) f2[h] = new b2(d[h]);
        a.f[c] = f2;
      }
    }
    N3.setWrapperField = function(a, b2, c) {
      q(a, N3);
      a.f || (a.f = {});
      var d = c ? c.g() : c;
      a.f[b2] = c;
      return P(a, b2, d);
    };
    N3.setOneofWrapperField = function(a, b2, c, d) {
      q(a, N3);
      a.f || (a.f = {});
      var f2 = d ? d.g() : d;
      a.f[b2] = d;
      return kb(a, b2, c, f2);
    };
    N3.setRepeatedWrapperField = function(a, b2, c) {
      q(a, N3);
      a.f || (a.f = {});
      c = c || [];
      for (var d = [], f2 = 0; f2 < c.length; f2++) d[f2] = c[f2].g();
      a.f[b2] = c;
      return P(a, b2, d);
    };
    N3.addToRepeatedWrapperField = function(a, b2, c, d, f2) {
      lb(a, d, b2);
      var h = a.f[b2];
      h || (h = a.f[b2] = []);
      c = c ? c : new d();
      a = O(a, b2);
      void 0 != f2 ? (h.splice(f2, 0, c), a.splice(f2, 0, c.g())) : (h.push(c), a.push(c.g()));
      return c;
    };
    N3.toMap = function(a, b2, c, d) {
      for (var f2 = {}, h = 0; h < a.length; h++) f2[b2.call(a[h])] = c ? c.call(a[h], d, a[h]) : a[h];
      return f2;
    };
    function mb(a) {
      if (a.f) for (var b2 in a.f) {
        var c = a.f[b2];
        if (Array.isArray(c)) for (var d = 0; d < c.length; d++) c[d] && c[d].g();
        else c && c.g();
      }
    }
    N3.prototype.g = function() {
      mb(this);
      return this.u;
    };
    N3.prototype.toArray = N3.prototype.g;
    N3.prototype.toString = function() {
      mb(this);
      return this.u.toString();
    };
    N3.prototype.getExtension = function(a) {
      if (this.i) {
        this.f || (this.f = {});
        var b2 = a.ma;
        if (a.na) {
          if (a.F()) return this.f[b2] || (this.f[b2] = l(this.i[b2] || [], function(c) {
            return new a.la(c);
          })), this.f[b2];
        } else if (a.F()) return !this.f[b2] && this.i[b2] && (this.f[b2] = new a.la(this.i[b2])), this.f[b2];
        return this.i[b2];
      }
    };
    N3.prototype.getExtension = N3.prototype.getExtension;
    N3.prototype.Kc = function(a, b2) {
      this.f || (this.f = {});
      bb(this);
      var c = a.ma;
      a.na ? (b2 = b2 || [], a.F() ? (this.f[c] = b2, this.i[c] = l(b2, function(d) {
        return d.g();
      })) : this.i[c] = b2) : a.F() ? (this.f[c] = b2, this.i[c] = b2 ? b2.g() : b2) : this.i[c] = b2;
      return this;
    };
    N3.prototype.setExtension = N3.prototype.Kc;
    N3.difference = function(a, b2) {
      if (!(a instanceof b2.constructor)) throw Error("Messages have different types.");
      var c = a.g();
      b2 = b2.g();
      var d = [], f2 = 0, h = c.length > b2.length ? c.length : b2.length;
      a.b && (d[0] = a.b, f2 = 1);
      for (; f2 < h; f2++) nb(c[f2], b2[f2]) || (d[f2] = b2[f2]);
      return new a.constructor(d);
    };
    N3.equals = function(a, b2) {
      return a == b2 || !(!a || !b2) && a instanceof b2.constructor && nb(a.g(), b2.g());
    };
    function ob(a, b2) {
      a = a || {};
      b2 = b2 || {};
      var c = {}, d;
      for (d in a) c[d] = 0;
      for (d in b2) c[d] = 0;
      for (d in c) if (!nb(a[d], b2[d])) return false;
      return true;
    }
    N3.compareExtensions = ob;
    function nb(a, b2) {
      if (a == b2) return true;
      if (!la(a) || !la(b2)) return "number" === typeof a && isNaN(a) || "number" === typeof b2 && isNaN(b2) ? String(a) == String(b2) : false;
      if (a.constructor != b2.constructor) return false;
      if ($a && a.constructor === Uint8Array) {
        if (a.length != b2.length) return false;
        for (var c = 0; c < a.length; c++) if (a[c] != b2[c]) return false;
        return true;
      }
      if (a.constructor === Array) {
        var d = void 0, f2 = void 0, h = Math.max(a.length, b2.length);
        for (c = 0; c < h; c++) {
          var m = a[c], t = b2[c];
          m && m.constructor == Object && (n2(void 0 === d), n2(c === a.length - 1), d = m, m = void 0);
          t && t.constructor == Object && (n2(void 0 === f2), n2(c === b2.length - 1), f2 = t, t = void 0);
          if (!nb(m, t)) return false;
        }
        return d || f2 ? (d = d || {}, f2 = f2 || {}, ob(d, f2)) : true;
      }
      if (a.constructor === Object) return ob(a, b2);
      throw Error("Invalid type in JSPB array");
    }
    N3.compareFields = nb;
    N3.prototype.Bb = function() {
      return pb(this);
    };
    N3.prototype.cloneMessage = N3.prototype.Bb;
    N3.prototype.clone = function() {
      return pb(this);
    };
    N3.prototype.clone = N3.prototype.clone;
    N3.clone = function(a) {
      return pb(a);
    };
    function pb(a) {
      return new a.constructor(qb(a.g()));
    }
    N3.copyInto = function(a, b2) {
      q(a, N3);
      q(b2, N3);
      n2(a.constructor == b2.constructor, "Copy source and target message should have the same type.");
      a = pb(a);
      for (var c = b2.g(), d = a.g(), f2 = c.length = 0; f2 < d.length; f2++) c[f2] = d[f2];
      b2.f = a.f;
      b2.i = a.i;
    };
    function qb(a) {
      if (Array.isArray(a)) {
        for (var b2 = Array(a.length), c = 0; c < a.length; c++) {
          var d = a[c];
          null != d && (b2[c] = "object" == typeof d ? qb(n2(d)) : d);
        }
        return b2;
      }
      if ($a && a instanceof Uint8Array) return new Uint8Array(a);
      b2 = {};
      for (c in a) d = a[c], null != d && (b2[c] = "object" == typeof d ? qb(n2(d)) : d);
      return b2;
    }
    N3.registerMessageType = function(a, b2) {
      b2.we = a;
    };
    var R = { dump: function(a) {
      q(a, N3, "jspb.Message instance expected");
      n2(a.getExtension, "Only unobfuscated and unoptimized compilation modes supported.");
      return R.X(a);
    } };
    g("jspb.debug.dump", R.dump, void 0);
    R.X = function(a) {
      var b2 = k(a);
      if ("number" == b2 || "string" == b2 || "boolean" == b2 || "null" == b2 || "undefined" == b2 || "undefined" !== typeof Uint8Array && a instanceof Uint8Array) return a;
      if ("array" == b2) return ua(a), l(a, R.X);
      if (a instanceof r) {
        var c = {};
        a = a.entries();
        for (var d = a.next(); !d.done; d = a.next()) c[d.value[0]] = R.X(d.value[1]);
        return c;
      }
      q(a, N3, "Only messages expected: " + a);
      b2 = a.constructor;
      var f2 = { $name: b2.name || b2.displayName };
      for (t in b2.prototype) {
        var h = /^get([A-Z]\w*)/.exec(t);
        if (h && "getExtension" != t && "getJsPbMessageId" != t) {
          var m = "has" + h[1];
          if (!a[m] || a[m]()) m = a[t](), f2[R.$a(h[1])] = R.X(m);
        }
      }
      if (a.extensionObject_) return f2.$extensions = "Recursive dumping of extensions not supported in compiled code. Switch to uncompiled or dump extension object directly", f2;
      for (d in b2.extensions) if (/^\d+$/.test(d)) {
        m = b2.extensions[d];
        var t = a.getExtension(m);
        h = void 0;
        m = m.Ba;
        var B = [], M = 0;
        for (h in m) B[M++] = h;
        h = B[0];
        null != t && (c || (c = f2.$extensions = {}), c[R.$a(h)] = R.X(t));
      }
      return f2;
    };
    R.$a = function(a) {
      return a.replace(/^[A-Z]/, function(b2) {
        return b2.toLowerCase();
      });
    };
    function S2() {
      this.a = [];
    }
    g("jspb.BinaryEncoder", S2, void 0);
    S2.prototype.length = function() {
      return this.a.length;
    };
    S2.prototype.length = S2.prototype.length;
    S2.prototype.end = function() {
      var a = this.a;
      this.a = [];
      return a;
    };
    S2.prototype.end = S2.prototype.end;
    S2.prototype.l = function(a, b2) {
      n2(a == Math.floor(a));
      n2(b2 == Math.floor(b2));
      n2(0 <= a && 4294967296 > a);
      for (n2(0 <= b2 && 4294967296 > b2); 0 < b2 || 127 < a; ) this.a.push(a & 127 | 128), a = (a >>> 7 | b2 << 25) >>> 0, b2 >>>= 7;
      this.a.push(a);
    };
    S2.prototype.writeSplitVarint64 = S2.prototype.l;
    S2.prototype.A = function(a, b2) {
      n2(a == Math.floor(a));
      n2(b2 == Math.floor(b2));
      n2(0 <= a && 4294967296 > a);
      n2(0 <= b2 && 4294967296 > b2);
      this.s(a);
      this.s(b2);
    };
    S2.prototype.writeSplitFixed64 = S2.prototype.A;
    S2.prototype.j = function(a) {
      n2(a == Math.floor(a));
      for (n2(0 <= a && 4294967296 > a); 127 < a; ) this.a.push(a & 127 | 128), a >>>= 7;
      this.a.push(a);
    };
    S2.prototype.writeUnsignedVarint32 = S2.prototype.j;
    S2.prototype.M = function(a) {
      n2(a == Math.floor(a));
      n2(-2147483648 <= a && 2147483648 > a);
      if (0 <= a) this.j(a);
      else {
        for (var b2 = 0; 9 > b2; b2++) this.a.push(a & 127 | 128), a >>= 7;
        this.a.push(1);
      }
    };
    S2.prototype.writeSignedVarint32 = S2.prototype.M;
    S2.prototype.va = function(a) {
      n2(a == Math.floor(a));
      n2(0 <= a && 18446744073709552e3 > a);
      A(a);
      this.l(y, z);
    };
    S2.prototype.writeUnsignedVarint64 = S2.prototype.va;
    S2.prototype.ua = function(a) {
      n2(a == Math.floor(a));
      n2(-9223372036854776e3 <= a && 9223372036854776e3 > a);
      A(a);
      this.l(y, z);
    };
    S2.prototype.writeSignedVarint64 = S2.prototype.ua;
    S2.prototype.wa = function(a) {
      n2(a == Math.floor(a));
      n2(-2147483648 <= a && 2147483648 > a);
      this.j((a << 1 ^ a >> 31) >>> 0);
    };
    S2.prototype.writeZigzagVarint32 = S2.prototype.wa;
    S2.prototype.xa = function(a) {
      n2(a == Math.floor(a));
      n2(-9223372036854776e3 <= a && 9223372036854776e3 > a);
      Ga(a);
      this.l(y, z);
    };
    S2.prototype.writeZigzagVarint64 = S2.prototype.xa;
    S2.prototype.Ta = function(a) {
      this.W(H(a));
    };
    S2.prototype.writeZigzagVarint64String = S2.prototype.Ta;
    S2.prototype.W = function(a) {
      var b2 = this;
      C(a);
      Ja(y, z, function(c, d) {
        b2.l(c >>> 0, d >>> 0);
      });
    };
    S2.prototype.writeZigzagVarintHash64 = S2.prototype.W;
    S2.prototype.be = function(a) {
      n2(a == Math.floor(a));
      n2(0 <= a && 256 > a);
      this.a.push(a >>> 0 & 255);
    };
    S2.prototype.writeUint8 = S2.prototype.be;
    S2.prototype.ae = function(a) {
      n2(a == Math.floor(a));
      n2(0 <= a && 65536 > a);
      this.a.push(a >>> 0 & 255);
      this.a.push(a >>> 8 & 255);
    };
    S2.prototype.writeUint16 = S2.prototype.ae;
    S2.prototype.s = function(a) {
      n2(a == Math.floor(a));
      n2(0 <= a && 4294967296 > a);
      this.a.push(a >>> 0 & 255);
      this.a.push(a >>> 8 & 255);
      this.a.push(a >>> 16 & 255);
      this.a.push(a >>> 24 & 255);
    };
    S2.prototype.writeUint32 = S2.prototype.s;
    S2.prototype.V = function(a) {
      n2(a == Math.floor(a));
      n2(0 <= a && 18446744073709552e3 > a);
      Fa(a);
      this.s(y);
      this.s(z);
    };
    S2.prototype.writeUint64 = S2.prototype.V;
    S2.prototype.Qc = function(a) {
      n2(a == Math.floor(a));
      n2(-128 <= a && 128 > a);
      this.a.push(a >>> 0 & 255);
    };
    S2.prototype.writeInt8 = S2.prototype.Qc;
    S2.prototype.Pc = function(a) {
      n2(a == Math.floor(a));
      n2(-32768 <= a && 32768 > a);
      this.a.push(a >>> 0 & 255);
      this.a.push(a >>> 8 & 255);
    };
    S2.prototype.writeInt16 = S2.prototype.Pc;
    S2.prototype.S = function(a) {
      n2(a == Math.floor(a));
      n2(-2147483648 <= a && 2147483648 > a);
      this.a.push(a >>> 0 & 255);
      this.a.push(a >>> 8 & 255);
      this.a.push(a >>> 16 & 255);
      this.a.push(a >>> 24 & 255);
    };
    S2.prototype.writeInt32 = S2.prototype.S;
    S2.prototype.T = function(a) {
      n2(a == Math.floor(a));
      n2(-9223372036854776e3 <= a && 9223372036854776e3 > a);
      A(a);
      this.A(y, z);
    };
    S2.prototype.writeInt64 = S2.prototype.T;
    S2.prototype.ka = function(a) {
      n2(a == Math.floor(a));
      n2(-9223372036854776e3 <= +a && 9223372036854776e3 > +a);
      C(H(a));
      this.A(y, z);
    };
    S2.prototype.writeInt64String = S2.prototype.ka;
    S2.prototype.L = function(a) {
      n2(Infinity === a || -Infinity === a || isNaN(a) || -34028234663852886e22 <= a && 34028234663852886e22 >= a);
      Ha(a);
      this.s(y);
    };
    S2.prototype.writeFloat = S2.prototype.L;
    S2.prototype.J = function(a) {
      n2(Infinity === a || -Infinity === a || isNaN(a) || -17976931348623157e292 <= a && 17976931348623157e292 >= a);
      Ia(a);
      this.s(y);
      this.s(z);
    };
    S2.prototype.writeDouble = S2.prototype.J;
    S2.prototype.I = function(a) {
      n2("boolean" === typeof a || "number" === typeof a);
      this.a.push(a ? 1 : 0);
    };
    S2.prototype.writeBool = S2.prototype.I;
    S2.prototype.R = function(a) {
      n2(a == Math.floor(a));
      n2(-2147483648 <= a && 2147483648 > a);
      this.M(a);
    };
    S2.prototype.writeEnum = S2.prototype.R;
    S2.prototype.ja = function(a) {
      this.a.push.apply(this.a, a);
    };
    S2.prototype.writeBytes = S2.prototype.ja;
    S2.prototype.N = function(a) {
      C(a);
      this.l(y, z);
    };
    S2.prototype.writeVarintHash64 = S2.prototype.N;
    S2.prototype.K = function(a) {
      C(a);
      this.s(y);
      this.s(z);
    };
    S2.prototype.writeFixedHash64 = S2.prototype.K;
    S2.prototype.U = function(a) {
      var b2 = this.a.length;
      ta(a);
      for (var c = 0; c < a.length; c++) {
        var d = a.charCodeAt(c);
        if (128 > d) this.a.push(d);
        else if (2048 > d) this.a.push(d >> 6 | 192), this.a.push(d & 63 | 128);
        else if (65536 > d) if (55296 <= d && 56319 >= d && c + 1 < a.length) {
          var f2 = a.charCodeAt(c + 1);
          56320 <= f2 && 57343 >= f2 && (d = 1024 * (d - 55296) + f2 - 56320 + 65536, this.a.push(d >> 18 | 240), this.a.push(d >> 12 & 63 | 128), this.a.push(d >> 6 & 63 | 128), this.a.push(d & 63 | 128), c++);
        } else this.a.push(d >> 12 | 224), this.a.push(d >> 6 & 63 | 128), this.a.push(d & 63 | 128);
      }
      return this.a.length - b2;
    };
    S2.prototype.writeString = S2.prototype.U;
    function T(a, b2) {
      this.lo = a;
      this.hi = b2;
    }
    g("jspb.arith.UInt64", T, void 0);
    T.prototype.cmp = function(a) {
      return this.hi < a.hi || this.hi == a.hi && this.lo < a.lo ? -1 : this.hi == a.hi && this.lo == a.lo ? 0 : 1;
    };
    T.prototype.cmp = T.prototype.cmp;
    T.prototype.La = function() {
      return new T((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0, this.hi >>> 1 >>> 0);
    };
    T.prototype.rightShift = T.prototype.La;
    T.prototype.Da = function() {
      return new T(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
    };
    T.prototype.leftShift = T.prototype.Da;
    T.prototype.cb = function() {
      return !!(this.hi & 2147483648);
    };
    T.prototype.msb = T.prototype.cb;
    T.prototype.Ob = function() {
      return !!(this.lo & 1);
    };
    T.prototype.lsb = T.prototype.Ob;
    T.prototype.Ua = function() {
      return 0 == this.lo && 0 == this.hi;
    };
    T.prototype.zero = T.prototype.Ua;
    T.prototype.add = function(a) {
      return new T((this.lo + a.lo & 4294967295) >>> 0 >>> 0, ((this.hi + a.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + a.lo ? 1 : 0) >>> 0);
    };
    T.prototype.add = T.prototype.add;
    T.prototype.sub = function(a) {
      return new T((this.lo - a.lo & 4294967295) >>> 0 >>> 0, ((this.hi - a.hi & 4294967295) >>> 0) - (0 > this.lo - a.lo ? 1 : 0) >>> 0);
    };
    T.prototype.sub = T.prototype.sub;
    function rb(a, b2) {
      var c = a & 65535;
      a >>>= 16;
      var d = b2 & 65535, f2 = b2 >>> 16;
      b2 = c * d + 65536 * (c * f2 & 65535) + 65536 * (a * d & 65535);
      for (c = a * f2 + (c * f2 >>> 16) + (a * d >>> 16); 4294967296 <= b2; ) b2 -= 4294967296, c += 1;
      return new T(b2 >>> 0, c >>> 0);
    }
    T.mul32x32 = rb;
    T.prototype.eb = function(a) {
      var b2 = rb(this.lo, a);
      a = rb(this.hi, a);
      a.hi = a.lo;
      a.lo = 0;
      return b2.add(a);
    };
    T.prototype.mul = T.prototype.eb;
    T.prototype.Xa = function(a) {
      if (0 == a) return [];
      var b2 = new T(0, 0), c = new T(this.lo, this.hi);
      a = new T(a, 0);
      for (var d = new T(1, 0); !a.cb(); ) a = a.Da(), d = d.Da();
      for (; !d.Ua(); ) 0 >= a.cmp(c) && (b2 = b2.add(d), c = c.sub(a)), a = a.La(), d = d.La();
      return [b2, c];
    };
    T.prototype.div = T.prototype.Xa;
    T.prototype.toString = function() {
      for (var a = "", b2 = this; !b2.Ua(); ) {
        b2 = b2.Xa(10);
        var c = b2[0];
        a = b2[1].lo + a;
        b2 = c;
      }
      "" == a && (a = "0");
      return a;
    };
    T.prototype.toString = T.prototype.toString;
    function U(a) {
      for (var b2 = new T(0, 0), c = new T(0, 0), d = 0; d < a.length; d++) {
        if ("0" > a[d] || "9" < a[d]) return null;
        c.lo = parseInt(a[d], 10);
        b2 = b2.eb(10).add(c);
      }
      return b2;
    }
    T.fromString = U;
    T.prototype.clone = function() {
      return new T(this.lo, this.hi);
    };
    T.prototype.clone = T.prototype.clone;
    function V(a, b2) {
      this.lo = a;
      this.hi = b2;
    }
    g("jspb.arith.Int64", V, void 0);
    V.prototype.add = function(a) {
      return new V((this.lo + a.lo & 4294967295) >>> 0 >>> 0, ((this.hi + a.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + a.lo ? 1 : 0) >>> 0);
    };
    V.prototype.add = V.prototype.add;
    V.prototype.sub = function(a) {
      return new V((this.lo - a.lo & 4294967295) >>> 0 >>> 0, ((this.hi - a.hi & 4294967295) >>> 0) - (0 > this.lo - a.lo ? 1 : 0) >>> 0);
    };
    V.prototype.sub = V.prototype.sub;
    V.prototype.clone = function() {
      return new V(this.lo, this.hi);
    };
    V.prototype.clone = V.prototype.clone;
    V.prototype.toString = function() {
      var a = 0 != (this.hi & 2147483648), b2 = new T(this.lo, this.hi);
      a && (b2 = new T(0, 0).sub(b2));
      return (a ? "-" : "") + b2.toString();
    };
    V.prototype.toString = V.prototype.toString;
    function sb(a) {
      var b2 = 0 < a.length && "-" == a[0];
      b2 && (a = a.substring(1));
      a = U(a);
      if (null === a) return null;
      b2 && (a = new T(0, 0).sub(a));
      return new V(a.lo, a.hi);
    }
    V.fromString = sb;
    function W() {
      this.c = [];
      this.b = 0;
      this.a = new S2();
      this.h = [];
    }
    g("jspb.BinaryWriter", W, void 0);
    function tb(a, b2) {
      var c = a.a.end();
      a.c.push(c);
      a.c.push(b2);
      a.b += c.length + b2.length;
    }
    function X(a, b2) {
      Y(a, b2, 2);
      b2 = a.a.end();
      a.c.push(b2);
      a.b += b2.length;
      b2.push(a.b);
      return b2;
    }
    function Z(a, b2) {
      var c = b2.pop();
      c = a.b + a.a.length() - c;
      for (n2(0 <= c); 127 < c; ) b2.push(c & 127 | 128), c >>>= 7, a.b++;
      b2.push(c);
      a.b++;
    }
    W.prototype.pb = function(a, b2, c) {
      tb(this, a.subarray(b2, c));
    };
    W.prototype.writeSerializedMessage = W.prototype.pb;
    W.prototype.Pb = function(a, b2, c) {
      null != a && null != b2 && null != c && this.pb(a, b2, c);
    };
    W.prototype.maybeWriteSerializedMessage = W.prototype.Pb;
    W.prototype.reset = function() {
      this.c = [];
      this.a.end();
      this.b = 0;
      this.h = [];
    };
    W.prototype.reset = W.prototype.reset;
    W.prototype.ab = function() {
      n2(0 == this.h.length);
      for (var a = new Uint8Array(this.b + this.a.length()), b2 = this.c, c = b2.length, d = 0, f2 = 0; f2 < c; f2++) {
        var h = b2[f2];
        a.set(h, d);
        d += h.length;
      }
      b2 = this.a.end();
      a.set(b2, d);
      d += b2.length;
      n2(d == a.length);
      this.c = [a];
      return a;
    };
    W.prototype.getResultBuffer = W.prototype.ab;
    W.prototype.Kb = function(a) {
      return Ba(this.ab(), a);
    };
    W.prototype.getResultBase64String = W.prototype.Kb;
    W.prototype.Va = function(a) {
      this.h.push(X(this, a));
    };
    W.prototype.beginSubMessage = W.prototype.Va;
    W.prototype.Ya = function() {
      n2(0 <= this.h.length);
      Z(this, this.h.pop());
    };
    W.prototype.endSubMessage = W.prototype.Ya;
    function Y(a, b2, c) {
      n2(1 <= b2 && b2 == Math.floor(b2));
      a.a.j(8 * b2 + c);
    }
    W.prototype.Nc = function(a, b2, c) {
      switch (a) {
        case 1:
          this.J(b2, c);
          break;
        case 2:
          this.L(b2, c);
          break;
        case 3:
          this.T(b2, c);
          break;
        case 4:
          this.V(b2, c);
          break;
        case 5:
          this.S(b2, c);
          break;
        case 6:
          this.Qa(b2, c);
          break;
        case 7:
          this.Pa(b2, c);
          break;
        case 8:
          this.I(b2, c);
          break;
        case 9:
          this.U(b2, c);
          break;
        case 10:
          p("Group field type not supported in writeAny()");
          break;
        case 11:
          p("Message field type not supported in writeAny()");
          break;
        case 12:
          this.ja(b2, c);
          break;
        case 13:
          this.s(b2, c);
          break;
        case 14:
          this.R(b2, c);
          break;
        case 15:
          this.Ra(b2, c);
          break;
        case 16:
          this.Sa(b2, c);
          break;
        case 17:
          this.rb(b2, c);
          break;
        case 18:
          this.sb(b2, c);
          break;
        case 30:
          this.K(b2, c);
          break;
        case 31:
          this.N(b2, c);
          break;
        default:
          p("Invalid field type in writeAny()");
      }
    };
    W.prototype.writeAny = W.prototype.Nc;
    function ub(a, b2, c) {
      null != c && (Y(a, b2, 0), a.a.j(c));
    }
    function vb(a, b2, c) {
      null != c && (Y(a, b2, 0), a.a.M(c));
    }
    W.prototype.S = function(a, b2) {
      null != b2 && (n2(-2147483648 <= b2 && 2147483648 > b2), vb(this, a, b2));
    };
    W.prototype.writeInt32 = W.prototype.S;
    W.prototype.ob = function(a, b2) {
      null != b2 && (b2 = parseInt(b2, 10), n2(-2147483648 <= b2 && 2147483648 > b2), vb(this, a, b2));
    };
    W.prototype.writeInt32String = W.prototype.ob;
    W.prototype.T = function(a, b2) {
      null != b2 && (n2(-9223372036854776e3 <= b2 && 9223372036854776e3 > b2), null != b2 && (Y(this, a, 0), this.a.ua(b2)));
    };
    W.prototype.writeInt64 = W.prototype.T;
    W.prototype.ka = function(a, b2) {
      null != b2 && (b2 = sb(b2), Y(this, a, 0), this.a.l(b2.lo, b2.hi));
    };
    W.prototype.writeInt64String = W.prototype.ka;
    W.prototype.s = function(a, b2) {
      null != b2 && (n2(0 <= b2 && 4294967296 > b2), ub(this, a, b2));
    };
    W.prototype.writeUint32 = W.prototype.s;
    W.prototype.ub = function(a, b2) {
      null != b2 && (b2 = parseInt(b2, 10), n2(0 <= b2 && 4294967296 > b2), ub(this, a, b2));
    };
    W.prototype.writeUint32String = W.prototype.ub;
    W.prototype.V = function(a, b2) {
      null != b2 && (n2(0 <= b2 && 18446744073709552e3 > b2), null != b2 && (Y(this, a, 0), this.a.va(b2)));
    };
    W.prototype.writeUint64 = W.prototype.V;
    W.prototype.vb = function(a, b2) {
      null != b2 && (b2 = U(b2), Y(this, a, 0), this.a.l(b2.lo, b2.hi));
    };
    W.prototype.writeUint64String = W.prototype.vb;
    W.prototype.rb = function(a, b2) {
      null != b2 && (n2(-2147483648 <= b2 && 2147483648 > b2), null != b2 && (Y(this, a, 0), this.a.wa(b2)));
    };
    W.prototype.writeSint32 = W.prototype.rb;
    W.prototype.sb = function(a, b2) {
      null != b2 && (n2(-9223372036854776e3 <= b2 && 9223372036854776e3 > b2), null != b2 && (Y(this, a, 0), this.a.xa(b2)));
    };
    W.prototype.writeSint64 = W.prototype.sb;
    W.prototype.$d = function(a, b2) {
      null != b2 && null != b2 && (Y(this, a, 0), this.a.W(b2));
    };
    W.prototype.writeSintHash64 = W.prototype.$d;
    W.prototype.Zd = function(a, b2) {
      null != b2 && null != b2 && (Y(this, a, 0), this.a.Ta(b2));
    };
    W.prototype.writeSint64String = W.prototype.Zd;
    W.prototype.Pa = function(a, b2) {
      null != b2 && (n2(0 <= b2 && 4294967296 > b2), Y(this, a, 5), this.a.s(b2));
    };
    W.prototype.writeFixed32 = W.prototype.Pa;
    W.prototype.Qa = function(a, b2) {
      null != b2 && (n2(0 <= b2 && 18446744073709552e3 > b2), Y(this, a, 1), this.a.V(b2));
    };
    W.prototype.writeFixed64 = W.prototype.Qa;
    W.prototype.nb = function(a, b2) {
      null != b2 && (b2 = U(b2), Y(this, a, 1), this.a.A(b2.lo, b2.hi));
    };
    W.prototype.writeFixed64String = W.prototype.nb;
    W.prototype.Ra = function(a, b2) {
      null != b2 && (n2(-2147483648 <= b2 && 2147483648 > b2), Y(this, a, 5), this.a.S(b2));
    };
    W.prototype.writeSfixed32 = W.prototype.Ra;
    W.prototype.Sa = function(a, b2) {
      null != b2 && (n2(-9223372036854776e3 <= b2 && 9223372036854776e3 > b2), Y(this, a, 1), this.a.T(b2));
    };
    W.prototype.writeSfixed64 = W.prototype.Sa;
    W.prototype.qb = function(a, b2) {
      null != b2 && (b2 = sb(b2), Y(this, a, 1), this.a.A(b2.lo, b2.hi));
    };
    W.prototype.writeSfixed64String = W.prototype.qb;
    W.prototype.L = function(a, b2) {
      null != b2 && (Y(this, a, 5), this.a.L(b2));
    };
    W.prototype.writeFloat = W.prototype.L;
    W.prototype.J = function(a, b2) {
      null != b2 && (Y(this, a, 1), this.a.J(b2));
    };
    W.prototype.writeDouble = W.prototype.J;
    W.prototype.I = function(a, b2) {
      null != b2 && (n2("boolean" === typeof b2 || "number" === typeof b2), Y(this, a, 0), this.a.I(b2));
    };
    W.prototype.writeBool = W.prototype.I;
    W.prototype.R = function(a, b2) {
      null != b2 && (n2(-2147483648 <= b2 && 2147483648 > b2), Y(this, a, 0), this.a.M(b2));
    };
    W.prototype.writeEnum = W.prototype.R;
    W.prototype.U = function(a, b2) {
      null != b2 && (a = X(this, a), this.a.U(b2), Z(this, a));
    };
    W.prototype.writeString = W.prototype.U;
    W.prototype.ja = function(a, b2) {
      null != b2 && (b2 = Ua(b2), Y(this, a, 2), this.a.j(b2.length), tb(this, b2));
    };
    W.prototype.writeBytes = W.prototype.ja;
    W.prototype.Rc = function(a, b2, c) {
      null != b2 && (a = X(this, a), c(b2, this), Z(this, a));
    };
    W.prototype.writeMessage = W.prototype.Rc;
    W.prototype.Sc = function(a, b2, c) {
      null != b2 && (Y(this, 1, 3), Y(this, 2, 0), this.a.M(a), a = X(this, 3), c(b2, this), Z(this, a), Y(this, 1, 4));
    };
    W.prototype.writeMessageSet = W.prototype.Sc;
    W.prototype.Oc = function(a, b2, c) {
      null != b2 && (Y(this, a, 3), c(b2, this), Y(this, a, 4));
    };
    W.prototype.writeGroup = W.prototype.Oc;
    W.prototype.K = function(a, b2) {
      null != b2 && (n2(8 == b2.length), Y(this, a, 1), this.a.K(b2));
    };
    W.prototype.writeFixedHash64 = W.prototype.K;
    W.prototype.N = function(a, b2) {
      null != b2 && (n2(8 == b2.length), Y(this, a, 0), this.a.N(b2));
    };
    W.prototype.writeVarintHash64 = W.prototype.N;
    W.prototype.A = function(a, b2, c) {
      Y(this, a, 1);
      this.a.A(b2, c);
    };
    W.prototype.writeSplitFixed64 = W.prototype.A;
    W.prototype.l = function(a, b2, c) {
      Y(this, a, 0);
      this.a.l(b2, c);
    };
    W.prototype.writeSplitVarint64 = W.prototype.l;
    W.prototype.tb = function(a, b2, c) {
      Y(this, a, 0);
      var d = this.a;
      Ja(b2, c, function(f2, h) {
        d.l(f2 >>> 0, h >>> 0);
      });
    };
    W.prototype.writeSplitZigzagVarint64 = W.prototype.tb;
    W.prototype.Ed = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) vb(this, a, b2[c]);
    };
    W.prototype.writeRepeatedInt32 = W.prototype.Ed;
    W.prototype.Fd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.ob(a, b2[c]);
    };
    W.prototype.writeRepeatedInt32String = W.prototype.Fd;
    W.prototype.Gd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y(this, a, 0), this.a.ua(d));
      }
    };
    W.prototype.writeRepeatedInt64 = W.prototype.Gd;
    W.prototype.Qd = function(a, b2, c, d) {
      if (null != b2) for (var f2 = 0; f2 < b2.length; f2++) this.A(a, c(b2[f2]), d(b2[f2]));
    };
    W.prototype.writeRepeatedSplitFixed64 = W.prototype.Qd;
    W.prototype.Rd = function(a, b2, c, d) {
      if (null != b2) for (var f2 = 0; f2 < b2.length; f2++) this.l(a, c(b2[f2]), d(b2[f2]));
    };
    W.prototype.writeRepeatedSplitVarint64 = W.prototype.Rd;
    W.prototype.Sd = function(a, b2, c, d) {
      if (null != b2) for (var f2 = 0; f2 < b2.length; f2++) this.tb(a, c(b2[f2]), d(b2[f2]));
    };
    W.prototype.writeRepeatedSplitZigzagVarint64 = W.prototype.Sd;
    W.prototype.Hd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.ka(a, b2[c]);
    };
    W.prototype.writeRepeatedInt64String = W.prototype.Hd;
    W.prototype.Ud = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) ub(this, a, b2[c]);
    };
    W.prototype.writeRepeatedUint32 = W.prototype.Ud;
    W.prototype.Vd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.ub(a, b2[c]);
    };
    W.prototype.writeRepeatedUint32String = W.prototype.Vd;
    W.prototype.Wd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y(this, a, 0), this.a.va(d));
      }
    };
    W.prototype.writeRepeatedUint64 = W.prototype.Wd;
    W.prototype.Xd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.vb(a, b2[c]);
    };
    W.prototype.writeRepeatedUint64String = W.prototype.Xd;
    W.prototype.Md = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y(this, a, 0), this.a.wa(d));
      }
    };
    W.prototype.writeRepeatedSint32 = W.prototype.Md;
    W.prototype.Nd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y(this, a, 0), this.a.xa(d));
      }
    };
    W.prototype.writeRepeatedSint64 = W.prototype.Nd;
    W.prototype.Od = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y(this, a, 0), this.a.Ta(d));
      }
    };
    W.prototype.writeRepeatedSint64String = W.prototype.Od;
    W.prototype.Pd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) {
        var d = b2[c];
        null != d && (Y(this, a, 0), this.a.W(d));
      }
    };
    W.prototype.writeRepeatedSintHash64 = W.prototype.Pd;
    W.prototype.yd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.Pa(a, b2[c]);
    };
    W.prototype.writeRepeatedFixed32 = W.prototype.yd;
    W.prototype.zd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.Qa(a, b2[c]);
    };
    W.prototype.writeRepeatedFixed64 = W.prototype.zd;
    W.prototype.Ad = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.nb(a, b2[c]);
    };
    W.prototype.writeRepeatedFixed64String = W.prototype.Ad;
    W.prototype.Jd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.Ra(a, b2[c]);
    };
    W.prototype.writeRepeatedSfixed32 = W.prototype.Jd;
    W.prototype.Kd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.Sa(a, b2[c]);
    };
    W.prototype.writeRepeatedSfixed64 = W.prototype.Kd;
    W.prototype.Ld = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.qb(a, b2[c]);
    };
    W.prototype.writeRepeatedSfixed64String = W.prototype.Ld;
    W.prototype.Cd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.L(a, b2[c]);
    };
    W.prototype.writeRepeatedFloat = W.prototype.Cd;
    W.prototype.wd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.J(a, b2[c]);
    };
    W.prototype.writeRepeatedDouble = W.prototype.wd;
    W.prototype.ud = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.I(a, b2[c]);
    };
    W.prototype.writeRepeatedBool = W.prototype.ud;
    W.prototype.xd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.R(a, b2[c]);
    };
    W.prototype.writeRepeatedEnum = W.prototype.xd;
    W.prototype.Td = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.U(a, b2[c]);
    };
    W.prototype.writeRepeatedString = W.prototype.Td;
    W.prototype.vd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.ja(a, b2[c]);
    };
    W.prototype.writeRepeatedBytes = W.prototype.vd;
    W.prototype.Id = function(a, b2, c) {
      if (null != b2) for (var d = 0; d < b2.length; d++) {
        var f2 = X(this, a);
        c(b2[d], this);
        Z(this, f2);
      }
    };
    W.prototype.writeRepeatedMessage = W.prototype.Id;
    W.prototype.Dd = function(a, b2, c) {
      if (null != b2) for (var d = 0; d < b2.length; d++) Y(this, a, 3), c(b2[d], this), Y(this, a, 4);
    };
    W.prototype.writeRepeatedGroup = W.prototype.Dd;
    W.prototype.Bd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.K(a, b2[c]);
    };
    W.prototype.writeRepeatedFixedHash64 = W.prototype.Bd;
    W.prototype.Yd = function(a, b2) {
      if (null != b2) for (var c = 0; c < b2.length; c++) this.N(a, b2[c]);
    };
    W.prototype.writeRepeatedVarintHash64 = W.prototype.Yd;
    W.prototype.ad = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.M(b2[c]);
        Z(this, a);
      }
    };
    W.prototype.writePackedInt32 = W.prototype.ad;
    W.prototype.bd = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.M(parseInt(b2[c], 10));
        Z(this, a);
      }
    };
    W.prototype.writePackedInt32String = W.prototype.bd;
    W.prototype.cd = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.ua(b2[c]);
        Z(this, a);
      }
    };
    W.prototype.writePackedInt64 = W.prototype.cd;
    W.prototype.md = function(a, b2, c, d) {
      if (null != b2) {
        a = X(this, a);
        for (var f2 = 0; f2 < b2.length; f2++) this.a.A(c(b2[f2]), d(b2[f2]));
        Z(this, a);
      }
    };
    W.prototype.writePackedSplitFixed64 = W.prototype.md;
    W.prototype.nd = function(a, b2, c, d) {
      if (null != b2) {
        a = X(this, a);
        for (var f2 = 0; f2 < b2.length; f2++) this.a.l(c(b2[f2]), d(b2[f2]));
        Z(this, a);
      }
    };
    W.prototype.writePackedSplitVarint64 = W.prototype.nd;
    W.prototype.od = function(a, b2, c, d) {
      if (null != b2) {
        a = X(this, a);
        for (var f2 = this.a, h = 0; h < b2.length; h++) Ja(c(b2[h]), d(b2[h]), function(m, t) {
          f2.l(m >>> 0, t >>> 0);
        });
        Z(this, a);
      }
    };
    W.prototype.writePackedSplitZigzagVarint64 = W.prototype.od;
    W.prototype.dd = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) {
          var d = sb(b2[c]);
          this.a.l(d.lo, d.hi);
        }
        Z(this, a);
      }
    };
    W.prototype.writePackedInt64String = W.prototype.dd;
    W.prototype.pd = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.j(b2[c]);
        Z(this, a);
      }
    };
    W.prototype.writePackedUint32 = W.prototype.pd;
    W.prototype.qd = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.j(parseInt(b2[c], 10));
        Z(this, a);
      }
    };
    W.prototype.writePackedUint32String = W.prototype.qd;
    W.prototype.rd = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.va(b2[c]);
        Z(this, a);
      }
    };
    W.prototype.writePackedUint64 = W.prototype.rd;
    W.prototype.sd = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) {
          var d = U(b2[c]);
          this.a.l(d.lo, d.hi);
        }
        Z(this, a);
      }
    };
    W.prototype.writePackedUint64String = W.prototype.sd;
    W.prototype.hd = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.wa(b2[c]);
        Z(this, a);
      }
    };
    W.prototype.writePackedSint32 = W.prototype.hd;
    W.prototype.jd = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.xa(b2[c]);
        Z(this, a);
      }
    };
    W.prototype.writePackedSint64 = W.prototype.jd;
    W.prototype.kd = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.W(H(b2[c]));
        Z(this, a);
      }
    };
    W.prototype.writePackedSint64String = W.prototype.kd;
    W.prototype.ld = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.W(b2[c]);
        Z(this, a);
      }
    };
    W.prototype.writePackedSintHash64 = W.prototype.ld;
    W.prototype.Wc = function(a, b2) {
      if (null != b2 && b2.length) for (Y(this, a, 2), this.a.j(4 * b2.length), a = 0; a < b2.length; a++) this.a.s(b2[a]);
    };
    W.prototype.writePackedFixed32 = W.prototype.Wc;
    W.prototype.Xc = function(a, b2) {
      if (null != b2 && b2.length) for (Y(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++) this.a.V(b2[a]);
    };
    W.prototype.writePackedFixed64 = W.prototype.Xc;
    W.prototype.Yc = function(a, b2) {
      if (null != b2 && b2.length) for (Y(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++) {
        var c = U(b2[a]);
        this.a.A(c.lo, c.hi);
      }
    };
    W.prototype.writePackedFixed64String = W.prototype.Yc;
    W.prototype.ed = function(a, b2) {
      if (null != b2 && b2.length) for (Y(this, a, 2), this.a.j(4 * b2.length), a = 0; a < b2.length; a++) this.a.S(b2[a]);
    };
    W.prototype.writePackedSfixed32 = W.prototype.ed;
    W.prototype.fd = function(a, b2) {
      if (null != b2 && b2.length) for (Y(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++) this.a.T(b2[a]);
    };
    W.prototype.writePackedSfixed64 = W.prototype.fd;
    W.prototype.gd = function(a, b2) {
      if (null != b2 && b2.length) for (Y(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++) this.a.ka(b2[a]);
    };
    W.prototype.writePackedSfixed64String = W.prototype.gd;
    W.prototype.$c = function(a, b2) {
      if (null != b2 && b2.length) for (Y(this, a, 2), this.a.j(4 * b2.length), a = 0; a < b2.length; a++) this.a.L(b2[a]);
    };
    W.prototype.writePackedFloat = W.prototype.$c;
    W.prototype.Uc = function(a, b2) {
      if (null != b2 && b2.length) for (Y(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++) this.a.J(b2[a]);
    };
    W.prototype.writePackedDouble = W.prototype.Uc;
    W.prototype.Tc = function(a, b2) {
      if (null != b2 && b2.length) for (Y(this, a, 2), this.a.j(b2.length), a = 0; a < b2.length; a++) this.a.I(b2[a]);
    };
    W.prototype.writePackedBool = W.prototype.Tc;
    W.prototype.Vc = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.R(b2[c]);
        Z(this, a);
      }
    };
    W.prototype.writePackedEnum = W.prototype.Vc;
    W.prototype.Zc = function(a, b2) {
      if (null != b2 && b2.length) for (Y(this, a, 2), this.a.j(8 * b2.length), a = 0; a < b2.length; a++) this.a.K(b2[a]);
    };
    W.prototype.writePackedFixedHash64 = W.prototype.Zc;
    W.prototype.td = function(a, b2) {
      if (null != b2 && b2.length) {
        a = X(this, a);
        for (var c = 0; c < b2.length; c++) this.a.N(b2[c]);
        Z(this, a);
      }
    };
    W.prototype.writePackedVarintHash64 = W.prototype.td;
    "object" === typeof exports && (exports.debug = R, exports.Map = r, exports.Message = N3, exports.BinaryReader = J, exports.BinaryWriter = W, exports.ExtensionFieldInfo = Ya, exports.ExtensionFieldBinaryInfo = Za, exports.exportSymbol = ma, exports.inherits = na, exports.object = { extend: pa }, exports.typeOf = k);
  }
});

// node_modules/google-protobuf/google/protobuf/any_pb.js
var require_any_pb = __commonJS({
  "node_modules/google-protobuf/google/protobuf/any_pb.js"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    goog.exportSymbol("proto.google.protobuf.Any", null, global2);
    proto.google.protobuf.Any = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.google.protobuf.Any, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      proto.google.protobuf.Any.displayName = "proto.google.protobuf.Any";
    }
    if (jspb.Message.GENERATE_TO_OBJECT) {
      proto.google.protobuf.Any.prototype.toObject = function(opt_includeInstance) {
        return proto.google.protobuf.Any.toObject(opt_includeInstance, this);
      };
      proto.google.protobuf.Any.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeUrl: jspb.Message.getFieldWithDefault(msg, 1, ""),
          value: msg.getValue_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.google.protobuf.Any.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new proto.google.protobuf.Any();
      return proto.google.protobuf.Any.deserializeBinaryFromReader(msg, reader);
    };
    proto.google.protobuf.Any.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeUrl(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setValue(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.google.protobuf.Any.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      proto.google.protobuf.Any.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.google.protobuf.Any.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeUrl();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getValue_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
    };
    proto.google.protobuf.Any.prototype.getTypeUrl = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.google.protobuf.Any.prototype.setTypeUrl = function(value) {
      return jspb.Message.setProto3StringField(this, 1, value);
    };
    proto.google.protobuf.Any.prototype.getValue = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    proto.google.protobuf.Any.prototype.getValue_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getValue()
        )
      );
    };
    proto.google.protobuf.Any.prototype.getValue_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getValue()
        )
      );
    };
    proto.google.protobuf.Any.prototype.setValue = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    goog.object.extend(exports, proto.google.protobuf);
    proto.google.protobuf.Any.prototype.getTypeName = function() {
      return this.getTypeUrl().split("/").pop();
    };
    proto.google.protobuf.Any.prototype.pack = function(serialized, name, opt_typeUrlPrefix) {
      if (!opt_typeUrlPrefix) {
        opt_typeUrlPrefix = "type.googleapis.com/";
      }
      if (opt_typeUrlPrefix.substr(-1) != "/") {
        this.setTypeUrl(opt_typeUrlPrefix + "/" + name);
      } else {
        this.setTypeUrl(opt_typeUrlPrefix + name);
      }
      this.setValue(serialized);
    };
    proto.google.protobuf.Any.prototype.unpack = function(deserialize, name) {
      if (this.getTypeName() == name) {
        return deserialize(this.getValue_asU8());
      } else {
        return null;
      }
    };
  }
});

// node_modules/tronweb/lib/esm/protocol/core/Tron_pb.cjs
var require_Tron_pb = __commonJS({
  "node_modules/tronweb/lib/esm/protocol/core/Tron_pb.cjs"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    var google_protobuf_any_pb2 = require_any_pb();
    goog.object.extend(proto, google_protobuf_any_pb2);
    goog.exportSymbol("TronWebProto.Account", null, global2);
    goog.exportSymbol("TronWebProto.Account.AccountResource", null, global2);
    goog.exportSymbol("TronWebProto.Account.Frozen", null, global2);
    goog.exportSymbol("TronWebProto.AccountId", null, global2);
    goog.exportSymbol("TronWebProto.AccountType", null, global2);
    goog.exportSymbol("TronWebProto.DelegatedResource", null, global2);
    goog.exportSymbol("TronWebProto.Exchange", null, global2);
    goog.exportSymbol("TronWebProto.Key", null, global2);
    goog.exportSymbol("TronWebProto.MarketOrderDetail", null, global2);
    goog.exportSymbol("TronWebProto.Permission", null, global2);
    goog.exportSymbol("TronWebProto.Permission.PermissionType", null, global2);
    goog.exportSymbol("TronWebProto.Proposal", null, global2);
    goog.exportSymbol("TronWebProto.Proposal.State", null, global2);
    goog.exportSymbol("TronWebProto.Transaction", null, global2);
    goog.exportSymbol("TronWebProto.Transaction.Contract", null, global2);
    goog.exportSymbol("TronWebProto.Transaction.Contract.ContractType", null, global2);
    goog.exportSymbol("TronWebProto.Transaction.Result", null, global2);
    goog.exportSymbol("TronWebProto.Transaction.Result.code", null, global2);
    goog.exportSymbol("TronWebProto.Transaction.Result.contractResult", null, global2);
    goog.exportSymbol("TronWebProto.Transaction.raw", null, global2);
    goog.exportSymbol("TronWebProto.Vote", null, global2);
    goog.exportSymbol("TronWebProto.Votes", null, global2);
    goog.exportSymbol("TronWebProto.Witness", null, global2);
    goog.exportSymbol("TronWebProto.authority", null, global2);
    TronWebProto.AccountId = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.AccountId, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.AccountId.displayName = "TronWebProto.AccountId";
    }
    TronWebProto.Vote = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.Vote, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Vote.displayName = "TronWebProto.Vote";
    }
    TronWebProto.Proposal = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Proposal.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.Proposal, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Proposal.displayName = "TronWebProto.Proposal";
    }
    TronWebProto.Exchange = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.Exchange, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Exchange.displayName = "TronWebProto.Exchange";
    }
    TronWebProto.Account = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Account.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.Account, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Account.displayName = "TronWebProto.Account";
    }
    TronWebProto.Account.Frozen = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.Account.Frozen, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Account.Frozen.displayName = "TronWebProto.Account.Frozen";
    }
    TronWebProto.Account.AccountResource = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.Account.AccountResource, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Account.AccountResource.displayName = "TronWebProto.Account.AccountResource";
    }
    TronWebProto.Key = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.Key, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Key.displayName = "TronWebProto.Key";
    }
    TronWebProto.DelegatedResource = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.DelegatedResource, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.DelegatedResource.displayName = "TronWebProto.DelegatedResource";
    }
    TronWebProto.authority = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.authority, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.authority.displayName = "TronWebProto.authority";
    }
    TronWebProto.Permission = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Permission.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.Permission, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Permission.displayName = "TronWebProto.Permission";
    }
    TronWebProto.Witness = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.Witness, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Witness.displayName = "TronWebProto.Witness";
    }
    TronWebProto.Votes = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Votes.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.Votes, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Votes.displayName = "TronWebProto.Votes";
    }
    TronWebProto.MarketOrderDetail = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.MarketOrderDetail, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.MarketOrderDetail.displayName = "TronWebProto.MarketOrderDetail";
    }
    TronWebProto.Transaction = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Transaction.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.Transaction, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Transaction.displayName = "TronWebProto.Transaction";
    }
    TronWebProto.Transaction.Contract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.Transaction.Contract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Transaction.Contract.displayName = "TronWebProto.Transaction.Contract";
    }
    TronWebProto.Transaction.Result = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Transaction.Result.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.Transaction.Result, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Transaction.Result.displayName = "TronWebProto.Transaction.Result";
    }
    TronWebProto.Transaction.raw = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.Transaction.raw.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.Transaction.raw, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.Transaction.raw.displayName = "TronWebProto.Transaction.raw";
    }
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.AccountId.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.AccountId.toObject(opt_includeInstance, this);
      };
      TronWebProto.AccountId.toObject = function(includeInstance, msg) {
        var f2, obj = {
          name: msg.getName_asB64(),
          address: msg.getAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.AccountId.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.AccountId();
      return TronWebProto.AccountId.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.AccountId.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setName(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.AccountId.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.AccountId.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.AccountId.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getName_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
    };
    TronWebProto.AccountId.prototype.getName = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.AccountId.prototype.getName_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getName()
        )
      );
    };
    TronWebProto.AccountId.prototype.getName_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getName()
        )
      );
    };
    TronWebProto.AccountId.prototype.setName = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.AccountId.prototype.getAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.AccountId.prototype.getAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAddress()
        )
      );
    };
    TronWebProto.AccountId.prototype.getAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAddress()
        )
      );
    };
    TronWebProto.AccountId.prototype.setAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Vote.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Vote.toObject(opt_includeInstance, this);
      };
      TronWebProto.Vote.toObject = function(includeInstance, msg) {
        var f2, obj = {
          voteAddress: msg.getVoteAddress_asB64(),
          voteCount: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Vote.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Vote();
      return TronWebProto.Vote.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Vote.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setVoteAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setVoteCount(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Vote.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Vote.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Vote.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getVoteAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getVoteCount();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
    };
    TronWebProto.Vote.prototype.getVoteAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.Vote.prototype.getVoteAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getVoteAddress()
        )
      );
    };
    TronWebProto.Vote.prototype.getVoteAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getVoteAddress()
        )
      );
    };
    TronWebProto.Vote.prototype.setVoteAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.Vote.prototype.getVoteCount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.Vote.prototype.setVoteCount = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.Proposal.repeatedFields_ = [6];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Proposal.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Proposal.toObject(opt_includeInstance, this);
      };
      TronWebProto.Proposal.toObject = function(includeInstance, msg) {
        var f2, obj = {
          proposalId: jspb.Message.getFieldWithDefault(msg, 1, 0),
          proposerAddress: msg.getProposerAddress_asB64(),
          parametersMap: (f2 = msg.getParametersMap()) ? f2.toObject(includeInstance, void 0) : [],
          expirationTime: jspb.Message.getFieldWithDefault(msg, 4, 0),
          createTime: jspb.Message.getFieldWithDefault(msg, 5, 0),
          approvalsList: msg.getApprovalsList_asB64(),
          state: jspb.Message.getFieldWithDefault(msg, 7, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Proposal.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Proposal();
      return TronWebProto.Proposal.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Proposal.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setProposalId(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setProposerAddress(value);
            break;
          case 3:
            var value = msg.getParametersMap();
            reader.readMessage(value, function(message, reader2) {
              jspb.Map.deserializeBinary(message, reader2, jspb.BinaryReader.prototype.readInt64, jspb.BinaryReader.prototype.readInt64, null, 0, 0);
            });
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExpirationTime(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setCreateTime(value);
            break;
          case 6:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.addApprovals(value);
            break;
          case 7:
            var value = (
              /** @type {!TronWebProto.Proposal.State} */
              reader.readEnum()
            );
            msg.setState(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Proposal.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Proposal.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Proposal.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getProposalId();
      if (f2 !== 0) {
        writer.writeInt64(
          1,
          f2
        );
      }
      f2 = message.getProposerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getParametersMap(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(3, writer, jspb.BinaryWriter.prototype.writeInt64, jspb.BinaryWriter.prototype.writeInt64);
      }
      f2 = message.getExpirationTime();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
      f2 = message.getCreateTime();
      if (f2 !== 0) {
        writer.writeInt64(
          5,
          f2
        );
      }
      f2 = message.getApprovalsList_asU8();
      if (f2.length > 0) {
        writer.writeRepeatedBytes(
          6,
          f2
        );
      }
      f2 = message.getState();
      if (f2 !== 0) {
        writer.writeEnum(
          7,
          f2
        );
      }
    };
    TronWebProto.Proposal.State = {
      PENDING: 0,
      DISAPPROVED: 1,
      APPROVED: 2,
      CANCELED: 3
    };
    TronWebProto.Proposal.prototype.getProposalId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.Proposal.prototype.setProposalId = function(value) {
      return jspb.Message.setProto3IntField(this, 1, value);
    };
    TronWebProto.Proposal.prototype.getProposerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.Proposal.prototype.getProposerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getProposerAddress()
        )
      );
    };
    TronWebProto.Proposal.prototype.getProposerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getProposerAddress()
        )
      );
    };
    TronWebProto.Proposal.prototype.setProposerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.Proposal.prototype.getParametersMap = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<number,number>} */
        jspb.Message.getMapField(
          this,
          3,
          opt_noLazyCreate,
          null
        )
      );
    };
    TronWebProto.Proposal.prototype.clearParametersMap = function() {
      this.getParametersMap().clear();
      return this;
    };
    TronWebProto.Proposal.prototype.getExpirationTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.Proposal.prototype.setExpirationTime = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    TronWebProto.Proposal.prototype.getCreateTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.Proposal.prototype.setCreateTime = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    TronWebProto.Proposal.prototype.getApprovalsList = function() {
      return (
        /** @type {!(Array<!Uint8Array>|Array<string>)} */
        jspb.Message.getRepeatedField(this, 6)
      );
    };
    TronWebProto.Proposal.prototype.getApprovalsList_asB64 = function() {
      return (
        /** @type {!Array<string>} */
        jspb.Message.bytesListAsB64(
          this.getApprovalsList()
        )
      );
    };
    TronWebProto.Proposal.prototype.getApprovalsList_asU8 = function() {
      return (
        /** @type {!Array<!Uint8Array>} */
        jspb.Message.bytesListAsU8(
          this.getApprovalsList()
        )
      );
    };
    TronWebProto.Proposal.prototype.setApprovalsList = function(value) {
      return jspb.Message.setField(this, 6, value || []);
    };
    TronWebProto.Proposal.prototype.addApprovals = function(value, opt_index) {
      return jspb.Message.addToRepeatedField(this, 6, value, opt_index);
    };
    TronWebProto.Proposal.prototype.clearApprovalsList = function() {
      return this.setApprovalsList([]);
    };
    TronWebProto.Proposal.prototype.getState = function() {
      return (
        /** @type {!TronWebProto.Proposal.State} */
        jspb.Message.getFieldWithDefault(this, 7, 0)
      );
    };
    TronWebProto.Proposal.prototype.setState = function(value) {
      return jspb.Message.setProto3EnumField(this, 7, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Exchange.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Exchange.toObject(opt_includeInstance, this);
      };
      TronWebProto.Exchange.toObject = function(includeInstance, msg) {
        var f2, obj = {
          exchangeId: jspb.Message.getFieldWithDefault(msg, 1, 0),
          creatorAddress: msg.getCreatorAddress_asB64(),
          createTime: jspb.Message.getFieldWithDefault(msg, 3, 0),
          firstTokenId: msg.getFirstTokenId_asB64(),
          firstTokenBalance: jspb.Message.getFieldWithDefault(msg, 7, 0),
          secondTokenId: msg.getSecondTokenId_asB64(),
          secondTokenBalance: jspb.Message.getFieldWithDefault(msg, 9, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Exchange.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Exchange();
      return TronWebProto.Exchange.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Exchange.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExchangeId(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setCreatorAddress(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setCreateTime(value);
            break;
          case 6:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setFirstTokenId(value);
            break;
          case 7:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFirstTokenBalance(value);
            break;
          case 8:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setSecondTokenId(value);
            break;
          case 9:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setSecondTokenBalance(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Exchange.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Exchange.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Exchange.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getExchangeId();
      if (f2 !== 0) {
        writer.writeInt64(
          1,
          f2
        );
      }
      f2 = message.getCreatorAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getCreateTime();
      if (f2 !== 0) {
        writer.writeInt64(
          3,
          f2
        );
      }
      f2 = message.getFirstTokenId_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          6,
          f2
        );
      }
      f2 = message.getFirstTokenBalance();
      if (f2 !== 0) {
        writer.writeInt64(
          7,
          f2
        );
      }
      f2 = message.getSecondTokenId_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          8,
          f2
        );
      }
      f2 = message.getSecondTokenBalance();
      if (f2 !== 0) {
        writer.writeInt64(
          9,
          f2
        );
      }
    };
    TronWebProto.Exchange.prototype.getExchangeId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.Exchange.prototype.setExchangeId = function(value) {
      return jspb.Message.setProto3IntField(this, 1, value);
    };
    TronWebProto.Exchange.prototype.getCreatorAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.Exchange.prototype.getCreatorAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getCreatorAddress()
        )
      );
    };
    TronWebProto.Exchange.prototype.getCreatorAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getCreatorAddress()
        )
      );
    };
    TronWebProto.Exchange.prototype.setCreatorAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.Exchange.prototype.getCreateTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.Exchange.prototype.setCreateTime = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.Exchange.prototype.getFirstTokenId = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 6, "")
      );
    };
    TronWebProto.Exchange.prototype.getFirstTokenId_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getFirstTokenId()
        )
      );
    };
    TronWebProto.Exchange.prototype.getFirstTokenId_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getFirstTokenId()
        )
      );
    };
    TronWebProto.Exchange.prototype.setFirstTokenId = function(value) {
      return jspb.Message.setProto3BytesField(this, 6, value);
    };
    TronWebProto.Exchange.prototype.getFirstTokenBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 7, 0)
      );
    };
    TronWebProto.Exchange.prototype.setFirstTokenBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 7, value);
    };
    TronWebProto.Exchange.prototype.getSecondTokenId = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 8, "")
      );
    };
    TronWebProto.Exchange.prototype.getSecondTokenId_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getSecondTokenId()
        )
      );
    };
    TronWebProto.Exchange.prototype.getSecondTokenId_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getSecondTokenId()
        )
      );
    };
    TronWebProto.Exchange.prototype.setSecondTokenId = function(value) {
      return jspb.Message.setProto3BytesField(this, 8, value);
    };
    TronWebProto.Exchange.prototype.getSecondTokenBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 9, 0)
      );
    };
    TronWebProto.Exchange.prototype.setSecondTokenBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 9, value);
    };
    TronWebProto.Account.repeatedFields_ = [5, 7, 16, 33];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Account.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Account.toObject(opt_includeInstance, this);
      };
      TronWebProto.Account.toObject = function(includeInstance, msg) {
        var f2, obj = {
          accountName: msg.getAccountName_asB64(),
          type: jspb.Message.getFieldWithDefault(msg, 2, 0),
          address: msg.getAddress_asB64(),
          balance: jspb.Message.getFieldWithDefault(msg, 4, 0),
          votesList: jspb.Message.toObjectList(
            msg.getVotesList(),
            TronWebProto.Vote.toObject,
            includeInstance
          ),
          assetMap: (f2 = msg.getAssetMap()) ? f2.toObject(includeInstance, void 0) : [],
          assetv2Map: (f2 = msg.getAssetv2Map()) ? f2.toObject(includeInstance, void 0) : [],
          frozenList: jspb.Message.toObjectList(
            msg.getFrozenList(),
            TronWebProto.Account.Frozen.toObject,
            includeInstance
          ),
          netUsage: jspb.Message.getFieldWithDefault(msg, 8, 0),
          acquiredDelegatedFrozenBalanceForBandwidth: jspb.Message.getFieldWithDefault(msg, 41, 0),
          delegatedFrozenBalanceForBandwidth: jspb.Message.getFieldWithDefault(msg, 42, 0),
          oldTronPower: jspb.Message.getFieldWithDefault(msg, 46, 0),
          tronPower: (f2 = msg.getTronPower()) && TronWebProto.Account.Frozen.toObject(includeInstance, f2),
          assetOptimized: jspb.Message.getBooleanFieldWithDefault(msg, 60, false),
          createTime: jspb.Message.getFieldWithDefault(msg, 9, 0),
          latestOprationTime: jspb.Message.getFieldWithDefault(msg, 10, 0),
          allowance: jspb.Message.getFieldWithDefault(msg, 11, 0),
          latestWithdrawTime: jspb.Message.getFieldWithDefault(msg, 12, 0),
          code: msg.getCode_asB64(),
          isWitness: jspb.Message.getBooleanFieldWithDefault(msg, 14, false),
          isCommittee: jspb.Message.getBooleanFieldWithDefault(msg, 15, false),
          frozenSupplyList: jspb.Message.toObjectList(
            msg.getFrozenSupplyList(),
            TronWebProto.Account.Frozen.toObject,
            includeInstance
          ),
          assetIssuedName: msg.getAssetIssuedName_asB64(),
          assetIssuedId: msg.getAssetIssuedId_asB64(),
          latestAssetOperationTimeMap: (f2 = msg.getLatestAssetOperationTimeMap()) ? f2.toObject(includeInstance, void 0) : [],
          latestAssetOperationTimev2Map: (f2 = msg.getLatestAssetOperationTimev2Map()) ? f2.toObject(includeInstance, void 0) : [],
          freeNetUsage: jspb.Message.getFieldWithDefault(msg, 19, 0),
          freeAssetNetUsageMap: (f2 = msg.getFreeAssetNetUsageMap()) ? f2.toObject(includeInstance, void 0) : [],
          freeAssetNetUsagev2Map: (f2 = msg.getFreeAssetNetUsagev2Map()) ? f2.toObject(includeInstance, void 0) : [],
          latestConsumeTime: jspb.Message.getFieldWithDefault(msg, 21, 0),
          latestConsumeFreeTime: jspb.Message.getFieldWithDefault(msg, 22, 0),
          accountId: msg.getAccountId_asB64(),
          accountResource: (f2 = msg.getAccountResource()) && TronWebProto.Account.AccountResource.toObject(includeInstance, f2),
          codehash: msg.getCodehash_asB64(),
          ownerPermission: (f2 = msg.getOwnerPermission()) && TronWebProto.Permission.toObject(includeInstance, f2),
          witnessPermission: (f2 = msg.getWitnessPermission()) && TronWebProto.Permission.toObject(includeInstance, f2),
          activePermissionList: jspb.Message.toObjectList(
            msg.getActivePermissionList(),
            TronWebProto.Permission.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Account.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Account();
      return TronWebProto.Account.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Account.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAccountName(value);
            break;
          case 2:
            var value = (
              /** @type {!TronWebProto.AccountType} */
              reader.readEnum()
            );
            msg.setType(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAddress(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setBalance(value);
            break;
          case 5:
            var value = new TronWebProto.Vote();
            reader.readMessage(value, TronWebProto.Vote.deserializeBinaryFromReader);
            msg.addVotes(value);
            break;
          case 6:
            var value = msg.getAssetMap();
            reader.readMessage(value, function(message, reader2) {
              jspb.Map.deserializeBinary(message, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
            });
            break;
          case 56:
            var value = msg.getAssetv2Map();
            reader.readMessage(value, function(message, reader2) {
              jspb.Map.deserializeBinary(message, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
            });
            break;
          case 7:
            var value = new TronWebProto.Account.Frozen();
            reader.readMessage(value, TronWebProto.Account.Frozen.deserializeBinaryFromReader);
            msg.addFrozen(value);
            break;
          case 8:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setNetUsage(value);
            break;
          case 41:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setAcquiredDelegatedFrozenBalanceForBandwidth(value);
            break;
          case 42:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setDelegatedFrozenBalanceForBandwidth(value);
            break;
          case 46:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setOldTronPower(value);
            break;
          case 47:
            var value = new TronWebProto.Account.Frozen();
            reader.readMessage(value, TronWebProto.Account.Frozen.deserializeBinaryFromReader);
            msg.setTronPower(value);
            break;
          case 60:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setAssetOptimized(value);
            break;
          case 9:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setCreateTime(value);
            break;
          case 10:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setLatestOprationTime(value);
            break;
          case 11:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setAllowance(value);
            break;
          case 12:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setLatestWithdrawTime(value);
            break;
          case 13:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setCode(value);
            break;
          case 14:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setIsWitness(value);
            break;
          case 15:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setIsCommittee(value);
            break;
          case 16:
            var value = new TronWebProto.Account.Frozen();
            reader.readMessage(value, TronWebProto.Account.Frozen.deserializeBinaryFromReader);
            msg.addFrozenSupply(value);
            break;
          case 17:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAssetIssuedName(value);
            break;
          case 57:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAssetIssuedId(value);
            break;
          case 18:
            var value = msg.getLatestAssetOperationTimeMap();
            reader.readMessage(value, function(message, reader2) {
              jspb.Map.deserializeBinary(message, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
            });
            break;
          case 58:
            var value = msg.getLatestAssetOperationTimev2Map();
            reader.readMessage(value, function(message, reader2) {
              jspb.Map.deserializeBinary(message, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
            });
            break;
          case 19:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFreeNetUsage(value);
            break;
          case 20:
            var value = msg.getFreeAssetNetUsageMap();
            reader.readMessage(value, function(message, reader2) {
              jspb.Map.deserializeBinary(message, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
            });
            break;
          case 59:
            var value = msg.getFreeAssetNetUsagev2Map();
            reader.readMessage(value, function(message, reader2) {
              jspb.Map.deserializeBinary(message, reader2, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64, null, "", 0);
            });
            break;
          case 21:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setLatestConsumeTime(value);
            break;
          case 22:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setLatestConsumeFreeTime(value);
            break;
          case 23:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAccountId(value);
            break;
          case 26:
            var value = new TronWebProto.Account.AccountResource();
            reader.readMessage(value, TronWebProto.Account.AccountResource.deserializeBinaryFromReader);
            msg.setAccountResource(value);
            break;
          case 30:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setCodehash(value);
            break;
          case 31:
            var value = new TronWebProto.Permission();
            reader.readMessage(value, TronWebProto.Permission.deserializeBinaryFromReader);
            msg.setOwnerPermission(value);
            break;
          case 32:
            var value = new TronWebProto.Permission();
            reader.readMessage(value, TronWebProto.Permission.deserializeBinaryFromReader);
            msg.setWitnessPermission(value);
            break;
          case 33:
            var value = new TronWebProto.Permission();
            reader.readMessage(value, TronWebProto.Permission.deserializeBinaryFromReader);
            msg.addActivePermission(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Account.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Account.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Account.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAccountName_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getType();
      if (f2 !== 0) {
        writer.writeEnum(
          2,
          f2
        );
      }
      f2 = message.getAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getBalance();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
      f2 = message.getVotesList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          5,
          f2,
          TronWebProto.Vote.serializeBinaryToWriter
        );
      }
      f2 = message.getAssetMap(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(6, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
      }
      f2 = message.getAssetv2Map(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(56, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
      }
      f2 = message.getFrozenList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          7,
          f2,
          TronWebProto.Account.Frozen.serializeBinaryToWriter
        );
      }
      f2 = message.getNetUsage();
      if (f2 !== 0) {
        writer.writeInt64(
          8,
          f2
        );
      }
      f2 = message.getAcquiredDelegatedFrozenBalanceForBandwidth();
      if (f2 !== 0) {
        writer.writeInt64(
          41,
          f2
        );
      }
      f2 = message.getDelegatedFrozenBalanceForBandwidth();
      if (f2 !== 0) {
        writer.writeInt64(
          42,
          f2
        );
      }
      f2 = message.getOldTronPower();
      if (f2 !== 0) {
        writer.writeInt64(
          46,
          f2
        );
      }
      f2 = message.getTronPower();
      if (f2 != null) {
        writer.writeMessage(
          47,
          f2,
          TronWebProto.Account.Frozen.serializeBinaryToWriter
        );
      }
      f2 = message.getAssetOptimized();
      if (f2) {
        writer.writeBool(
          60,
          f2
        );
      }
      f2 = message.getCreateTime();
      if (f2 !== 0) {
        writer.writeInt64(
          9,
          f2
        );
      }
      f2 = message.getLatestOprationTime();
      if (f2 !== 0) {
        writer.writeInt64(
          10,
          f2
        );
      }
      f2 = message.getAllowance();
      if (f2 !== 0) {
        writer.writeInt64(
          11,
          f2
        );
      }
      f2 = message.getLatestWithdrawTime();
      if (f2 !== 0) {
        writer.writeInt64(
          12,
          f2
        );
      }
      f2 = message.getCode_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          13,
          f2
        );
      }
      f2 = message.getIsWitness();
      if (f2) {
        writer.writeBool(
          14,
          f2
        );
      }
      f2 = message.getIsCommittee();
      if (f2) {
        writer.writeBool(
          15,
          f2
        );
      }
      f2 = message.getFrozenSupplyList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          16,
          f2,
          TronWebProto.Account.Frozen.serializeBinaryToWriter
        );
      }
      f2 = message.getAssetIssuedName_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          17,
          f2
        );
      }
      f2 = message.getAssetIssuedId_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          57,
          f2
        );
      }
      f2 = message.getLatestAssetOperationTimeMap(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(18, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
      }
      f2 = message.getLatestAssetOperationTimev2Map(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(58, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
      }
      f2 = message.getFreeNetUsage();
      if (f2 !== 0) {
        writer.writeInt64(
          19,
          f2
        );
      }
      f2 = message.getFreeAssetNetUsageMap(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(20, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
      }
      f2 = message.getFreeAssetNetUsagev2Map(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(59, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
      }
      f2 = message.getLatestConsumeTime();
      if (f2 !== 0) {
        writer.writeInt64(
          21,
          f2
        );
      }
      f2 = message.getLatestConsumeFreeTime();
      if (f2 !== 0) {
        writer.writeInt64(
          22,
          f2
        );
      }
      f2 = message.getAccountId_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          23,
          f2
        );
      }
      f2 = message.getAccountResource();
      if (f2 != null) {
        writer.writeMessage(
          26,
          f2,
          TronWebProto.Account.AccountResource.serializeBinaryToWriter
        );
      }
      f2 = message.getCodehash_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          30,
          f2
        );
      }
      f2 = message.getOwnerPermission();
      if (f2 != null) {
        writer.writeMessage(
          31,
          f2,
          TronWebProto.Permission.serializeBinaryToWriter
        );
      }
      f2 = message.getWitnessPermission();
      if (f2 != null) {
        writer.writeMessage(
          32,
          f2,
          TronWebProto.Permission.serializeBinaryToWriter
        );
      }
      f2 = message.getActivePermissionList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          33,
          f2,
          TronWebProto.Permission.serializeBinaryToWriter
        );
      }
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Account.Frozen.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Account.Frozen.toObject(opt_includeInstance, this);
      };
      TronWebProto.Account.Frozen.toObject = function(includeInstance, msg) {
        var f2, obj = {
          frozenBalance: jspb.Message.getFieldWithDefault(msg, 1, 0),
          expireTime: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Account.Frozen.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Account.Frozen();
      return TronWebProto.Account.Frozen.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Account.Frozen.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFrozenBalance(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExpireTime(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Account.Frozen.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Account.Frozen.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Account.Frozen.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getFrozenBalance();
      if (f2 !== 0) {
        writer.writeInt64(
          1,
          f2
        );
      }
      f2 = message.getExpireTime();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
    };
    TronWebProto.Account.Frozen.prototype.getFrozenBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.Account.Frozen.prototype.setFrozenBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 1, value);
    };
    TronWebProto.Account.Frozen.prototype.getExpireTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.Account.Frozen.prototype.setExpireTime = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Account.AccountResource.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Account.AccountResource.toObject(opt_includeInstance, this);
      };
      TronWebProto.Account.AccountResource.toObject = function(includeInstance, msg) {
        var f2, obj = {
          energyUsage: jspb.Message.getFieldWithDefault(msg, 1, 0),
          frozenBalanceForEnergy: (f2 = msg.getFrozenBalanceForEnergy()) && TronWebProto.Account.Frozen.toObject(includeInstance, f2),
          latestConsumeTimeForEnergy: jspb.Message.getFieldWithDefault(msg, 3, 0),
          acquiredDelegatedFrozenBalanceForEnergy: jspb.Message.getFieldWithDefault(msg, 4, 0),
          delegatedFrozenBalanceForEnergy: jspb.Message.getFieldWithDefault(msg, 5, 0),
          storageLimit: jspb.Message.getFieldWithDefault(msg, 6, 0),
          storageUsage: jspb.Message.getFieldWithDefault(msg, 7, 0),
          latestExchangeStorageTime: jspb.Message.getFieldWithDefault(msg, 8, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Account.AccountResource.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Account.AccountResource();
      return TronWebProto.Account.AccountResource.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Account.AccountResource.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setEnergyUsage(value);
            break;
          case 2:
            var value = new TronWebProto.Account.Frozen();
            reader.readMessage(value, TronWebProto.Account.Frozen.deserializeBinaryFromReader);
            msg.setFrozenBalanceForEnergy(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setLatestConsumeTimeForEnergy(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setAcquiredDelegatedFrozenBalanceForEnergy(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setDelegatedFrozenBalanceForEnergy(value);
            break;
          case 6:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setStorageLimit(value);
            break;
          case 7:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setStorageUsage(value);
            break;
          case 8:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setLatestExchangeStorageTime(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Account.AccountResource.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Account.AccountResource.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Account.AccountResource.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getEnergyUsage();
      if (f2 !== 0) {
        writer.writeInt64(
          1,
          f2
        );
      }
      f2 = message.getFrozenBalanceForEnergy();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          TronWebProto.Account.Frozen.serializeBinaryToWriter
        );
      }
      f2 = message.getLatestConsumeTimeForEnergy();
      if (f2 !== 0) {
        writer.writeInt64(
          3,
          f2
        );
      }
      f2 = message.getAcquiredDelegatedFrozenBalanceForEnergy();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
      f2 = message.getDelegatedFrozenBalanceForEnergy();
      if (f2 !== 0) {
        writer.writeInt64(
          5,
          f2
        );
      }
      f2 = message.getStorageLimit();
      if (f2 !== 0) {
        writer.writeInt64(
          6,
          f2
        );
      }
      f2 = message.getStorageUsage();
      if (f2 !== 0) {
        writer.writeInt64(
          7,
          f2
        );
      }
      f2 = message.getLatestExchangeStorageTime();
      if (f2 !== 0) {
        writer.writeInt64(
          8,
          f2
        );
      }
    };
    TronWebProto.Account.AccountResource.prototype.getEnergyUsage = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.Account.AccountResource.prototype.setEnergyUsage = function(value) {
      return jspb.Message.setProto3IntField(this, 1, value);
    };
    TronWebProto.Account.AccountResource.prototype.getFrozenBalanceForEnergy = function() {
      return (
        /** @type{?TronWebProto.Account.Frozen} */
        jspb.Message.getWrapperField(this, TronWebProto.Account.Frozen, 2)
      );
    };
    TronWebProto.Account.AccountResource.prototype.setFrozenBalanceForEnergy = function(value) {
      return jspb.Message.setWrapperField(this, 2, value);
    };
    TronWebProto.Account.AccountResource.prototype.clearFrozenBalanceForEnergy = function() {
      return this.setFrozenBalanceForEnergy(void 0);
    };
    TronWebProto.Account.AccountResource.prototype.hasFrozenBalanceForEnergy = function() {
      return jspb.Message.getField(this, 2) != null;
    };
    TronWebProto.Account.AccountResource.prototype.getLatestConsumeTimeForEnergy = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.Account.AccountResource.prototype.setLatestConsumeTimeForEnergy = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.Account.AccountResource.prototype.getAcquiredDelegatedFrozenBalanceForEnergy = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.Account.AccountResource.prototype.setAcquiredDelegatedFrozenBalanceForEnergy = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    TronWebProto.Account.AccountResource.prototype.getDelegatedFrozenBalanceForEnergy = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.Account.AccountResource.prototype.setDelegatedFrozenBalanceForEnergy = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    TronWebProto.Account.AccountResource.prototype.getStorageLimit = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 6, 0)
      );
    };
    TronWebProto.Account.AccountResource.prototype.setStorageLimit = function(value) {
      return jspb.Message.setProto3IntField(this, 6, value);
    };
    TronWebProto.Account.AccountResource.prototype.getStorageUsage = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 7, 0)
      );
    };
    TronWebProto.Account.AccountResource.prototype.setStorageUsage = function(value) {
      return jspb.Message.setProto3IntField(this, 7, value);
    };
    TronWebProto.Account.AccountResource.prototype.getLatestExchangeStorageTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 8, 0)
      );
    };
    TronWebProto.Account.AccountResource.prototype.setLatestExchangeStorageTime = function(value) {
      return jspb.Message.setProto3IntField(this, 8, value);
    };
    TronWebProto.Account.prototype.getAccountName = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.Account.prototype.getAccountName_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAccountName()
        )
      );
    };
    TronWebProto.Account.prototype.getAccountName_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAccountName()
        )
      );
    };
    TronWebProto.Account.prototype.setAccountName = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.Account.prototype.getType = function() {
      return (
        /** @type {!TronWebProto.AccountType} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.Account.prototype.setType = function(value) {
      return jspb.Message.setProto3EnumField(this, 2, value);
    };
    TronWebProto.Account.prototype.getAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.Account.prototype.getAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAddress()
        )
      );
    };
    TronWebProto.Account.prototype.getAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAddress()
        )
      );
    };
    TronWebProto.Account.prototype.setAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 3, value);
    };
    TronWebProto.Account.prototype.getBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.Account.prototype.setBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    TronWebProto.Account.prototype.getVotesList = function() {
      return (
        /** @type{!Array<!TronWebProto.Vote>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 5)
      );
    };
    TronWebProto.Account.prototype.setVotesList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 5, value);
    };
    TronWebProto.Account.prototype.addVotes = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, TronWebProto.Vote, opt_index);
    };
    TronWebProto.Account.prototype.clearVotesList = function() {
      return this.setVotesList([]);
    };
    TronWebProto.Account.prototype.getAssetMap = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<string,number>} */
        jspb.Message.getMapField(
          this,
          6,
          opt_noLazyCreate,
          null
        )
      );
    };
    TronWebProto.Account.prototype.clearAssetMap = function() {
      this.getAssetMap().clear();
      return this;
    };
    TronWebProto.Account.prototype.getAssetv2Map = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<string,number>} */
        jspb.Message.getMapField(
          this,
          56,
          opt_noLazyCreate,
          null
        )
      );
    };
    TronWebProto.Account.prototype.clearAssetv2Map = function() {
      this.getAssetv2Map().clear();
      return this;
    };
    TronWebProto.Account.prototype.getFrozenList = function() {
      return (
        /** @type{!Array<!TronWebProto.Account.Frozen>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.Account.Frozen, 7)
      );
    };
    TronWebProto.Account.prototype.setFrozenList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 7, value);
    };
    TronWebProto.Account.prototype.addFrozen = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, TronWebProto.Account.Frozen, opt_index);
    };
    TronWebProto.Account.prototype.clearFrozenList = function() {
      return this.setFrozenList([]);
    };
    TronWebProto.Account.prototype.getNetUsage = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 8, 0)
      );
    };
    TronWebProto.Account.prototype.setNetUsage = function(value) {
      return jspb.Message.setProto3IntField(this, 8, value);
    };
    TronWebProto.Account.prototype.getAcquiredDelegatedFrozenBalanceForBandwidth = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 41, 0)
      );
    };
    TronWebProto.Account.prototype.setAcquiredDelegatedFrozenBalanceForBandwidth = function(value) {
      return jspb.Message.setProto3IntField(this, 41, value);
    };
    TronWebProto.Account.prototype.getDelegatedFrozenBalanceForBandwidth = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 42, 0)
      );
    };
    TronWebProto.Account.prototype.setDelegatedFrozenBalanceForBandwidth = function(value) {
      return jspb.Message.setProto3IntField(this, 42, value);
    };
    TronWebProto.Account.prototype.getOldTronPower = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 46, 0)
      );
    };
    TronWebProto.Account.prototype.setOldTronPower = function(value) {
      return jspb.Message.setProto3IntField(this, 46, value);
    };
    TronWebProto.Account.prototype.getTronPower = function() {
      return (
        /** @type{?TronWebProto.Account.Frozen} */
        jspb.Message.getWrapperField(this, TronWebProto.Account.Frozen, 47)
      );
    };
    TronWebProto.Account.prototype.setTronPower = function(value) {
      return jspb.Message.setWrapperField(this, 47, value);
    };
    TronWebProto.Account.prototype.clearTronPower = function() {
      return this.setTronPower(void 0);
    };
    TronWebProto.Account.prototype.hasTronPower = function() {
      return jspb.Message.getField(this, 47) != null;
    };
    TronWebProto.Account.prototype.getAssetOptimized = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 60, false)
      );
    };
    TronWebProto.Account.prototype.setAssetOptimized = function(value) {
      return jspb.Message.setProto3BooleanField(this, 60, value);
    };
    TronWebProto.Account.prototype.getCreateTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 9, 0)
      );
    };
    TronWebProto.Account.prototype.setCreateTime = function(value) {
      return jspb.Message.setProto3IntField(this, 9, value);
    };
    TronWebProto.Account.prototype.getLatestOprationTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 10, 0)
      );
    };
    TronWebProto.Account.prototype.setLatestOprationTime = function(value) {
      return jspb.Message.setProto3IntField(this, 10, value);
    };
    TronWebProto.Account.prototype.getAllowance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 11, 0)
      );
    };
    TronWebProto.Account.prototype.setAllowance = function(value) {
      return jspb.Message.setProto3IntField(this, 11, value);
    };
    TronWebProto.Account.prototype.getLatestWithdrawTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 12, 0)
      );
    };
    TronWebProto.Account.prototype.setLatestWithdrawTime = function(value) {
      return jspb.Message.setProto3IntField(this, 12, value);
    };
    TronWebProto.Account.prototype.getCode = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 13, "")
      );
    };
    TronWebProto.Account.prototype.getCode_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getCode()
        )
      );
    };
    TronWebProto.Account.prototype.getCode_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getCode()
        )
      );
    };
    TronWebProto.Account.prototype.setCode = function(value) {
      return jspb.Message.setProto3BytesField(this, 13, value);
    };
    TronWebProto.Account.prototype.getIsWitness = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 14, false)
      );
    };
    TronWebProto.Account.prototype.setIsWitness = function(value) {
      return jspb.Message.setProto3BooleanField(this, 14, value);
    };
    TronWebProto.Account.prototype.getIsCommittee = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 15, false)
      );
    };
    TronWebProto.Account.prototype.setIsCommittee = function(value) {
      return jspb.Message.setProto3BooleanField(this, 15, value);
    };
    TronWebProto.Account.prototype.getFrozenSupplyList = function() {
      return (
        /** @type{!Array<!TronWebProto.Account.Frozen>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.Account.Frozen, 16)
      );
    };
    TronWebProto.Account.prototype.setFrozenSupplyList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 16, value);
    };
    TronWebProto.Account.prototype.addFrozenSupply = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 16, opt_value, TronWebProto.Account.Frozen, opt_index);
    };
    TronWebProto.Account.prototype.clearFrozenSupplyList = function() {
      return this.setFrozenSupplyList([]);
    };
    TronWebProto.Account.prototype.getAssetIssuedName = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 17, "")
      );
    };
    TronWebProto.Account.prototype.getAssetIssuedName_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAssetIssuedName()
        )
      );
    };
    TronWebProto.Account.prototype.getAssetIssuedName_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAssetIssuedName()
        )
      );
    };
    TronWebProto.Account.prototype.setAssetIssuedName = function(value) {
      return jspb.Message.setProto3BytesField(this, 17, value);
    };
    TronWebProto.Account.prototype.getAssetIssuedId = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 57, "")
      );
    };
    TronWebProto.Account.prototype.getAssetIssuedId_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAssetIssuedId()
        )
      );
    };
    TronWebProto.Account.prototype.getAssetIssuedId_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAssetIssuedId()
        )
      );
    };
    TronWebProto.Account.prototype.setAssetIssuedId = function(value) {
      return jspb.Message.setProto3BytesField(this, 57, value);
    };
    TronWebProto.Account.prototype.getLatestAssetOperationTimeMap = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<string,number>} */
        jspb.Message.getMapField(
          this,
          18,
          opt_noLazyCreate,
          null
        )
      );
    };
    TronWebProto.Account.prototype.clearLatestAssetOperationTimeMap = function() {
      this.getLatestAssetOperationTimeMap().clear();
      return this;
    };
    TronWebProto.Account.prototype.getLatestAssetOperationTimev2Map = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<string,number>} */
        jspb.Message.getMapField(
          this,
          58,
          opt_noLazyCreate,
          null
        )
      );
    };
    TronWebProto.Account.prototype.clearLatestAssetOperationTimev2Map = function() {
      this.getLatestAssetOperationTimev2Map().clear();
      return this;
    };
    TronWebProto.Account.prototype.getFreeNetUsage = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 19, 0)
      );
    };
    TronWebProto.Account.prototype.setFreeNetUsage = function(value) {
      return jspb.Message.setProto3IntField(this, 19, value);
    };
    TronWebProto.Account.prototype.getFreeAssetNetUsageMap = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<string,number>} */
        jspb.Message.getMapField(
          this,
          20,
          opt_noLazyCreate,
          null
        )
      );
    };
    TronWebProto.Account.prototype.clearFreeAssetNetUsageMap = function() {
      this.getFreeAssetNetUsageMap().clear();
      return this;
    };
    TronWebProto.Account.prototype.getFreeAssetNetUsagev2Map = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<string,number>} */
        jspb.Message.getMapField(
          this,
          59,
          opt_noLazyCreate,
          null
        )
      );
    };
    TronWebProto.Account.prototype.clearFreeAssetNetUsagev2Map = function() {
      this.getFreeAssetNetUsagev2Map().clear();
      return this;
    };
    TronWebProto.Account.prototype.getLatestConsumeTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 21, 0)
      );
    };
    TronWebProto.Account.prototype.setLatestConsumeTime = function(value) {
      return jspb.Message.setProto3IntField(this, 21, value);
    };
    TronWebProto.Account.prototype.getLatestConsumeFreeTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 22, 0)
      );
    };
    TronWebProto.Account.prototype.setLatestConsumeFreeTime = function(value) {
      return jspb.Message.setProto3IntField(this, 22, value);
    };
    TronWebProto.Account.prototype.getAccountId = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 23, "")
      );
    };
    TronWebProto.Account.prototype.getAccountId_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAccountId()
        )
      );
    };
    TronWebProto.Account.prototype.getAccountId_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAccountId()
        )
      );
    };
    TronWebProto.Account.prototype.setAccountId = function(value) {
      return jspb.Message.setProto3BytesField(this, 23, value);
    };
    TronWebProto.Account.prototype.getAccountResource = function() {
      return (
        /** @type{?TronWebProto.Account.AccountResource} */
        jspb.Message.getWrapperField(this, TronWebProto.Account.AccountResource, 26)
      );
    };
    TronWebProto.Account.prototype.setAccountResource = function(value) {
      return jspb.Message.setWrapperField(this, 26, value);
    };
    TronWebProto.Account.prototype.clearAccountResource = function() {
      return this.setAccountResource(void 0);
    };
    TronWebProto.Account.prototype.hasAccountResource = function() {
      return jspb.Message.getField(this, 26) != null;
    };
    TronWebProto.Account.prototype.getCodehash = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 30, "")
      );
    };
    TronWebProto.Account.prototype.getCodehash_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getCodehash()
        )
      );
    };
    TronWebProto.Account.prototype.getCodehash_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getCodehash()
        )
      );
    };
    TronWebProto.Account.prototype.setCodehash = function(value) {
      return jspb.Message.setProto3BytesField(this, 30, value);
    };
    TronWebProto.Account.prototype.getOwnerPermission = function() {
      return (
        /** @type{?TronWebProto.Permission} */
        jspb.Message.getWrapperField(this, TronWebProto.Permission, 31)
      );
    };
    TronWebProto.Account.prototype.setOwnerPermission = function(value) {
      return jspb.Message.setWrapperField(this, 31, value);
    };
    TronWebProto.Account.prototype.clearOwnerPermission = function() {
      return this.setOwnerPermission(void 0);
    };
    TronWebProto.Account.prototype.hasOwnerPermission = function() {
      return jspb.Message.getField(this, 31) != null;
    };
    TronWebProto.Account.prototype.getWitnessPermission = function() {
      return (
        /** @type{?TronWebProto.Permission} */
        jspb.Message.getWrapperField(this, TronWebProto.Permission, 32)
      );
    };
    TronWebProto.Account.prototype.setWitnessPermission = function(value) {
      return jspb.Message.setWrapperField(this, 32, value);
    };
    TronWebProto.Account.prototype.clearWitnessPermission = function() {
      return this.setWitnessPermission(void 0);
    };
    TronWebProto.Account.prototype.hasWitnessPermission = function() {
      return jspb.Message.getField(this, 32) != null;
    };
    TronWebProto.Account.prototype.getActivePermissionList = function() {
      return (
        /** @type{!Array<!TronWebProto.Permission>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.Permission, 33)
      );
    };
    TronWebProto.Account.prototype.setActivePermissionList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 33, value);
    };
    TronWebProto.Account.prototype.addActivePermission = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 33, opt_value, TronWebProto.Permission, opt_index);
    };
    TronWebProto.Account.prototype.clearActivePermissionList = function() {
      return this.setActivePermissionList([]);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Key.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Key.toObject(opt_includeInstance, this);
      };
      TronWebProto.Key.toObject = function(includeInstance, msg) {
        var f2, obj = {
          address: msg.getAddress_asB64(),
          weight: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Key.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Key();
      return TronWebProto.Key.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Key.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setWeight(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Key.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Key.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Key.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getWeight();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
    };
    TronWebProto.Key.prototype.getAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.Key.prototype.getAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAddress()
        )
      );
    };
    TronWebProto.Key.prototype.getAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAddress()
        )
      );
    };
    TronWebProto.Key.prototype.setAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.Key.prototype.getWeight = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.Key.prototype.setWeight = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.DelegatedResource.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.DelegatedResource.toObject(opt_includeInstance, this);
      };
      TronWebProto.DelegatedResource.toObject = function(includeInstance, msg) {
        var f2, obj = {
          from: msg.getFrom_asB64(),
          to: msg.getTo_asB64(),
          frozenBalanceForBandwidth: jspb.Message.getFieldWithDefault(msg, 3, 0),
          frozenBalanceForEnergy: jspb.Message.getFieldWithDefault(msg, 4, 0),
          expireTimeForBandwidth: jspb.Message.getFieldWithDefault(msg, 5, 0),
          expireTimeForEnergy: jspb.Message.getFieldWithDefault(msg, 6, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.DelegatedResource.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.DelegatedResource();
      return TronWebProto.DelegatedResource.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.DelegatedResource.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setFrom(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setTo(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFrozenBalanceForBandwidth(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFrozenBalanceForEnergy(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExpireTimeForBandwidth(value);
            break;
          case 6:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExpireTimeForEnergy(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.DelegatedResource.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.DelegatedResource.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.DelegatedResource.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getFrom_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getTo_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getFrozenBalanceForBandwidth();
      if (f2 !== 0) {
        writer.writeInt64(
          3,
          f2
        );
      }
      f2 = message.getFrozenBalanceForEnergy();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
      f2 = message.getExpireTimeForBandwidth();
      if (f2 !== 0) {
        writer.writeInt64(
          5,
          f2
        );
      }
      f2 = message.getExpireTimeForEnergy();
      if (f2 !== 0) {
        writer.writeInt64(
          6,
          f2
        );
      }
    };
    TronWebProto.DelegatedResource.prototype.getFrom = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.DelegatedResource.prototype.getFrom_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getFrom()
        )
      );
    };
    TronWebProto.DelegatedResource.prototype.getFrom_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getFrom()
        )
      );
    };
    TronWebProto.DelegatedResource.prototype.setFrom = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.DelegatedResource.prototype.getTo = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.DelegatedResource.prototype.getTo_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getTo()
        )
      );
    };
    TronWebProto.DelegatedResource.prototype.getTo_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getTo()
        )
      );
    };
    TronWebProto.DelegatedResource.prototype.setTo = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.DelegatedResource.prototype.getFrozenBalanceForBandwidth = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.DelegatedResource.prototype.setFrozenBalanceForBandwidth = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.DelegatedResource.prototype.getFrozenBalanceForEnergy = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.DelegatedResource.prototype.setFrozenBalanceForEnergy = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    TronWebProto.DelegatedResource.prototype.getExpireTimeForBandwidth = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.DelegatedResource.prototype.setExpireTimeForBandwidth = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    TronWebProto.DelegatedResource.prototype.getExpireTimeForEnergy = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 6, 0)
      );
    };
    TronWebProto.DelegatedResource.prototype.setExpireTimeForEnergy = function(value) {
      return jspb.Message.setProto3IntField(this, 6, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.authority.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.authority.toObject(opt_includeInstance, this);
      };
      TronWebProto.authority.toObject = function(includeInstance, msg) {
        var f2, obj = {
          account: (f2 = msg.getAccount()) && TronWebProto.AccountId.toObject(includeInstance, f2),
          permissionName: msg.getPermissionName_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.authority.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.authority();
      return TronWebProto.authority.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.authority.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new TronWebProto.AccountId();
            reader.readMessage(value, TronWebProto.AccountId.deserializeBinaryFromReader);
            msg.setAccount(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setPermissionName(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.authority.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.authority.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.authority.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAccount();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          TronWebProto.AccountId.serializeBinaryToWriter
        );
      }
      f2 = message.getPermissionName_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
    };
    TronWebProto.authority.prototype.getAccount = function() {
      return (
        /** @type{?TronWebProto.AccountId} */
        jspb.Message.getWrapperField(this, TronWebProto.AccountId, 1)
      );
    };
    TronWebProto.authority.prototype.setAccount = function(value) {
      return jspb.Message.setWrapperField(this, 1, value);
    };
    TronWebProto.authority.prototype.clearAccount = function() {
      return this.setAccount(void 0);
    };
    TronWebProto.authority.prototype.hasAccount = function() {
      return jspb.Message.getField(this, 1) != null;
    };
    TronWebProto.authority.prototype.getPermissionName = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.authority.prototype.getPermissionName_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getPermissionName()
        )
      );
    };
    TronWebProto.authority.prototype.getPermissionName_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getPermissionName()
        )
      );
    };
    TronWebProto.authority.prototype.setPermissionName = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.Permission.repeatedFields_ = [7];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Permission.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Permission.toObject(opt_includeInstance, this);
      };
      TronWebProto.Permission.toObject = function(includeInstance, msg) {
        var f2, obj = {
          type: jspb.Message.getFieldWithDefault(msg, 1, 0),
          id: jspb.Message.getFieldWithDefault(msg, 2, 0),
          permissionName: jspb.Message.getFieldWithDefault(msg, 3, ""),
          threshold: jspb.Message.getFieldWithDefault(msg, 4, 0),
          parentId: jspb.Message.getFieldWithDefault(msg, 5, 0),
          operations: msg.getOperations_asB64(),
          keysList: jspb.Message.toObjectList(
            msg.getKeysList(),
            TronWebProto.Key.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Permission.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Permission();
      return TronWebProto.Permission.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Permission.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!TronWebProto.Permission.PermissionType} */
              reader.readEnum()
            );
            msg.setType(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt32()
            );
            msg.setId(value);
            break;
          case 3:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setPermissionName(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setThreshold(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt32()
            );
            msg.setParentId(value);
            break;
          case 6:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOperations(value);
            break;
          case 7:
            var value = new TronWebProto.Key();
            reader.readMessage(value, TronWebProto.Key.deserializeBinaryFromReader);
            msg.addKeys(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Permission.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Permission.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Permission.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getType();
      if (f2 !== 0) {
        writer.writeEnum(
          1,
          f2
        );
      }
      f2 = message.getId();
      if (f2 !== 0) {
        writer.writeInt32(
          2,
          f2
        );
      }
      f2 = message.getPermissionName();
      if (f2.length > 0) {
        writer.writeString(
          3,
          f2
        );
      }
      f2 = message.getThreshold();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
      f2 = message.getParentId();
      if (f2 !== 0) {
        writer.writeInt32(
          5,
          f2
        );
      }
      f2 = message.getOperations_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          6,
          f2
        );
      }
      f2 = message.getKeysList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          7,
          f2,
          TronWebProto.Key.serializeBinaryToWriter
        );
      }
    };
    TronWebProto.Permission.PermissionType = {
      OWNER: 0,
      WITNESS: 1,
      ACTIVE: 2
    };
    TronWebProto.Permission.prototype.getType = function() {
      return (
        /** @type {!TronWebProto.Permission.PermissionType} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.Permission.prototype.setType = function(value) {
      return jspb.Message.setProto3EnumField(this, 1, value);
    };
    TronWebProto.Permission.prototype.getId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.Permission.prototype.setId = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.Permission.prototype.getPermissionName = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.Permission.prototype.setPermissionName = function(value) {
      return jspb.Message.setProto3StringField(this, 3, value);
    };
    TronWebProto.Permission.prototype.getThreshold = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.Permission.prototype.setThreshold = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    TronWebProto.Permission.prototype.getParentId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.Permission.prototype.setParentId = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    TronWebProto.Permission.prototype.getOperations = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 6, "")
      );
    };
    TronWebProto.Permission.prototype.getOperations_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOperations()
        )
      );
    };
    TronWebProto.Permission.prototype.getOperations_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOperations()
        )
      );
    };
    TronWebProto.Permission.prototype.setOperations = function(value) {
      return jspb.Message.setProto3BytesField(this, 6, value);
    };
    TronWebProto.Permission.prototype.getKeysList = function() {
      return (
        /** @type{!Array<!TronWebProto.Key>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.Key, 7)
      );
    };
    TronWebProto.Permission.prototype.setKeysList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 7, value);
    };
    TronWebProto.Permission.prototype.addKeys = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, TronWebProto.Key, opt_index);
    };
    TronWebProto.Permission.prototype.clearKeysList = function() {
      return this.setKeysList([]);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Witness.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Witness.toObject(opt_includeInstance, this);
      };
      TronWebProto.Witness.toObject = function(includeInstance, msg) {
        var f2, obj = {
          address: msg.getAddress_asB64(),
          votecount: jspb.Message.getFieldWithDefault(msg, 2, 0),
          pubkey: msg.getPubkey_asB64(),
          url: jspb.Message.getFieldWithDefault(msg, 4, ""),
          totalproduced: jspb.Message.getFieldWithDefault(msg, 5, 0),
          totalmissed: jspb.Message.getFieldWithDefault(msg, 6, 0),
          latestblocknum: jspb.Message.getFieldWithDefault(msg, 7, 0),
          latestslotnum: jspb.Message.getFieldWithDefault(msg, 8, 0),
          isjobs: jspb.Message.getBooleanFieldWithDefault(msg, 9, false)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Witness.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Witness();
      return TronWebProto.Witness.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Witness.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setVotecount(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setPubkey(value);
            break;
          case 4:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setUrl(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setTotalproduced(value);
            break;
          case 6:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setTotalmissed(value);
            break;
          case 7:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setLatestblocknum(value);
            break;
          case 8:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setLatestslotnum(value);
            break;
          case 9:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setIsjobs(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Witness.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Witness.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Witness.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getVotecount();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
      f2 = message.getPubkey_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getUrl();
      if (f2.length > 0) {
        writer.writeString(
          4,
          f2
        );
      }
      f2 = message.getTotalproduced();
      if (f2 !== 0) {
        writer.writeInt64(
          5,
          f2
        );
      }
      f2 = message.getTotalmissed();
      if (f2 !== 0) {
        writer.writeInt64(
          6,
          f2
        );
      }
      f2 = message.getLatestblocknum();
      if (f2 !== 0) {
        writer.writeInt64(
          7,
          f2
        );
      }
      f2 = message.getLatestslotnum();
      if (f2 !== 0) {
        writer.writeInt64(
          8,
          f2
        );
      }
      f2 = message.getIsjobs();
      if (f2) {
        writer.writeBool(
          9,
          f2
        );
      }
    };
    TronWebProto.Witness.prototype.getAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.Witness.prototype.getAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAddress()
        )
      );
    };
    TronWebProto.Witness.prototype.getAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAddress()
        )
      );
    };
    TronWebProto.Witness.prototype.setAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.Witness.prototype.getVotecount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.Witness.prototype.setVotecount = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.Witness.prototype.getPubkey = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.Witness.prototype.getPubkey_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getPubkey()
        )
      );
    };
    TronWebProto.Witness.prototype.getPubkey_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getPubkey()
        )
      );
    };
    TronWebProto.Witness.prototype.setPubkey = function(value) {
      return jspb.Message.setProto3BytesField(this, 3, value);
    };
    TronWebProto.Witness.prototype.getUrl = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 4, "")
      );
    };
    TronWebProto.Witness.prototype.setUrl = function(value) {
      return jspb.Message.setProto3StringField(this, 4, value);
    };
    TronWebProto.Witness.prototype.getTotalproduced = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.Witness.prototype.setTotalproduced = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    TronWebProto.Witness.prototype.getTotalmissed = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 6, 0)
      );
    };
    TronWebProto.Witness.prototype.setTotalmissed = function(value) {
      return jspb.Message.setProto3IntField(this, 6, value);
    };
    TronWebProto.Witness.prototype.getLatestblocknum = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 7, 0)
      );
    };
    TronWebProto.Witness.prototype.setLatestblocknum = function(value) {
      return jspb.Message.setProto3IntField(this, 7, value);
    };
    TronWebProto.Witness.prototype.getLatestslotnum = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 8, 0)
      );
    };
    TronWebProto.Witness.prototype.setLatestslotnum = function(value) {
      return jspb.Message.setProto3IntField(this, 8, value);
    };
    TronWebProto.Witness.prototype.getIsjobs = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 9, false)
      );
    };
    TronWebProto.Witness.prototype.setIsjobs = function(value) {
      return jspb.Message.setProto3BooleanField(this, 9, value);
    };
    TronWebProto.Votes.repeatedFields_ = [2, 3];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Votes.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Votes.toObject(opt_includeInstance, this);
      };
      TronWebProto.Votes.toObject = function(includeInstance, msg) {
        var f2, obj = {
          address: msg.getAddress_asB64(),
          oldVotesList: jspb.Message.toObjectList(
            msg.getOldVotesList(),
            TronWebProto.Vote.toObject,
            includeInstance
          ),
          newVotesList: jspb.Message.toObjectList(
            msg.getNewVotesList(),
            TronWebProto.Vote.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Votes.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Votes();
      return TronWebProto.Votes.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Votes.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAddress(value);
            break;
          case 2:
            var value = new TronWebProto.Vote();
            reader.readMessage(value, TronWebProto.Vote.deserializeBinaryFromReader);
            msg.addOldVotes(value);
            break;
          case 3:
            var value = new TronWebProto.Vote();
            reader.readMessage(value, TronWebProto.Vote.deserializeBinaryFromReader);
            msg.addNewVotes(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Votes.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Votes.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Votes.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getOldVotesList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          TronWebProto.Vote.serializeBinaryToWriter
        );
      }
      f2 = message.getNewVotesList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          3,
          f2,
          TronWebProto.Vote.serializeBinaryToWriter
        );
      }
    };
    TronWebProto.Votes.prototype.getAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.Votes.prototype.getAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAddress()
        )
      );
    };
    TronWebProto.Votes.prototype.getAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAddress()
        )
      );
    };
    TronWebProto.Votes.prototype.setAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.Votes.prototype.getOldVotesList = function() {
      return (
        /** @type{!Array<!TronWebProto.Vote>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 2)
      );
    };
    TronWebProto.Votes.prototype.setOldVotesList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 2, value);
    };
    TronWebProto.Votes.prototype.addOldVotes = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, TronWebProto.Vote, opt_index);
    };
    TronWebProto.Votes.prototype.clearOldVotesList = function() {
      return this.setOldVotesList([]);
    };
    TronWebProto.Votes.prototype.getNewVotesList = function() {
      return (
        /** @type{!Array<!TronWebProto.Vote>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 3)
      );
    };
    TronWebProto.Votes.prototype.setNewVotesList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 3, value);
    };
    TronWebProto.Votes.prototype.addNewVotes = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, TronWebProto.Vote, opt_index);
    };
    TronWebProto.Votes.prototype.clearNewVotesList = function() {
      return this.setNewVotesList([]);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.MarketOrderDetail.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.MarketOrderDetail.toObject(opt_includeInstance, this);
      };
      TronWebProto.MarketOrderDetail.toObject = function(includeInstance, msg) {
        var f2, obj = {
          makerorderid: msg.getMakerorderid_asB64(),
          takerorderid: msg.getTakerorderid_asB64(),
          fillsellquantity: jspb.Message.getFieldWithDefault(msg, 3, 0),
          fillbuyquantity: jspb.Message.getFieldWithDefault(msg, 4, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.MarketOrderDetail.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.MarketOrderDetail();
      return TronWebProto.MarketOrderDetail.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.MarketOrderDetail.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setMakerorderid(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setTakerorderid(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFillsellquantity(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFillbuyquantity(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.MarketOrderDetail.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.MarketOrderDetail.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.MarketOrderDetail.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getMakerorderid_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getTakerorderid_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getFillsellquantity();
      if (f2 !== 0) {
        writer.writeInt64(
          3,
          f2
        );
      }
      f2 = message.getFillbuyquantity();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
    };
    TronWebProto.MarketOrderDetail.prototype.getMakerorderid = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.MarketOrderDetail.prototype.getMakerorderid_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getMakerorderid()
        )
      );
    };
    TronWebProto.MarketOrderDetail.prototype.getMakerorderid_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getMakerorderid()
        )
      );
    };
    TronWebProto.MarketOrderDetail.prototype.setMakerorderid = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.MarketOrderDetail.prototype.getTakerorderid = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.MarketOrderDetail.prototype.getTakerorderid_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getTakerorderid()
        )
      );
    };
    TronWebProto.MarketOrderDetail.prototype.getTakerorderid_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getTakerorderid()
        )
      );
    };
    TronWebProto.MarketOrderDetail.prototype.setTakerorderid = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.MarketOrderDetail.prototype.getFillsellquantity = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.MarketOrderDetail.prototype.setFillsellquantity = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.MarketOrderDetail.prototype.getFillbuyquantity = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.MarketOrderDetail.prototype.setFillbuyquantity = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    TronWebProto.Transaction.repeatedFields_ = [2, 5];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Transaction.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Transaction.toObject(opt_includeInstance, this);
      };
      TronWebProto.Transaction.toObject = function(includeInstance, msg) {
        var f2, obj = {
          rawData: (f2 = msg.getRawData()) && TronWebProto.Transaction.raw.toObject(includeInstance, f2),
          signatureList: msg.getSignatureList_asB64(),
          retList: jspb.Message.toObjectList(
            msg.getRetList(),
            TronWebProto.Transaction.Result.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Transaction.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Transaction();
      return TronWebProto.Transaction.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Transaction.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new TronWebProto.Transaction.raw();
            reader.readMessage(value, TronWebProto.Transaction.raw.deserializeBinaryFromReader);
            msg.setRawData(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.addSignature(value);
            break;
          case 5:
            var value = new TronWebProto.Transaction.Result();
            reader.readMessage(value, TronWebProto.Transaction.Result.deserializeBinaryFromReader);
            msg.addRet(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Transaction.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Transaction.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Transaction.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getRawData();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          TronWebProto.Transaction.raw.serializeBinaryToWriter
        );
      }
      f2 = message.getSignatureList_asU8();
      if (f2.length > 0) {
        writer.writeRepeatedBytes(
          2,
          f2
        );
      }
      f2 = message.getRetList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          5,
          f2,
          TronWebProto.Transaction.Result.serializeBinaryToWriter
        );
      }
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Transaction.Contract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Transaction.Contract.toObject(opt_includeInstance, this);
      };
      TronWebProto.Transaction.Contract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          type: jspb.Message.getFieldWithDefault(msg, 1, 0),
          parameter: (f2 = msg.getParameter()) && google_protobuf_any_pb2.Any.toObject(includeInstance, f2),
          provider: msg.getProvider_asB64(),
          contractname: msg.getContractname_asB64(),
          permissionId: jspb.Message.getFieldWithDefault(msg, 5, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Transaction.Contract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Transaction.Contract();
      return TronWebProto.Transaction.Contract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Transaction.Contract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!TronWebProto.Transaction.Contract.ContractType} */
              reader.readEnum()
            );
            msg.setType(value);
            break;
          case 2:
            var value = new google_protobuf_any_pb2.Any();
            reader.readMessage(value, google_protobuf_any_pb2.Any.deserializeBinaryFromReader);
            msg.setParameter(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setProvider(value);
            break;
          case 4:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setContractname(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt32()
            );
            msg.setPermissionId(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Transaction.Contract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Transaction.Contract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Transaction.Contract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getType();
      if (f2 !== 0) {
        writer.writeEnum(
          1,
          f2
        );
      }
      f2 = message.getParameter();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          google_protobuf_any_pb2.Any.serializeBinaryToWriter
        );
      }
      f2 = message.getProvider_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getContractname_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          4,
          f2
        );
      }
      f2 = message.getPermissionId();
      if (f2 !== 0) {
        writer.writeInt32(
          5,
          f2
        );
      }
    };
    TronWebProto.Transaction.Contract.ContractType = {
      ACCOUNTCREATECONTRACT: 0,
      TRANSFERCONTRACT: 1,
      TRANSFERASSETCONTRACT: 2,
      VOTEASSETCONTRACT: 3,
      VOTEWITNESSCONTRACT: 4,
      WITNESSCREATECONTRACT: 5,
      ASSETISSUECONTRACT: 6,
      WITNESSUPDATECONTRACT: 8,
      PARTICIPATEASSETISSUECONTRACT: 9,
      ACCOUNTUPDATECONTRACT: 10,
      FREEZEBALANCECONTRACT: 11,
      UNFREEZEBALANCECONTRACT: 12,
      WITHDRAWBALANCECONTRACT: 13,
      UNFREEZEASSETCONTRACT: 14,
      UPDATEASSETCONTRACT: 15,
      PROPOSALCREATECONTRACT: 16,
      PROPOSALAPPROVECONTRACT: 17,
      PROPOSALDELETECONTRACT: 18,
      SETACCOUNTIDCONTRACT: 19,
      CUSTOMCONTRACT: 20,
      CREATESMARTCONTRACT: 30,
      TRIGGERSMARTCONTRACT: 31,
      GETCONTRACT: 32,
      UPDATESETTINGCONTRACT: 33,
      EXCHANGECREATECONTRACT: 41,
      EXCHANGEINJECTCONTRACT: 42,
      EXCHANGEWITHDRAWCONTRACT: 43,
      EXCHANGETRANSACTIONCONTRACT: 44,
      UPDATEENERGYLIMITCONTRACT: 45,
      ACCOUNTPERMISSIONUPDATECONTRACT: 46,
      CLEARABICONTRACT: 48,
      UPDATEBROKERAGECONTRACT: 49,
      SHIELDEDTRANSFERCONTRACT: 51,
      MARKETSELLASSETCONTRACT: 52,
      MARKETCANCELORDERCONTRACT: 53,
      FREEZEBALANCEV2CONTRACT: 54,
      UNFREEZEBALANCEV2CONTRACT: 55,
      WITHDRAWEXPIREUNFREEZECONTRACT: 56,
      DELEGATERESOURCECONTRACT: 57,
      UNDELEGATERESOURCECONTRACT: 58,
      CANCELALLUNFREEZEV2CONTRACT: 59
    };
    TronWebProto.Transaction.Contract.prototype.getType = function() {
      return (
        /** @type {!TronWebProto.Transaction.Contract.ContractType} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.Transaction.Contract.prototype.setType = function(value) {
      return jspb.Message.setProto3EnumField(this, 1, value);
    };
    TronWebProto.Transaction.Contract.prototype.getParameter = function() {
      return (
        /** @type{?TronWebProto.Any} */
        jspb.Message.getWrapperField(this, google_protobuf_any_pb2.Any, 2)
      );
    };
    TronWebProto.Transaction.Contract.prototype.setParameter = function(value) {
      return jspb.Message.setWrapperField(this, 2, value);
    };
    TronWebProto.Transaction.Contract.prototype.clearParameter = function() {
      return this.setParameter(void 0);
    };
    TronWebProto.Transaction.Contract.prototype.hasParameter = function() {
      return jspb.Message.getField(this, 2) != null;
    };
    TronWebProto.Transaction.Contract.prototype.getProvider = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.Transaction.Contract.prototype.getProvider_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getProvider()
        )
      );
    };
    TronWebProto.Transaction.Contract.prototype.getProvider_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getProvider()
        )
      );
    };
    TronWebProto.Transaction.Contract.prototype.setProvider = function(value) {
      return jspb.Message.setProto3BytesField(this, 3, value);
    };
    TronWebProto.Transaction.Contract.prototype.getContractname = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 4, "")
      );
    };
    TronWebProto.Transaction.Contract.prototype.getContractname_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getContractname()
        )
      );
    };
    TronWebProto.Transaction.Contract.prototype.getContractname_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getContractname()
        )
      );
    };
    TronWebProto.Transaction.Contract.prototype.setContractname = function(value) {
      return jspb.Message.setProto3BytesField(this, 4, value);
    };
    TronWebProto.Transaction.Contract.prototype.getPermissionId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.Transaction.Contract.prototype.setPermissionId = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    TronWebProto.Transaction.Result.repeatedFields_ = [26];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Transaction.Result.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Transaction.Result.toObject(opt_includeInstance, this);
      };
      TronWebProto.Transaction.Result.toObject = function(includeInstance, msg) {
        var f2, obj = {
          fee: jspb.Message.getFieldWithDefault(msg, 1, 0),
          ret: jspb.Message.getFieldWithDefault(msg, 2, 0),
          contractret: jspb.Message.getFieldWithDefault(msg, 3, 0),
          assetissueid: jspb.Message.getFieldWithDefault(msg, 14, ""),
          withdrawAmount: jspb.Message.getFieldWithDefault(msg, 15, 0),
          unfreezeAmount: jspb.Message.getFieldWithDefault(msg, 16, 0),
          exchangeReceivedAmount: jspb.Message.getFieldWithDefault(msg, 18, 0),
          exchangeInjectAnotherAmount: jspb.Message.getFieldWithDefault(msg, 19, 0),
          exchangeWithdrawAnotherAmount: jspb.Message.getFieldWithDefault(msg, 20, 0),
          exchangeId: jspb.Message.getFieldWithDefault(msg, 21, 0),
          shieldedTransactionFee: jspb.Message.getFieldWithDefault(msg, 22, 0),
          orderid: msg.getOrderid_asB64(),
          orderdetailsList: jspb.Message.toObjectList(
            msg.getOrderdetailsList(),
            TronWebProto.MarketOrderDetail.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Transaction.Result.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Transaction.Result();
      return TronWebProto.Transaction.Result.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Transaction.Result.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFee(value);
            break;
          case 2:
            var value = (
              /** @type {!TronWebProto.Transaction.Result.code} */
              reader.readEnum()
            );
            msg.setRet(value);
            break;
          case 3:
            var value = (
              /** @type {!TronWebProto.Transaction.Result.contractResult} */
              reader.readEnum()
            );
            msg.setContractret(value);
            break;
          case 14:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setAssetissueid(value);
            break;
          case 15:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setWithdrawAmount(value);
            break;
          case 16:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setUnfreezeAmount(value);
            break;
          case 18:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExchangeReceivedAmount(value);
            break;
          case 19:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExchangeInjectAnotherAmount(value);
            break;
          case 20:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExchangeWithdrawAnotherAmount(value);
            break;
          case 21:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExchangeId(value);
            break;
          case 22:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setShieldedTransactionFee(value);
            break;
          case 25:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOrderid(value);
            break;
          case 26:
            var value = new TronWebProto.MarketOrderDetail();
            reader.readMessage(value, TronWebProto.MarketOrderDetail.deserializeBinaryFromReader);
            msg.addOrderdetails(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Transaction.Result.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Transaction.Result.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Transaction.Result.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getFee();
      if (f2 !== 0) {
        writer.writeInt64(
          1,
          f2
        );
      }
      f2 = message.getRet();
      if (f2 !== 0) {
        writer.writeEnum(
          2,
          f2
        );
      }
      f2 = message.getContractret();
      if (f2 !== 0) {
        writer.writeEnum(
          3,
          f2
        );
      }
      f2 = message.getAssetissueid();
      if (f2.length > 0) {
        writer.writeString(
          14,
          f2
        );
      }
      f2 = message.getWithdrawAmount();
      if (f2 !== 0) {
        writer.writeInt64(
          15,
          f2
        );
      }
      f2 = message.getUnfreezeAmount();
      if (f2 !== 0) {
        writer.writeInt64(
          16,
          f2
        );
      }
      f2 = message.getExchangeReceivedAmount();
      if (f2 !== 0) {
        writer.writeInt64(
          18,
          f2
        );
      }
      f2 = message.getExchangeInjectAnotherAmount();
      if (f2 !== 0) {
        writer.writeInt64(
          19,
          f2
        );
      }
      f2 = message.getExchangeWithdrawAnotherAmount();
      if (f2 !== 0) {
        writer.writeInt64(
          20,
          f2
        );
      }
      f2 = message.getExchangeId();
      if (f2 !== 0) {
        writer.writeInt64(
          21,
          f2
        );
      }
      f2 = message.getShieldedTransactionFee();
      if (f2 !== 0) {
        writer.writeInt64(
          22,
          f2
        );
      }
      f2 = message.getOrderid_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          25,
          f2
        );
      }
      f2 = message.getOrderdetailsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          26,
          f2,
          TronWebProto.MarketOrderDetail.serializeBinaryToWriter
        );
      }
    };
    TronWebProto.Transaction.Result.code = {
      SUCESS: 0,
      FAILED: 1
    };
    TronWebProto.Transaction.Result.contractResult = {
      DEFAULT: 0,
      SUCCESS: 1,
      REVERT: 2,
      BAD_JUMP_DESTINATION: 3,
      OUT_OF_MEMORY: 4,
      PRECOMPILED_CONTRACT: 5,
      STACK_TOO_SMALL: 6,
      STACK_TOO_LARGE: 7,
      ILLEGAL_OPERATION: 8,
      STACK_OVERFLOW: 9,
      OUT_OF_ENERGY: 10,
      OUT_OF_TIME: 11,
      JVM_STACK_OVER_FLOW: 12,
      UNKNOWN: 13,
      TRANSFER_FAILED: 14,
      INVALID_CODE: 15
    };
    TronWebProto.Transaction.Result.prototype.getFee = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.Transaction.Result.prototype.setFee = function(value) {
      return jspb.Message.setProto3IntField(this, 1, value);
    };
    TronWebProto.Transaction.Result.prototype.getRet = function() {
      return (
        /** @type {!TronWebProto.Transaction.Result.code} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.Transaction.Result.prototype.setRet = function(value) {
      return jspb.Message.setProto3EnumField(this, 2, value);
    };
    TronWebProto.Transaction.Result.prototype.getContractret = function() {
      return (
        /** @type {!TronWebProto.Transaction.Result.contractResult} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.Transaction.Result.prototype.setContractret = function(value) {
      return jspb.Message.setProto3EnumField(this, 3, value);
    };
    TronWebProto.Transaction.Result.prototype.getAssetissueid = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 14, "")
      );
    };
    TronWebProto.Transaction.Result.prototype.setAssetissueid = function(value) {
      return jspb.Message.setProto3StringField(this, 14, value);
    };
    TronWebProto.Transaction.Result.prototype.getWithdrawAmount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 15, 0)
      );
    };
    TronWebProto.Transaction.Result.prototype.setWithdrawAmount = function(value) {
      return jspb.Message.setProto3IntField(this, 15, value);
    };
    TronWebProto.Transaction.Result.prototype.getUnfreezeAmount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 16, 0)
      );
    };
    TronWebProto.Transaction.Result.prototype.setUnfreezeAmount = function(value) {
      return jspb.Message.setProto3IntField(this, 16, value);
    };
    TronWebProto.Transaction.Result.prototype.getExchangeReceivedAmount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 18, 0)
      );
    };
    TronWebProto.Transaction.Result.prototype.setExchangeReceivedAmount = function(value) {
      return jspb.Message.setProto3IntField(this, 18, value);
    };
    TronWebProto.Transaction.Result.prototype.getExchangeInjectAnotherAmount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 19, 0)
      );
    };
    TronWebProto.Transaction.Result.prototype.setExchangeInjectAnotherAmount = function(value) {
      return jspb.Message.setProto3IntField(this, 19, value);
    };
    TronWebProto.Transaction.Result.prototype.getExchangeWithdrawAnotherAmount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 20, 0)
      );
    };
    TronWebProto.Transaction.Result.prototype.setExchangeWithdrawAnotherAmount = function(value) {
      return jspb.Message.setProto3IntField(this, 20, value);
    };
    TronWebProto.Transaction.Result.prototype.getExchangeId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 21, 0)
      );
    };
    TronWebProto.Transaction.Result.prototype.setExchangeId = function(value) {
      return jspb.Message.setProto3IntField(this, 21, value);
    };
    TronWebProto.Transaction.Result.prototype.getShieldedTransactionFee = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 22, 0)
      );
    };
    TronWebProto.Transaction.Result.prototype.setShieldedTransactionFee = function(value) {
      return jspb.Message.setProto3IntField(this, 22, value);
    };
    TronWebProto.Transaction.Result.prototype.getOrderid = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 25, "")
      );
    };
    TronWebProto.Transaction.Result.prototype.getOrderid_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOrderid()
        )
      );
    };
    TronWebProto.Transaction.Result.prototype.getOrderid_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOrderid()
        )
      );
    };
    TronWebProto.Transaction.Result.prototype.setOrderid = function(value) {
      return jspb.Message.setProto3BytesField(this, 25, value);
    };
    TronWebProto.Transaction.Result.prototype.getOrderdetailsList = function() {
      return (
        /** @type{!Array<!TronWebProto.MarketOrderDetail>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.MarketOrderDetail, 26)
      );
    };
    TronWebProto.Transaction.Result.prototype.setOrderdetailsList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 26, value);
    };
    TronWebProto.Transaction.Result.prototype.addOrderdetails = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 26, opt_value, TronWebProto.MarketOrderDetail, opt_index);
    };
    TronWebProto.Transaction.Result.prototype.clearOrderdetailsList = function() {
      return this.setOrderdetailsList([]);
    };
    TronWebProto.Transaction.raw.repeatedFields_ = [9, 11];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.Transaction.raw.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.Transaction.raw.toObject(opt_includeInstance, this);
      };
      TronWebProto.Transaction.raw.toObject = function(includeInstance, msg) {
        var f2, obj = {
          refBlockBytes: msg.getRefBlockBytes_asB64(),
          refBlockNum: jspb.Message.getFieldWithDefault(msg, 3, 0),
          refBlockHash: msg.getRefBlockHash_asB64(),
          expiration: jspb.Message.getFieldWithDefault(msg, 8, 0),
          authsList: jspb.Message.toObjectList(
            msg.getAuthsList(),
            TronWebProto.authority.toObject,
            includeInstance
          ),
          data: msg.getData_asB64(),
          contractList: jspb.Message.toObjectList(
            msg.getContractList(),
            TronWebProto.Transaction.Contract.toObject,
            includeInstance
          ),
          scripts: msg.getScripts_asB64(),
          timestamp: jspb.Message.getFieldWithDefault(msg, 14, 0),
          feeLimit: jspb.Message.getFieldWithDefault(msg, 18, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.Transaction.raw.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.Transaction.raw();
      return TronWebProto.Transaction.raw.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.Transaction.raw.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setRefBlockBytes(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setRefBlockNum(value);
            break;
          case 4:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setRefBlockHash(value);
            break;
          case 8:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExpiration(value);
            break;
          case 9:
            var value = new TronWebProto.authority();
            reader.readMessage(value, TronWebProto.authority.deserializeBinaryFromReader);
            msg.addAuths(value);
            break;
          case 10:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setData(value);
            break;
          case 11:
            var value = new TronWebProto.Transaction.Contract();
            reader.readMessage(value, TronWebProto.Transaction.Contract.deserializeBinaryFromReader);
            msg.addContract(value);
            break;
          case 12:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setScripts(value);
            break;
          case 14:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setTimestamp(value);
            break;
          case 18:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFeeLimit(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.Transaction.raw.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.Transaction.raw.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.Transaction.raw.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getRefBlockBytes_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getRefBlockNum();
      if (f2 !== 0) {
        writer.writeInt64(
          3,
          f2
        );
      }
      f2 = message.getRefBlockHash_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          4,
          f2
        );
      }
      f2 = message.getExpiration();
      if (f2 !== 0) {
        writer.writeInt64(
          8,
          f2
        );
      }
      f2 = message.getAuthsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          9,
          f2,
          TronWebProto.authority.serializeBinaryToWriter
        );
      }
      f2 = message.getData_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          10,
          f2
        );
      }
      f2 = message.getContractList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          11,
          f2,
          TronWebProto.Transaction.Contract.serializeBinaryToWriter
        );
      }
      f2 = message.getScripts_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          12,
          f2
        );
      }
      f2 = message.getTimestamp();
      if (f2 !== 0) {
        writer.writeInt64(
          14,
          f2
        );
      }
      f2 = message.getFeeLimit();
      if (f2 !== 0) {
        writer.writeInt64(
          18,
          f2
        );
      }
    };
    TronWebProto.Transaction.raw.prototype.getRefBlockBytes = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.Transaction.raw.prototype.getRefBlockBytes_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getRefBlockBytes()
        )
      );
    };
    TronWebProto.Transaction.raw.prototype.getRefBlockBytes_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getRefBlockBytes()
        )
      );
    };
    TronWebProto.Transaction.raw.prototype.setRefBlockBytes = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.Transaction.raw.prototype.getRefBlockNum = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.Transaction.raw.prototype.setRefBlockNum = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.Transaction.raw.prototype.getRefBlockHash = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 4, "")
      );
    };
    TronWebProto.Transaction.raw.prototype.getRefBlockHash_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getRefBlockHash()
        )
      );
    };
    TronWebProto.Transaction.raw.prototype.getRefBlockHash_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getRefBlockHash()
        )
      );
    };
    TronWebProto.Transaction.raw.prototype.setRefBlockHash = function(value) {
      return jspb.Message.setProto3BytesField(this, 4, value);
    };
    TronWebProto.Transaction.raw.prototype.getExpiration = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 8, 0)
      );
    };
    TronWebProto.Transaction.raw.prototype.setExpiration = function(value) {
      return jspb.Message.setProto3IntField(this, 8, value);
    };
    TronWebProto.Transaction.raw.prototype.getAuthsList = function() {
      return (
        /** @type{!Array<!TronWebProto.authority>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.authority, 9)
      );
    };
    TronWebProto.Transaction.raw.prototype.setAuthsList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 9, value);
    };
    TronWebProto.Transaction.raw.prototype.addAuths = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 9, opt_value, TronWebProto.authority, opt_index);
    };
    TronWebProto.Transaction.raw.prototype.clearAuthsList = function() {
      return this.setAuthsList([]);
    };
    TronWebProto.Transaction.raw.prototype.getData = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 10, "")
      );
    };
    TronWebProto.Transaction.raw.prototype.getData_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getData()
        )
      );
    };
    TronWebProto.Transaction.raw.prototype.getData_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getData()
        )
      );
    };
    TronWebProto.Transaction.raw.prototype.setData = function(value) {
      return jspb.Message.setProto3BytesField(this, 10, value);
    };
    TronWebProto.Transaction.raw.prototype.getContractList = function() {
      return (
        /** @type{!Array<!TronWebProto.Transaction.Contract>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.Transaction.Contract, 11)
      );
    };
    TronWebProto.Transaction.raw.prototype.setContractList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 11, value);
    };
    TronWebProto.Transaction.raw.prototype.addContract = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 11, opt_value, TronWebProto.Transaction.Contract, opt_index);
    };
    TronWebProto.Transaction.raw.prototype.clearContractList = function() {
      return this.setContractList([]);
    };
    TronWebProto.Transaction.raw.prototype.getScripts = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 12, "")
      );
    };
    TronWebProto.Transaction.raw.prototype.getScripts_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getScripts()
        )
      );
    };
    TronWebProto.Transaction.raw.prototype.getScripts_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getScripts()
        )
      );
    };
    TronWebProto.Transaction.raw.prototype.setScripts = function(value) {
      return jspb.Message.setProto3BytesField(this, 12, value);
    };
    TronWebProto.Transaction.raw.prototype.getTimestamp = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 14, 0)
      );
    };
    TronWebProto.Transaction.raw.prototype.setTimestamp = function(value) {
      return jspb.Message.setProto3IntField(this, 14, value);
    };
    TronWebProto.Transaction.raw.prototype.getFeeLimit = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 18, 0)
      );
    };
    TronWebProto.Transaction.raw.prototype.setFeeLimit = function(value) {
      return jspb.Message.setProto3IntField(this, 18, value);
    };
    TronWebProto.Transaction.prototype.getRawData = function() {
      return (
        /** @type{?TronWebProto.Transaction.raw} */
        jspb.Message.getWrapperField(this, TronWebProto.Transaction.raw, 1)
      );
    };
    TronWebProto.Transaction.prototype.setRawData = function(value) {
      return jspb.Message.setWrapperField(this, 1, value);
    };
    TronWebProto.Transaction.prototype.clearRawData = function() {
      return this.setRawData(void 0);
    };
    TronWebProto.Transaction.prototype.hasRawData = function() {
      return jspb.Message.getField(this, 1) != null;
    };
    TronWebProto.Transaction.prototype.getSignatureList = function() {
      return (
        /** @type {!(Array<!Uint8Array>|Array<string>)} */
        jspb.Message.getRepeatedField(this, 2)
      );
    };
    TronWebProto.Transaction.prototype.getSignatureList_asB64 = function() {
      return (
        /** @type {!Array<string>} */
        jspb.Message.bytesListAsB64(
          this.getSignatureList()
        )
      );
    };
    TronWebProto.Transaction.prototype.getSignatureList_asU8 = function() {
      return (
        /** @type {!Array<!Uint8Array>} */
        jspb.Message.bytesListAsU8(
          this.getSignatureList()
        )
      );
    };
    TronWebProto.Transaction.prototype.setSignatureList = function(value) {
      return jspb.Message.setField(this, 2, value || []);
    };
    TronWebProto.Transaction.prototype.addSignature = function(value, opt_index) {
      return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
    };
    TronWebProto.Transaction.prototype.clearSignatureList = function() {
      return this.setSignatureList([]);
    };
    TronWebProto.Transaction.prototype.getRetList = function() {
      return (
        /** @type{!Array<!TronWebProto.Transaction.Result>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.Transaction.Result, 5)
      );
    };
    TronWebProto.Transaction.prototype.setRetList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 5, value);
    };
    TronWebProto.Transaction.prototype.addRet = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, TronWebProto.Transaction.Result, opt_index);
    };
    TronWebProto.Transaction.prototype.clearRetList = function() {
      return this.setRetList([]);
    };
    TronWebProto.AccountType = {
      NORMAL: 0,
      ASSETISSUE: 1,
      CONTRACT: 2
    };
    goog.object.extend(exports, TronWebProto);
  }
});

// node_modules/tronweb/lib/esm/protocol/core/contract/common_pb.cjs
var require_common_pb = __commonJS({
  "node_modules/tronweb/lib/esm/protocol/core/contract/common_pb.cjs"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    goog.exportSymbol("TronWebProto.ResourceCode", null, global2);
    TronWebProto.ResourceCode = {
      BANDWIDTH: 0,
      ENERGY: 1,
      TRON_POWER: 2
    };
    goog.object.extend(exports, TronWebProto);
  }
});

// node_modules/tronweb/lib/esm/protocol/core/contract/balance_contract_pb.cjs
var require_balance_contract_pb = __commonJS({
  "node_modules/tronweb/lib/esm/protocol/core/contract/balance_contract_pb.cjs"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    var core_contract_common_pb = require_common_pb();
    goog.object.extend(proto, core_contract_common_pb);
    goog.exportSymbol("TronWebProto.AccountBalanceRequest", null, global2);
    goog.exportSymbol("TronWebProto.AccountBalanceResponse", null, global2);
    goog.exportSymbol("TronWebProto.AccountIdentifier", null, global2);
    goog.exportSymbol("TronWebProto.AccountTrace", null, global2);
    goog.exportSymbol("TronWebProto.BlockBalanceTrace", null, global2);
    goog.exportSymbol("TronWebProto.BlockBalanceTrace.BlockIdentifier", null, global2);
    goog.exportSymbol("TronWebProto.CancelAllUnfreezeV2Contract", null, global2);
    goog.exportSymbol("TronWebProto.DelegateResourceContract", null, global2);
    goog.exportSymbol("TronWebProto.FreezeBalanceContract", null, global2);
    goog.exportSymbol("TronWebProto.FreezeBalanceV2Contract", null, global2);
    goog.exportSymbol("TronWebProto.TransactionBalanceTrace", null, global2);
    goog.exportSymbol("TronWebProto.TransactionBalanceTrace.Operation", null, global2);
    goog.exportSymbol("TronWebProto.TransferContract", null, global2);
    goog.exportSymbol("TronWebProto.UnDelegateResourceContract", null, global2);
    goog.exportSymbol("TronWebProto.UnfreezeBalanceContract", null, global2);
    goog.exportSymbol("TronWebProto.UnfreezeBalanceV2Contract", null, global2);
    goog.exportSymbol("TronWebProto.WithdrawBalanceContract", null, global2);
    goog.exportSymbol("TronWebProto.WithdrawExpireUnfreezeContract", null, global2);
    TronWebProto.FreezeBalanceContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.FreezeBalanceContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.FreezeBalanceContract.displayName = "TronWebProto.FreezeBalanceContract";
    }
    TronWebProto.UnfreezeBalanceContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.UnfreezeBalanceContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.UnfreezeBalanceContract.displayName = "TronWebProto.UnfreezeBalanceContract";
    }
    TronWebProto.WithdrawBalanceContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.WithdrawBalanceContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.WithdrawBalanceContract.displayName = "TronWebProto.WithdrawBalanceContract";
    }
    TronWebProto.TransferContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.TransferContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.TransferContract.displayName = "TronWebProto.TransferContract";
    }
    TronWebProto.TransactionBalanceTrace = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.TransactionBalanceTrace.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.TransactionBalanceTrace, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.TransactionBalanceTrace.displayName = "TronWebProto.TransactionBalanceTrace";
    }
    TronWebProto.TransactionBalanceTrace.Operation = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.TransactionBalanceTrace.Operation, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.TransactionBalanceTrace.Operation.displayName = "TronWebProto.TransactionBalanceTrace.Operation";
    }
    TronWebProto.BlockBalanceTrace = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.BlockBalanceTrace.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.BlockBalanceTrace, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.BlockBalanceTrace.displayName = "TronWebProto.BlockBalanceTrace";
    }
    TronWebProto.BlockBalanceTrace.BlockIdentifier = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.BlockBalanceTrace.BlockIdentifier, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.BlockBalanceTrace.BlockIdentifier.displayName = "TronWebProto.BlockBalanceTrace.BlockIdentifier";
    }
    TronWebProto.AccountTrace = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.AccountTrace, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.AccountTrace.displayName = "TronWebProto.AccountTrace";
    }
    TronWebProto.AccountIdentifier = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.AccountIdentifier, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.AccountIdentifier.displayName = "TronWebProto.AccountIdentifier";
    }
    TronWebProto.AccountBalanceRequest = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.AccountBalanceRequest, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.AccountBalanceRequest.displayName = "TronWebProto.AccountBalanceRequest";
    }
    TronWebProto.AccountBalanceResponse = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.AccountBalanceResponse, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.AccountBalanceResponse.displayName = "TronWebProto.AccountBalanceResponse";
    }
    TronWebProto.FreezeBalanceV2Contract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.FreezeBalanceV2Contract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.FreezeBalanceV2Contract.displayName = "TronWebProto.FreezeBalanceV2Contract";
    }
    TronWebProto.UnfreezeBalanceV2Contract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.UnfreezeBalanceV2Contract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.UnfreezeBalanceV2Contract.displayName = "TronWebProto.UnfreezeBalanceV2Contract";
    }
    TronWebProto.WithdrawExpireUnfreezeContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.WithdrawExpireUnfreezeContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.WithdrawExpireUnfreezeContract.displayName = "TronWebProto.WithdrawExpireUnfreezeContract";
    }
    TronWebProto.DelegateResourceContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.DelegateResourceContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.DelegateResourceContract.displayName = "TronWebProto.DelegateResourceContract";
    }
    TronWebProto.UnDelegateResourceContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.UnDelegateResourceContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.UnDelegateResourceContract.displayName = "TronWebProto.UnDelegateResourceContract";
    }
    TronWebProto.CancelAllUnfreezeV2Contract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.CancelAllUnfreezeV2Contract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.CancelAllUnfreezeV2Contract.displayName = "TronWebProto.CancelAllUnfreezeV2Contract";
    }
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.FreezeBalanceContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.FreezeBalanceContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.FreezeBalanceContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          frozenBalance: jspb.Message.getFieldWithDefault(msg, 2, 0),
          frozenDuration: jspb.Message.getFieldWithDefault(msg, 3, 0),
          resource: jspb.Message.getFieldWithDefault(msg, 10, 0),
          receiverAddress: msg.getReceiverAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.FreezeBalanceContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.FreezeBalanceContract();
      return TronWebProto.FreezeBalanceContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.FreezeBalanceContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFrozenBalance(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFrozenDuration(value);
            break;
          case 10:
            var value = (
              /** @type {!TronWebProto.ResourceCode} */
              reader.readEnum()
            );
            msg.setResource(value);
            break;
          case 15:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setReceiverAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.FreezeBalanceContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.FreezeBalanceContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.FreezeBalanceContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getFrozenBalance();
      if (f2 !== 0) {
        writer.writeInt64(2, f2);
      }
      f2 = message.getFrozenDuration();
      if (f2 !== 0) {
        writer.writeInt64(3, f2);
      }
      f2 = message.getResource();
      if (f2 !== 0) {
        writer.writeEnum(10, f2);
      }
      f2 = message.getReceiverAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(15, f2);
      }
    };
    TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.FreezeBalanceContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.FreezeBalanceContract.prototype.getFrozenBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.FreezeBalanceContract.prototype.setFrozenBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.FreezeBalanceContract.prototype.getFrozenDuration = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.FreezeBalanceContract.prototype.setFrozenDuration = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.FreezeBalanceContract.prototype.getResource = function() {
      return (
        /** @type {!TronWebProto.ResourceCode} */
        jspb.Message.getFieldWithDefault(this, 10, 0)
      );
    };
    TronWebProto.FreezeBalanceContract.prototype.setResource = function(value) {
      return jspb.Message.setProto3EnumField(this, 10, value);
    };
    TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 15, "")
      );
    };
    TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getReceiverAddress())
      );
    };
    TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getReceiverAddress())
      );
    };
    TronWebProto.FreezeBalanceContract.prototype.setReceiverAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 15, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.UnfreezeBalanceContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.UnfreezeBalanceContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.UnfreezeBalanceContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          resource: jspb.Message.getFieldWithDefault(msg, 10, 0),
          receiverAddress: msg.getReceiverAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.UnfreezeBalanceContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.UnfreezeBalanceContract();
      return TronWebProto.UnfreezeBalanceContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.UnfreezeBalanceContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 10:
            var value = (
              /** @type {!TronWebProto.ResourceCode} */
              reader.readEnum()
            );
            msg.setResource(value);
            break;
          case 15:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setReceiverAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.UnfreezeBalanceContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.UnfreezeBalanceContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.UnfreezeBalanceContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getResource();
      if (f2 !== 0) {
        writer.writeEnum(10, f2);
      }
      f2 = message.getReceiverAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(15, f2);
      }
    };
    TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.UnfreezeBalanceContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.UnfreezeBalanceContract.prototype.getResource = function() {
      return (
        /** @type {!TronWebProto.ResourceCode} */
        jspb.Message.getFieldWithDefault(this, 10, 0)
      );
    };
    TronWebProto.UnfreezeBalanceContract.prototype.setResource = function(value) {
      return jspb.Message.setProto3EnumField(this, 10, value);
    };
    TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 15, "")
      );
    };
    TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getReceiverAddress())
      );
    };
    TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getReceiverAddress())
      );
    };
    TronWebProto.UnfreezeBalanceContract.prototype.setReceiverAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 15, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.WithdrawBalanceContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.WithdrawBalanceContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.WithdrawBalanceContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.WithdrawBalanceContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.WithdrawBalanceContract();
      return TronWebProto.WithdrawBalanceContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.WithdrawBalanceContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.WithdrawBalanceContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.WithdrawBalanceContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.WithdrawBalanceContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
    };
    TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.WithdrawBalanceContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.TransferContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.TransferContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.TransferContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          toAddress: msg.getToAddress_asB64(),
          amount: jspb.Message.getFieldWithDefault(msg, 3, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.TransferContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.TransferContract();
      return TronWebProto.TransferContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.TransferContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setToAddress(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setAmount(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.TransferContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.TransferContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.TransferContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getToAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
      f2 = message.getAmount();
      if (f2 !== 0) {
        writer.writeInt64(3, f2);
      }
    };
    TronWebProto.TransferContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.TransferContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.TransferContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.TransferContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.TransferContract.prototype.getToAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.TransferContract.prototype.getToAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getToAddress())
      );
    };
    TronWebProto.TransferContract.prototype.getToAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getToAddress())
      );
    };
    TronWebProto.TransferContract.prototype.setToAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.TransferContract.prototype.getAmount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.TransferContract.prototype.setAmount = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.TransactionBalanceTrace.repeatedFields_ = [2];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.TransactionBalanceTrace.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.TransactionBalanceTrace.toObject(opt_includeInstance, this);
      };
      TronWebProto.TransactionBalanceTrace.toObject = function(includeInstance, msg) {
        var f2, obj = {
          transactionIdentifier: msg.getTransactionIdentifier_asB64(),
          operationList: jspb.Message.toObjectList(
            msg.getOperationList(),
            TronWebProto.TransactionBalanceTrace.Operation.toObject,
            includeInstance
          ),
          type: jspb.Message.getFieldWithDefault(msg, 3, ""),
          status: jspb.Message.getFieldWithDefault(msg, 4, "")
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.TransactionBalanceTrace.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.TransactionBalanceTrace();
      return TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setTransactionIdentifier(value);
            break;
          case 2:
            var value = new TronWebProto.TransactionBalanceTrace.Operation();
            reader.readMessage(value, TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader);
            msg.addOperation(value);
            break;
          case 3:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setType(value);
            break;
          case 4:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setStatus(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.TransactionBalanceTrace.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTransactionIdentifier_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getOperationList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(2, f2, TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter);
      }
      f2 = message.getType();
      if (f2.length > 0) {
        writer.writeString(3, f2);
      }
      f2 = message.getStatus();
      if (f2.length > 0) {
        writer.writeString(4, f2);
      }
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.TransactionBalanceTrace.Operation.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.TransactionBalanceTrace.Operation.toObject(opt_includeInstance, this);
      };
      TronWebProto.TransactionBalanceTrace.Operation.toObject = function(includeInstance, msg) {
        var f2, obj = {
          operationIdentifier: jspb.Message.getFieldWithDefault(msg, 1, 0),
          address: msg.getAddress_asB64(),
          amount: jspb.Message.getFieldWithDefault(msg, 3, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.TransactionBalanceTrace.Operation.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.TransactionBalanceTrace.Operation();
      return TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setOperationIdentifier(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAddress(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setAmount(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.TransactionBalanceTrace.Operation.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOperationIdentifier();
      if (f2 !== 0) {
        writer.writeInt64(1, f2);
      }
      f2 = message.getAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
      f2 = message.getAmount();
      if (f2 !== 0) {
        writer.writeInt64(3, f2);
      }
    };
    TronWebProto.TransactionBalanceTrace.Operation.prototype.getOperationIdentifier = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.TransactionBalanceTrace.Operation.prototype.setOperationIdentifier = function(value) {
      return jspb.Message.setProto3IntField(this, 1, value);
    };
    TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getAddress())
      );
    };
    TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getAddress())
      );
    };
    TronWebProto.TransactionBalanceTrace.Operation.prototype.setAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.TransactionBalanceTrace.Operation.prototype.getAmount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.TransactionBalanceTrace.Operation.prototype.setAmount = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getTransactionIdentifier())
      );
    };
    TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getTransactionIdentifier())
      );
    };
    TronWebProto.TransactionBalanceTrace.prototype.setTransactionIdentifier = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.TransactionBalanceTrace.prototype.getOperationList = function() {
      return (
        /** @type{!Array<!TronWebProto.TransactionBalanceTrace.Operation>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.TransactionBalanceTrace.Operation, 2)
      );
    };
    TronWebProto.TransactionBalanceTrace.prototype.setOperationList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 2, value);
    };
    TronWebProto.TransactionBalanceTrace.prototype.addOperation = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, TronWebProto.TransactionBalanceTrace.Operation, opt_index);
    };
    TronWebProto.TransactionBalanceTrace.prototype.clearOperationList = function() {
      return this.setOperationList([]);
    };
    TronWebProto.TransactionBalanceTrace.prototype.getType = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.TransactionBalanceTrace.prototype.setType = function(value) {
      return jspb.Message.setProto3StringField(this, 3, value);
    };
    TronWebProto.TransactionBalanceTrace.prototype.getStatus = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 4, "")
      );
    };
    TronWebProto.TransactionBalanceTrace.prototype.setStatus = function(value) {
      return jspb.Message.setProto3StringField(this, 4, value);
    };
    TronWebProto.BlockBalanceTrace.repeatedFields_ = [3];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.BlockBalanceTrace.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.BlockBalanceTrace.toObject(opt_includeInstance, this);
      };
      TronWebProto.BlockBalanceTrace.toObject = function(includeInstance, msg) {
        var f2, obj = {
          blockIdentifier: (f2 = msg.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(includeInstance, f2),
          timestamp: jspb.Message.getFieldWithDefault(msg, 2, 0),
          transactionBalanceTraceList: jspb.Message.toObjectList(
            msg.getTransactionBalanceTraceList(),
            TronWebProto.TransactionBalanceTrace.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.BlockBalanceTrace.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.BlockBalanceTrace();
      return TronWebProto.BlockBalanceTrace.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.BlockBalanceTrace.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new TronWebProto.BlockBalanceTrace.BlockIdentifier();
            reader.readMessage(value, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader);
            msg.setBlockIdentifier(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setTimestamp(value);
            break;
          case 3:
            var value = new TronWebProto.TransactionBalanceTrace();
            reader.readMessage(value, TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader);
            msg.addTransactionBalanceTrace(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.BlockBalanceTrace.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.BlockBalanceTrace.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.BlockBalanceTrace.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getBlockIdentifier();
      if (f2 != null) {
        writer.writeMessage(1, f2, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter);
      }
      f2 = message.getTimestamp();
      if (f2 !== 0) {
        writer.writeInt64(2, f2);
      }
      f2 = message.getTransactionBalanceTraceList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(3, f2, TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter);
      }
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(opt_includeInstance, this);
      };
      TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject = function(includeInstance, msg) {
        var f2, obj = {
          hash: msg.getHash_asB64(),
          number: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.BlockBalanceTrace.BlockIdentifier();
      return TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setHash(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setNumber(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getHash_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getNumber();
      if (f2 !== 0) {
        writer.writeInt64(2, f2);
      }
    };
    TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getHash())
      );
    };
    TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getHash())
      );
    };
    TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.setHash = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getNumber = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.setNumber = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.BlockBalanceTrace.prototype.getBlockIdentifier = function() {
      return (
        /** @type{?TronWebProto.BlockBalanceTrace.BlockIdentifier} */
        jspb.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 1)
      );
    };
    TronWebProto.BlockBalanceTrace.prototype.setBlockIdentifier = function(value) {
      return jspb.Message.setWrapperField(this, 1, value);
    };
    TronWebProto.BlockBalanceTrace.prototype.clearBlockIdentifier = function() {
      return this.setBlockIdentifier(void 0);
    };
    TronWebProto.BlockBalanceTrace.prototype.hasBlockIdentifier = function() {
      return jspb.Message.getField(this, 1) != null;
    };
    TronWebProto.BlockBalanceTrace.prototype.getTimestamp = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.BlockBalanceTrace.prototype.setTimestamp = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.BlockBalanceTrace.prototype.getTransactionBalanceTraceList = function() {
      return (
        /** @type{!Array<!TronWebProto.TransactionBalanceTrace>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.TransactionBalanceTrace, 3)
      );
    };
    TronWebProto.BlockBalanceTrace.prototype.setTransactionBalanceTraceList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 3, value);
    };
    TronWebProto.BlockBalanceTrace.prototype.addTransactionBalanceTrace = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, TronWebProto.TransactionBalanceTrace, opt_index);
    };
    TronWebProto.BlockBalanceTrace.prototype.clearTransactionBalanceTraceList = function() {
      return this.setTransactionBalanceTraceList([]);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.AccountTrace.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.AccountTrace.toObject(opt_includeInstance, this);
      };
      TronWebProto.AccountTrace.toObject = function(includeInstance, msg) {
        var f2, obj = {
          balance: jspb.Message.getFieldWithDefault(msg, 1, 0),
          placeholder: jspb.Message.getFieldWithDefault(msg, 99, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.AccountTrace.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.AccountTrace();
      return TronWebProto.AccountTrace.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.AccountTrace.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setBalance(value);
            break;
          case 99:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setPlaceholder(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.AccountTrace.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.AccountTrace.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.AccountTrace.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getBalance();
      if (f2 !== 0) {
        writer.writeInt64(1, f2);
      }
      f2 = message.getPlaceholder();
      if (f2 !== 0) {
        writer.writeInt64(99, f2);
      }
    };
    TronWebProto.AccountTrace.prototype.getBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.AccountTrace.prototype.setBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 1, value);
    };
    TronWebProto.AccountTrace.prototype.getPlaceholder = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 99, 0)
      );
    };
    TronWebProto.AccountTrace.prototype.setPlaceholder = function(value) {
      return jspb.Message.setProto3IntField(this, 99, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.AccountIdentifier.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.AccountIdentifier.toObject(opt_includeInstance, this);
      };
      TronWebProto.AccountIdentifier.toObject = function(includeInstance, msg) {
        var f2, obj = {
          address: msg.getAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.AccountIdentifier.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.AccountIdentifier();
      return TronWebProto.AccountIdentifier.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.AccountIdentifier.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.AccountIdentifier.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.AccountIdentifier.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.AccountIdentifier.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
    };
    TronWebProto.AccountIdentifier.prototype.getAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.AccountIdentifier.prototype.getAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getAddress())
      );
    };
    TronWebProto.AccountIdentifier.prototype.getAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getAddress())
      );
    };
    TronWebProto.AccountIdentifier.prototype.setAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.AccountBalanceRequest.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.AccountBalanceRequest.toObject(opt_includeInstance, this);
      };
      TronWebProto.AccountBalanceRequest.toObject = function(includeInstance, msg) {
        var f2, obj = {
          accountIdentifier: (f2 = msg.getAccountIdentifier()) && TronWebProto.AccountIdentifier.toObject(includeInstance, f2),
          blockIdentifier: (f2 = msg.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.AccountBalanceRequest.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.AccountBalanceRequest();
      return TronWebProto.AccountBalanceRequest.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.AccountBalanceRequest.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new TronWebProto.AccountIdentifier();
            reader.readMessage(value, TronWebProto.AccountIdentifier.deserializeBinaryFromReader);
            msg.setAccountIdentifier(value);
            break;
          case 2:
            var value = new TronWebProto.BlockBalanceTrace.BlockIdentifier();
            reader.readMessage(value, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader);
            msg.setBlockIdentifier(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.AccountBalanceRequest.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.AccountBalanceRequest.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.AccountBalanceRequest.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAccountIdentifier();
      if (f2 != null) {
        writer.writeMessage(1, f2, TronWebProto.AccountIdentifier.serializeBinaryToWriter);
      }
      f2 = message.getBlockIdentifier();
      if (f2 != null) {
        writer.writeMessage(2, f2, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter);
      }
    };
    TronWebProto.AccountBalanceRequest.prototype.getAccountIdentifier = function() {
      return (
        /** @type{?TronWebProto.AccountIdentifier} */
        jspb.Message.getWrapperField(this, TronWebProto.AccountIdentifier, 1)
      );
    };
    TronWebProto.AccountBalanceRequest.prototype.setAccountIdentifier = function(value) {
      return jspb.Message.setWrapperField(this, 1, value);
    };
    TronWebProto.AccountBalanceRequest.prototype.clearAccountIdentifier = function() {
      return this.setAccountIdentifier(void 0);
    };
    TronWebProto.AccountBalanceRequest.prototype.hasAccountIdentifier = function() {
      return jspb.Message.getField(this, 1) != null;
    };
    TronWebProto.AccountBalanceRequest.prototype.getBlockIdentifier = function() {
      return (
        /** @type{?TronWebProto.BlockBalanceTrace.BlockIdentifier} */
        jspb.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 2)
      );
    };
    TronWebProto.AccountBalanceRequest.prototype.setBlockIdentifier = function(value) {
      return jspb.Message.setWrapperField(this, 2, value);
    };
    TronWebProto.AccountBalanceRequest.prototype.clearBlockIdentifier = function() {
      return this.setBlockIdentifier(void 0);
    };
    TronWebProto.AccountBalanceRequest.prototype.hasBlockIdentifier = function() {
      return jspb.Message.getField(this, 2) != null;
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.AccountBalanceResponse.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.AccountBalanceResponse.toObject(opt_includeInstance, this);
      };
      TronWebProto.AccountBalanceResponse.toObject = function(includeInstance, msg) {
        var f2, obj = {
          balance: jspb.Message.getFieldWithDefault(msg, 1, 0),
          blockIdentifier: (f2 = msg.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.AccountBalanceResponse.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.AccountBalanceResponse();
      return TronWebProto.AccountBalanceResponse.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.AccountBalanceResponse.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setBalance(value);
            break;
          case 2:
            var value = new TronWebProto.BlockBalanceTrace.BlockIdentifier();
            reader.readMessage(value, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader);
            msg.setBlockIdentifier(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.AccountBalanceResponse.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.AccountBalanceResponse.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.AccountBalanceResponse.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getBalance();
      if (f2 !== 0) {
        writer.writeInt64(1, f2);
      }
      f2 = message.getBlockIdentifier();
      if (f2 != null) {
        writer.writeMessage(2, f2, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter);
      }
    };
    TronWebProto.AccountBalanceResponse.prototype.getBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.AccountBalanceResponse.prototype.setBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 1, value);
    };
    TronWebProto.AccountBalanceResponse.prototype.getBlockIdentifier = function() {
      return (
        /** @type{?TronWebProto.BlockBalanceTrace.BlockIdentifier} */
        jspb.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 2)
      );
    };
    TronWebProto.AccountBalanceResponse.prototype.setBlockIdentifier = function(value) {
      return jspb.Message.setWrapperField(this, 2, value);
    };
    TronWebProto.AccountBalanceResponse.prototype.clearBlockIdentifier = function() {
      return this.setBlockIdentifier(void 0);
    };
    TronWebProto.AccountBalanceResponse.prototype.hasBlockIdentifier = function() {
      return jspb.Message.getField(this, 2) != null;
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.FreezeBalanceV2Contract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.FreezeBalanceV2Contract.toObject(opt_includeInstance, this);
      };
      TronWebProto.FreezeBalanceV2Contract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          frozenBalance: jspb.Message.getFieldWithDefault(msg, 2, 0),
          resource: jspb.Message.getFieldWithDefault(msg, 3, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.FreezeBalanceV2Contract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.FreezeBalanceV2Contract();
      return TronWebProto.FreezeBalanceV2Contract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.FreezeBalanceV2Contract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFrozenBalance(value);
            break;
          case 3:
            var value = (
              /** @type {!TronWebProto.ResourceCode} */
              reader.readEnum()
            );
            msg.setResource(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.FreezeBalanceV2Contract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.FreezeBalanceV2Contract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.FreezeBalanceV2Contract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getFrozenBalance();
      if (f2 !== 0) {
        writer.writeInt64(2, f2);
      }
      f2 = message.getResource();
      if (f2 !== 0) {
        writer.writeEnum(3, f2);
      }
    };
    TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.FreezeBalanceV2Contract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.FreezeBalanceV2Contract.prototype.getFrozenBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.FreezeBalanceV2Contract.prototype.setFrozenBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.FreezeBalanceV2Contract.prototype.getResource = function() {
      return (
        /** @type {!TronWebProto.ResourceCode} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.FreezeBalanceV2Contract.prototype.setResource = function(value) {
      return jspb.Message.setProto3EnumField(this, 3, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.UnfreezeBalanceV2Contract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.UnfreezeBalanceV2Contract.toObject(opt_includeInstance, this);
      };
      TronWebProto.UnfreezeBalanceV2Contract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          unfreezeBalance: jspb.Message.getFieldWithDefault(msg, 2, 0),
          resource: jspb.Message.getFieldWithDefault(msg, 3, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.UnfreezeBalanceV2Contract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.UnfreezeBalanceV2Contract();
      return TronWebProto.UnfreezeBalanceV2Contract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.UnfreezeBalanceV2Contract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setUnfreezeBalance(value);
            break;
          case 3:
            var value = (
              /** @type {!TronWebProto.ResourceCode} */
              reader.readEnum()
            );
            msg.setResource(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.UnfreezeBalanceV2Contract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.UnfreezeBalanceV2Contract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.UnfreezeBalanceV2Contract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getUnfreezeBalance();
      if (f2 !== 0) {
        writer.writeInt64(2, f2);
      }
      f2 = message.getResource();
      if (f2 !== 0) {
        writer.writeEnum(3, f2);
      }
    };
    TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.UnfreezeBalanceV2Contract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.UnfreezeBalanceV2Contract.prototype.getUnfreezeBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.UnfreezeBalanceV2Contract.prototype.setUnfreezeBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.UnfreezeBalanceV2Contract.prototype.getResource = function() {
      return (
        /** @type {!TronWebProto.ResourceCode} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.UnfreezeBalanceV2Contract.prototype.setResource = function(value) {
      return jspb.Message.setProto3EnumField(this, 3, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.WithdrawExpireUnfreezeContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.WithdrawExpireUnfreezeContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.WithdrawExpireUnfreezeContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.WithdrawExpireUnfreezeContract();
      return TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.WithdrawExpireUnfreezeContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.WithdrawExpireUnfreezeContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.WithdrawExpireUnfreezeContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
    };
    TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.WithdrawExpireUnfreezeContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.DelegateResourceContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.DelegateResourceContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.DelegateResourceContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          resource: jspb.Message.getFieldWithDefault(msg, 2, 0),
          balance: jspb.Message.getFieldWithDefault(msg, 3, 0),
          receiverAddress: msg.getReceiverAddress_asB64(),
          lock: jspb.Message.getBooleanFieldWithDefault(msg, 5, false),
          lockPeriod: jspb.Message.getFieldWithDefault(msg, 6, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.DelegateResourceContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.DelegateResourceContract();
      return TronWebProto.DelegateResourceContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.DelegateResourceContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!TronWebProto.ResourceCode} */
              reader.readEnum()
            );
            msg.setResource(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setBalance(value);
            break;
          case 4:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setReceiverAddress(value);
            break;
          case 5:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setLock(value);
            break;
          case 6:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setLockPeriod(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.DelegateResourceContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.DelegateResourceContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.DelegateResourceContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getResource();
      if (f2 !== 0) {
        writer.writeEnum(2, f2);
      }
      f2 = message.getBalance();
      if (f2 !== 0) {
        writer.writeInt64(3, f2);
      }
      f2 = message.getReceiverAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(4, f2);
      }
      f2 = message.getLock();
      if (f2) {
        writer.writeBool(5, f2);
      }
      f2 = message.getLockPeriod();
      if (f2 !== 0) {
        writer.writeInt64(6, f2);
      }
    };
    TronWebProto.DelegateResourceContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.DelegateResourceContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.DelegateResourceContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.DelegateResourceContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.DelegateResourceContract.prototype.getResource = function() {
      return (
        /** @type {!TronWebProto.ResourceCode} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.DelegateResourceContract.prototype.setResource = function(value) {
      return jspb.Message.setProto3EnumField(this, 2, value);
    };
    TronWebProto.DelegateResourceContract.prototype.getBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.DelegateResourceContract.prototype.setBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.DelegateResourceContract.prototype.getReceiverAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 4, "")
      );
    };
    TronWebProto.DelegateResourceContract.prototype.getReceiverAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getReceiverAddress())
      );
    };
    TronWebProto.DelegateResourceContract.prototype.getReceiverAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getReceiverAddress())
      );
    };
    TronWebProto.DelegateResourceContract.prototype.setReceiverAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 4, value);
    };
    TronWebProto.DelegateResourceContract.prototype.getLock = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 5, false)
      );
    };
    TronWebProto.DelegateResourceContract.prototype.setLock = function(value) {
      return jspb.Message.setProto3BooleanField(this, 5, value);
    };
    TronWebProto.DelegateResourceContract.prototype.getLockPeriod = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 6, 0)
      );
    };
    TronWebProto.DelegateResourceContract.prototype.setLockPeriod = function(value) {
      return jspb.Message.setProto3IntField(this, 6, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.UnDelegateResourceContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.UnDelegateResourceContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.UnDelegateResourceContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          resource: jspb.Message.getFieldWithDefault(msg, 2, 0),
          balance: jspb.Message.getFieldWithDefault(msg, 3, 0),
          receiverAddress: msg.getReceiverAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.UnDelegateResourceContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.UnDelegateResourceContract();
      return TronWebProto.UnDelegateResourceContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.UnDelegateResourceContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!TronWebProto.ResourceCode} */
              reader.readEnum()
            );
            msg.setResource(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setBalance(value);
            break;
          case 4:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setReceiverAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.UnDelegateResourceContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.UnDelegateResourceContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.UnDelegateResourceContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getResource();
      if (f2 !== 0) {
        writer.writeEnum(2, f2);
      }
      f2 = message.getBalance();
      if (f2 !== 0) {
        writer.writeInt64(3, f2);
      }
      f2 = message.getReceiverAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(4, f2);
      }
    };
    TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.UnDelegateResourceContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.UnDelegateResourceContract.prototype.getResource = function() {
      return (
        /** @type {!TronWebProto.ResourceCode} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.UnDelegateResourceContract.prototype.setResource = function(value) {
      return jspb.Message.setProto3EnumField(this, 2, value);
    };
    TronWebProto.UnDelegateResourceContract.prototype.getBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.UnDelegateResourceContract.prototype.setBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 4, "")
      );
    };
    TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getReceiverAddress())
      );
    };
    TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getReceiverAddress())
      );
    };
    TronWebProto.UnDelegateResourceContract.prototype.setReceiverAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 4, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.CancelAllUnfreezeV2Contract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.CancelAllUnfreezeV2Contract.toObject(opt_includeInstance, this);
      };
      TronWebProto.CancelAllUnfreezeV2Contract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.CancelAllUnfreezeV2Contract();
      return TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.CancelAllUnfreezeV2Contract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.CancelAllUnfreezeV2Contract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.CancelAllUnfreezeV2Contract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
    };
    TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.CancelAllUnfreezeV2Contract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    goog.object.extend(exports, TronWebProto);
  }
});

// node_modules/tronweb/lib/esm/protocol/core/contract/asset_issue_contract_pb.cjs
var require_asset_issue_contract_pb = __commonJS({
  "node_modules/tronweb/lib/esm/protocol/core/contract/asset_issue_contract_pb.cjs"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    goog.exportSymbol("TronWebProto.AssetIssueContract", null, global2);
    goog.exportSymbol("TronWebProto.AssetIssueContract.FrozenSupply", null, global2);
    goog.exportSymbol("TronWebProto.ParticipateAssetIssueContract", null, global2);
    goog.exportSymbol("TronWebProto.TransferAssetContract", null, global2);
    goog.exportSymbol("TronWebProto.UnfreezeAssetContract", null, global2);
    goog.exportSymbol("TronWebProto.UpdateAssetContract", null, global2);
    TronWebProto.AssetIssueContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.AssetIssueContract.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.AssetIssueContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.AssetIssueContract.displayName = "TronWebProto.AssetIssueContract";
    }
    TronWebProto.AssetIssueContract.FrozenSupply = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.AssetIssueContract.FrozenSupply, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.AssetIssueContract.FrozenSupply.displayName = "TronWebProto.AssetIssueContract.FrozenSupply";
    }
    TronWebProto.TransferAssetContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.TransferAssetContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.TransferAssetContract.displayName = "TronWebProto.TransferAssetContract";
    }
    TronWebProto.UnfreezeAssetContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.UnfreezeAssetContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.UnfreezeAssetContract.displayName = "TronWebProto.UnfreezeAssetContract";
    }
    TronWebProto.UpdateAssetContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.UpdateAssetContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.UpdateAssetContract.displayName = "TronWebProto.UpdateAssetContract";
    }
    TronWebProto.ParticipateAssetIssueContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.ParticipateAssetIssueContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.ParticipateAssetIssueContract.displayName = "TronWebProto.ParticipateAssetIssueContract";
    }
    TronWebProto.AssetIssueContract.repeatedFields_ = [5];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.AssetIssueContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.AssetIssueContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.AssetIssueContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          id: jspb.Message.getFieldWithDefault(msg, 41, ""),
          ownerAddress: msg.getOwnerAddress_asB64(),
          name: msg.getName_asB64(),
          abbr: msg.getAbbr_asB64(),
          totalSupply: jspb.Message.getFieldWithDefault(msg, 4, 0),
          frozenSupplyList: jspb.Message.toObjectList(
            msg.getFrozenSupplyList(),
            TronWebProto.AssetIssueContract.FrozenSupply.toObject,
            includeInstance
          ),
          trxNum: jspb.Message.getFieldWithDefault(msg, 6, 0),
          precision: jspb.Message.getFieldWithDefault(msg, 7, 0),
          num: jspb.Message.getFieldWithDefault(msg, 8, 0),
          startTime: jspb.Message.getFieldWithDefault(msg, 9, 0),
          endTime: jspb.Message.getFieldWithDefault(msg, 10, 0),
          order: jspb.Message.getFieldWithDefault(msg, 11, 0),
          voteScore: jspb.Message.getFieldWithDefault(msg, 16, 0),
          description: msg.getDescription_asB64(),
          url: msg.getUrl_asB64(),
          freeAssetNetLimit: jspb.Message.getFieldWithDefault(msg, 22, 0),
          publicFreeAssetNetLimit: jspb.Message.getFieldWithDefault(msg, 23, 0),
          publicFreeAssetNetUsage: jspb.Message.getFieldWithDefault(msg, 24, 0),
          publicLatestFreeNetTime: jspb.Message.getFieldWithDefault(msg, 25, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.AssetIssueContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.AssetIssueContract();
      return TronWebProto.AssetIssueContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.AssetIssueContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 41:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setId(value);
            break;
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setName(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAbbr(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setTotalSupply(value);
            break;
          case 5:
            var value = new TronWebProto.AssetIssueContract.FrozenSupply();
            reader.readMessage(value, TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader);
            msg.addFrozenSupply(value);
            break;
          case 6:
            var value = (
              /** @type {number} */
              reader.readInt32()
            );
            msg.setTrxNum(value);
            break;
          case 7:
            var value = (
              /** @type {number} */
              reader.readInt32()
            );
            msg.setPrecision(value);
            break;
          case 8:
            var value = (
              /** @type {number} */
              reader.readInt32()
            );
            msg.setNum(value);
            break;
          case 9:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setStartTime(value);
            break;
          case 10:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setEndTime(value);
            break;
          case 11:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setOrder(value);
            break;
          case 16:
            var value = (
              /** @type {number} */
              reader.readInt32()
            );
            msg.setVoteScore(value);
            break;
          case 20:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setDescription(value);
            break;
          case 21:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setUrl(value);
            break;
          case 22:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFreeAssetNetLimit(value);
            break;
          case 23:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setPublicFreeAssetNetLimit(value);
            break;
          case 24:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setPublicFreeAssetNetUsage(value);
            break;
          case 25:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setPublicLatestFreeNetTime(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.AssetIssueContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.AssetIssueContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.AssetIssueContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getId();
      if (f2.length > 0) {
        writer.writeString(
          41,
          f2
        );
      }
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getName_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getAbbr_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getTotalSupply();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
      f2 = message.getFrozenSupplyList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          5,
          f2,
          TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter
        );
      }
      f2 = message.getTrxNum();
      if (f2 !== 0) {
        writer.writeInt32(
          6,
          f2
        );
      }
      f2 = message.getPrecision();
      if (f2 !== 0) {
        writer.writeInt32(
          7,
          f2
        );
      }
      f2 = message.getNum();
      if (f2 !== 0) {
        writer.writeInt32(
          8,
          f2
        );
      }
      f2 = message.getStartTime();
      if (f2 !== 0) {
        writer.writeInt64(
          9,
          f2
        );
      }
      f2 = message.getEndTime();
      if (f2 !== 0) {
        writer.writeInt64(
          10,
          f2
        );
      }
      f2 = message.getOrder();
      if (f2 !== 0) {
        writer.writeInt64(
          11,
          f2
        );
      }
      f2 = message.getVoteScore();
      if (f2 !== 0) {
        writer.writeInt32(
          16,
          f2
        );
      }
      f2 = message.getDescription_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          20,
          f2
        );
      }
      f2 = message.getUrl_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          21,
          f2
        );
      }
      f2 = message.getFreeAssetNetLimit();
      if (f2 !== 0) {
        writer.writeInt64(
          22,
          f2
        );
      }
      f2 = message.getPublicFreeAssetNetLimit();
      if (f2 !== 0) {
        writer.writeInt64(
          23,
          f2
        );
      }
      f2 = message.getPublicFreeAssetNetUsage();
      if (f2 !== 0) {
        writer.writeInt64(
          24,
          f2
        );
      }
      f2 = message.getPublicLatestFreeNetTime();
      if (f2 !== 0) {
        writer.writeInt64(
          25,
          f2
        );
      }
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.AssetIssueContract.FrozenSupply.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.AssetIssueContract.FrozenSupply.toObject(opt_includeInstance, this);
      };
      TronWebProto.AssetIssueContract.FrozenSupply.toObject = function(includeInstance, msg) {
        var f2, obj = {
          frozenAmount: jspb.Message.getFieldWithDefault(msg, 1, 0),
          frozenDays: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.AssetIssueContract.FrozenSupply();
      return TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFrozenAmount(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFrozenDays(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.AssetIssueContract.FrozenSupply.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getFrozenAmount();
      if (f2 !== 0) {
        writer.writeInt64(
          1,
          f2
        );
      }
      f2 = message.getFrozenDays();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
    };
    TronWebProto.AssetIssueContract.FrozenSupply.prototype.getFrozenAmount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.AssetIssueContract.FrozenSupply.prototype.setFrozenAmount = function(value) {
      return jspb.Message.setProto3IntField(this, 1, value);
    };
    TronWebProto.AssetIssueContract.FrozenSupply.prototype.getFrozenDays = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.AssetIssueContract.FrozenSupply.prototype.setFrozenDays = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.AssetIssueContract.prototype.getId = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 41, "")
      );
    };
    TronWebProto.AssetIssueContract.prototype.setId = function(value) {
      return jspb.Message.setProto3StringField(this, 41, value);
    };
    TronWebProto.AssetIssueContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.AssetIssueContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.AssetIssueContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.AssetIssueContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.AssetIssueContract.prototype.getName = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.AssetIssueContract.prototype.getName_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getName()
        )
      );
    };
    TronWebProto.AssetIssueContract.prototype.getName_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getName()
        )
      );
    };
    TronWebProto.AssetIssueContract.prototype.setName = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.AssetIssueContract.prototype.getAbbr = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.AssetIssueContract.prototype.getAbbr_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAbbr()
        )
      );
    };
    TronWebProto.AssetIssueContract.prototype.getAbbr_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAbbr()
        )
      );
    };
    TronWebProto.AssetIssueContract.prototype.setAbbr = function(value) {
      return jspb.Message.setProto3BytesField(this, 3, value);
    };
    TronWebProto.AssetIssueContract.prototype.getTotalSupply = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setTotalSupply = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    TronWebProto.AssetIssueContract.prototype.getFrozenSupplyList = function() {
      return (
        /** @type{!Array<!TronWebProto.AssetIssueContract.FrozenSupply>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.AssetIssueContract.FrozenSupply, 5)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setFrozenSupplyList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 5, value);
    };
    TronWebProto.AssetIssueContract.prototype.addFrozenSupply = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, TronWebProto.AssetIssueContract.FrozenSupply, opt_index);
    };
    TronWebProto.AssetIssueContract.prototype.clearFrozenSupplyList = function() {
      return this.setFrozenSupplyList([]);
    };
    TronWebProto.AssetIssueContract.prototype.getTrxNum = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 6, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setTrxNum = function(value) {
      return jspb.Message.setProto3IntField(this, 6, value);
    };
    TronWebProto.AssetIssueContract.prototype.getPrecision = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 7, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setPrecision = function(value) {
      return jspb.Message.setProto3IntField(this, 7, value);
    };
    TronWebProto.AssetIssueContract.prototype.getNum = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 8, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setNum = function(value) {
      return jspb.Message.setProto3IntField(this, 8, value);
    };
    TronWebProto.AssetIssueContract.prototype.getStartTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 9, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setStartTime = function(value) {
      return jspb.Message.setProto3IntField(this, 9, value);
    };
    TronWebProto.AssetIssueContract.prototype.getEndTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 10, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setEndTime = function(value) {
      return jspb.Message.setProto3IntField(this, 10, value);
    };
    TronWebProto.AssetIssueContract.prototype.getOrder = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 11, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setOrder = function(value) {
      return jspb.Message.setProto3IntField(this, 11, value);
    };
    TronWebProto.AssetIssueContract.prototype.getVoteScore = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 16, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setVoteScore = function(value) {
      return jspb.Message.setProto3IntField(this, 16, value);
    };
    TronWebProto.AssetIssueContract.prototype.getDescription = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 20, "")
      );
    };
    TronWebProto.AssetIssueContract.prototype.getDescription_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getDescription()
        )
      );
    };
    TronWebProto.AssetIssueContract.prototype.getDescription_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getDescription()
        )
      );
    };
    TronWebProto.AssetIssueContract.prototype.setDescription = function(value) {
      return jspb.Message.setProto3BytesField(this, 20, value);
    };
    TronWebProto.AssetIssueContract.prototype.getUrl = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 21, "")
      );
    };
    TronWebProto.AssetIssueContract.prototype.getUrl_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getUrl()
        )
      );
    };
    TronWebProto.AssetIssueContract.prototype.getUrl_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getUrl()
        )
      );
    };
    TronWebProto.AssetIssueContract.prototype.setUrl = function(value) {
      return jspb.Message.setProto3BytesField(this, 21, value);
    };
    TronWebProto.AssetIssueContract.prototype.getFreeAssetNetLimit = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 22, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setFreeAssetNetLimit = function(value) {
      return jspb.Message.setProto3IntField(this, 22, value);
    };
    TronWebProto.AssetIssueContract.prototype.getPublicFreeAssetNetLimit = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 23, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setPublicFreeAssetNetLimit = function(value) {
      return jspb.Message.setProto3IntField(this, 23, value);
    };
    TronWebProto.AssetIssueContract.prototype.getPublicFreeAssetNetUsage = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 24, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setPublicFreeAssetNetUsage = function(value) {
      return jspb.Message.setProto3IntField(this, 24, value);
    };
    TronWebProto.AssetIssueContract.prototype.getPublicLatestFreeNetTime = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 25, 0)
      );
    };
    TronWebProto.AssetIssueContract.prototype.setPublicLatestFreeNetTime = function(value) {
      return jspb.Message.setProto3IntField(this, 25, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.TransferAssetContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.TransferAssetContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.TransferAssetContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          assetName: msg.getAssetName_asB64(),
          ownerAddress: msg.getOwnerAddress_asB64(),
          toAddress: msg.getToAddress_asB64(),
          amount: jspb.Message.getFieldWithDefault(msg, 4, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.TransferAssetContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.TransferAssetContract();
      return TronWebProto.TransferAssetContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.TransferAssetContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAssetName(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setToAddress(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setAmount(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.TransferAssetContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.TransferAssetContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.TransferAssetContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAssetName_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getToAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getAmount();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
    };
    TronWebProto.TransferAssetContract.prototype.getAssetName = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.TransferAssetContract.prototype.getAssetName_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAssetName()
        )
      );
    };
    TronWebProto.TransferAssetContract.prototype.getAssetName_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAssetName()
        )
      );
    };
    TronWebProto.TransferAssetContract.prototype.setAssetName = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.TransferAssetContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.TransferAssetContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.TransferAssetContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.TransferAssetContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.TransferAssetContract.prototype.getToAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.TransferAssetContract.prototype.getToAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getToAddress()
        )
      );
    };
    TronWebProto.TransferAssetContract.prototype.getToAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getToAddress()
        )
      );
    };
    TronWebProto.TransferAssetContract.prototype.setToAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 3, value);
    };
    TronWebProto.TransferAssetContract.prototype.getAmount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.TransferAssetContract.prototype.setAmount = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.UnfreezeAssetContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.UnfreezeAssetContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.UnfreezeAssetContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.UnfreezeAssetContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.UnfreezeAssetContract();
      return TronWebProto.UnfreezeAssetContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.UnfreezeAssetContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.UnfreezeAssetContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.UnfreezeAssetContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.UnfreezeAssetContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
    };
    TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.UnfreezeAssetContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.UpdateAssetContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.UpdateAssetContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.UpdateAssetContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          description: msg.getDescription_asB64(),
          url: msg.getUrl_asB64(),
          newLimit: jspb.Message.getFieldWithDefault(msg, 4, 0),
          newPublicLimit: jspb.Message.getFieldWithDefault(msg, 5, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.UpdateAssetContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.UpdateAssetContract();
      return TronWebProto.UpdateAssetContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.UpdateAssetContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setDescription(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setUrl(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setNewLimit(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setNewPublicLimit(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.UpdateAssetContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.UpdateAssetContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.UpdateAssetContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getDescription_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getUrl_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getNewLimit();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
      f2 = message.getNewPublicLimit();
      if (f2 !== 0) {
        writer.writeInt64(
          5,
          f2
        );
      }
    };
    TronWebProto.UpdateAssetContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.UpdateAssetContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.UpdateAssetContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.UpdateAssetContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.UpdateAssetContract.prototype.getDescription = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.UpdateAssetContract.prototype.getDescription_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getDescription()
        )
      );
    };
    TronWebProto.UpdateAssetContract.prototype.getDescription_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getDescription()
        )
      );
    };
    TronWebProto.UpdateAssetContract.prototype.setDescription = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.UpdateAssetContract.prototype.getUrl = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.UpdateAssetContract.prototype.getUrl_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getUrl()
        )
      );
    };
    TronWebProto.UpdateAssetContract.prototype.getUrl_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getUrl()
        )
      );
    };
    TronWebProto.UpdateAssetContract.prototype.setUrl = function(value) {
      return jspb.Message.setProto3BytesField(this, 3, value);
    };
    TronWebProto.UpdateAssetContract.prototype.getNewLimit = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.UpdateAssetContract.prototype.setNewLimit = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    TronWebProto.UpdateAssetContract.prototype.getNewPublicLimit = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.UpdateAssetContract.prototype.setNewPublicLimit = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.ParticipateAssetIssueContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.ParticipateAssetIssueContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.ParticipateAssetIssueContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          toAddress: msg.getToAddress_asB64(),
          assetName: msg.getAssetName_asB64(),
          amount: jspb.Message.getFieldWithDefault(msg, 4, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.ParticipateAssetIssueContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.ParticipateAssetIssueContract();
      return TronWebProto.ParticipateAssetIssueContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.ParticipateAssetIssueContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setToAddress(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAssetName(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setAmount(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.ParticipateAssetIssueContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.ParticipateAssetIssueContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getToAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getAssetName_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getAmount();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getToAddress()
        )
      );
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getToAddress()
        )
      );
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.setToAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getAssetName()
        )
      );
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getAssetName()
        )
      );
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.setAssetName = function(value) {
      return jspb.Message.setProto3BytesField(this, 3, value);
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.getAmount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.ParticipateAssetIssueContract.prototype.setAmount = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    goog.object.extend(exports, TronWebProto);
  }
});

// node_modules/tronweb/lib/esm/protocol/core/contract/smart_contract_pb.cjs
var require_smart_contract_pb = __commonJS({
  "node_modules/tronweb/lib/esm/protocol/core/contract/smart_contract_pb.cjs"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    var core_Tron_pb = require_Tron_pb();
    goog.object.extend(proto, core_Tron_pb);
    goog.exportSymbol("TronWebProto.ClearABIContract", null, global2);
    goog.exportSymbol("TronWebProto.ContractState", null, global2);
    goog.exportSymbol("TronWebProto.CreateSmartContract", null, global2);
    goog.exportSymbol("TronWebProto.SmartContract", null, global2);
    goog.exportSymbol("TronWebProto.SmartContract.ABI", null, global2);
    goog.exportSymbol("TronWebProto.SmartContract.ABI.Entry", null, global2);
    goog.exportSymbol("TronWebProto.SmartContract.ABI.Entry.EntryType", null, global2);
    goog.exportSymbol("TronWebProto.SmartContract.ABI.Entry.Param", null, global2);
    goog.exportSymbol("TronWebProto.SmartContract.ABI.Entry.StateMutabilityType", null, global2);
    goog.exportSymbol("TronWebProto.SmartContractDataWrapper", null, global2);
    goog.exportSymbol("TronWebProto.TriggerSmartContract", null, global2);
    goog.exportSymbol("TronWebProto.UpdateEnergyLimitContract", null, global2);
    goog.exportSymbol("TronWebProto.UpdateSettingContract", null, global2);
    TronWebProto.SmartContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.SmartContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.SmartContract.displayName = "TronWebProto.SmartContract";
    }
    TronWebProto.SmartContract.ABI = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.SmartContract.ABI.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.SmartContract.ABI, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.SmartContract.ABI.displayName = "TronWebProto.SmartContract.ABI";
    }
    TronWebProto.SmartContract.ABI.Entry = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.SmartContract.ABI.Entry.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.SmartContract.ABI.Entry, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.SmartContract.ABI.Entry.displayName = "TronWebProto.SmartContract.ABI.Entry";
    }
    TronWebProto.SmartContract.ABI.Entry.Param = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.SmartContract.ABI.Entry.Param, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.SmartContract.ABI.Entry.Param.displayName = "TronWebProto.SmartContract.ABI.Entry.Param";
    }
    TronWebProto.ContractState = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.ContractState, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.ContractState.displayName = "TronWebProto.ContractState";
    }
    TronWebProto.CreateSmartContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.CreateSmartContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.CreateSmartContract.displayName = "TronWebProto.CreateSmartContract";
    }
    TronWebProto.TriggerSmartContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.TriggerSmartContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.TriggerSmartContract.displayName = "TronWebProto.TriggerSmartContract";
    }
    TronWebProto.ClearABIContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.ClearABIContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.ClearABIContract.displayName = "TronWebProto.ClearABIContract";
    }
    TronWebProto.UpdateSettingContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.UpdateSettingContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.UpdateSettingContract.displayName = "TronWebProto.UpdateSettingContract";
    }
    TronWebProto.UpdateEnergyLimitContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.UpdateEnergyLimitContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.UpdateEnergyLimitContract.displayName = "TronWebProto.UpdateEnergyLimitContract";
    }
    TronWebProto.SmartContractDataWrapper = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.SmartContractDataWrapper, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.SmartContractDataWrapper.displayName = "TronWebProto.SmartContractDataWrapper";
    }
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.SmartContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.SmartContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.SmartContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          originAddress: msg.getOriginAddress_asB64(),
          contractAddress: msg.getContractAddress_asB64(),
          abi: (f2 = msg.getAbi()) && TronWebProto.SmartContract.ABI.toObject(includeInstance, f2),
          bytecode: msg.getBytecode_asB64(),
          callValue: jspb.Message.getFieldWithDefault(msg, 5, 0),
          consumeUserResourcePercent: jspb.Message.getFieldWithDefault(msg, 6, 0),
          name: jspb.Message.getFieldWithDefault(msg, 7, ""),
          originEnergyLimit: jspb.Message.getFieldWithDefault(msg, 8, 0),
          codeHash: msg.getCodeHash_asB64(),
          trxHash: msg.getTrxHash_asB64(),
          version: jspb.Message.getFieldWithDefault(msg, 11, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.SmartContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.SmartContract();
      return TronWebProto.SmartContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.SmartContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOriginAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setContractAddress(value);
            break;
          case 3:
            var value = new TronWebProto.SmartContract.ABI();
            reader.readMessage(value, TronWebProto.SmartContract.ABI.deserializeBinaryFromReader);
            msg.setAbi(value);
            break;
          case 4:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setBytecode(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setCallValue(value);
            break;
          case 6:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setConsumeUserResourcePercent(value);
            break;
          case 7:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setName(value);
            break;
          case 8:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setOriginEnergyLimit(value);
            break;
          case 9:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setCodeHash(value);
            break;
          case 10:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setTrxHash(value);
            break;
          case 11:
            var value = (
              /** @type {number} */
              reader.readInt32()
            );
            msg.setVersion(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.SmartContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.SmartContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.SmartContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOriginAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getContractAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
      f2 = message.getAbi();
      if (f2 != null) {
        writer.writeMessage(3, f2, TronWebProto.SmartContract.ABI.serializeBinaryToWriter);
      }
      f2 = message.getBytecode_asU8();
      if (f2.length > 0) {
        writer.writeBytes(4, f2);
      }
      f2 = message.getCallValue();
      if (f2 !== 0) {
        writer.writeInt64(5, f2);
      }
      f2 = message.getConsumeUserResourcePercent();
      if (f2 !== 0) {
        writer.writeInt64(6, f2);
      }
      f2 = message.getName();
      if (f2.length > 0) {
        writer.writeString(7, f2);
      }
      f2 = message.getOriginEnergyLimit();
      if (f2 !== 0) {
        writer.writeInt64(8, f2);
      }
      f2 = message.getCodeHash_asU8();
      if (f2.length > 0) {
        writer.writeBytes(9, f2);
      }
      f2 = message.getTrxHash_asU8();
      if (f2.length > 0) {
        writer.writeBytes(10, f2);
      }
      f2 = message.getVersion();
      if (f2 !== 0) {
        writer.writeInt32(11, f2);
      }
    };
    TronWebProto.SmartContract.ABI.repeatedFields_ = [1];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.SmartContract.ABI.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.SmartContract.ABI.toObject(opt_includeInstance, this);
      };
      TronWebProto.SmartContract.ABI.toObject = function(includeInstance, msg) {
        var f2, obj = {
          entrysList: jspb.Message.toObjectList(
            msg.getEntrysList(),
            TronWebProto.SmartContract.ABI.Entry.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.SmartContract.ABI.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.SmartContract.ABI();
      return TronWebProto.SmartContract.ABI.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.SmartContract.ABI.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new TronWebProto.SmartContract.ABI.Entry();
            reader.readMessage(value, TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader);
            msg.addEntrys(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.SmartContract.ABI.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.SmartContract.ABI.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.SmartContract.ABI.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getEntrysList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(1, f2, TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter);
      }
    };
    TronWebProto.SmartContract.ABI.Entry.repeatedFields_ = [4, 5];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.SmartContract.ABI.Entry.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.SmartContract.ABI.Entry.toObject(opt_includeInstance, this);
      };
      TronWebProto.SmartContract.ABI.Entry.toObject = function(includeInstance, msg) {
        var f2, obj = {
          anonymous: jspb.Message.getBooleanFieldWithDefault(msg, 1, false),
          constant: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
          name: jspb.Message.getFieldWithDefault(msg, 3, ""),
          inputsList: jspb.Message.toObjectList(
            msg.getInputsList(),
            TronWebProto.SmartContract.ABI.Entry.Param.toObject,
            includeInstance
          ),
          outputsList: jspb.Message.toObjectList(
            msg.getOutputsList(),
            TronWebProto.SmartContract.ABI.Entry.Param.toObject,
            includeInstance
          ),
          type: jspb.Message.getFieldWithDefault(msg, 6, 0),
          payable: jspb.Message.getBooleanFieldWithDefault(msg, 7, false),
          statemutability: jspb.Message.getFieldWithDefault(msg, 8, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.SmartContract.ABI.Entry.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.SmartContract.ABI.Entry();
      return TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setAnonymous(value);
            break;
          case 2:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setConstant(value);
            break;
          case 3:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setName(value);
            break;
          case 4:
            var value = new TronWebProto.SmartContract.ABI.Entry.Param();
            reader.readMessage(value, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader);
            msg.addInputs(value);
            break;
          case 5:
            var value = new TronWebProto.SmartContract.ABI.Entry.Param();
            reader.readMessage(value, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader);
            msg.addOutputs(value);
            break;
          case 6:
            var value = (
              /** @type {!TronWebProto.SmartContract.ABI.Entry.EntryType} */
              reader.readEnum()
            );
            msg.setType(value);
            break;
          case 7:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setPayable(value);
            break;
          case 8:
            var value = (
              /** @type {!TronWebProto.SmartContract.ABI.Entry.StateMutabilityType} */
              reader.readEnum()
            );
            msg.setStatemutability(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAnonymous();
      if (f2) {
        writer.writeBool(1, f2);
      }
      f2 = message.getConstant();
      if (f2) {
        writer.writeBool(2, f2);
      }
      f2 = message.getName();
      if (f2.length > 0) {
        writer.writeString(3, f2);
      }
      f2 = message.getInputsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(4, f2, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter);
      }
      f2 = message.getOutputsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(5, f2, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter);
      }
      f2 = message.getType();
      if (f2 !== 0) {
        writer.writeEnum(6, f2);
      }
      f2 = message.getPayable();
      if (f2) {
        writer.writeBool(7, f2);
      }
      f2 = message.getStatemutability();
      if (f2 !== 0) {
        writer.writeEnum(8, f2);
      }
    };
    TronWebProto.SmartContract.ABI.Entry.EntryType = {
      UNKNOWNENTRYTYPE: 0,
      CONSTRUCTOR: 1,
      FUNCTION: 2,
      EVENT: 3,
      FALLBACK: 4,
      RECEIVE: 5,
      ERROR: 6
    };
    TronWebProto.SmartContract.ABI.Entry.StateMutabilityType = {
      UNKNOWNMUTABILITYTYPE: 0,
      PURE: 1,
      VIEW: 2,
      NONPAYABLE: 3,
      PAYABLE: 4
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.SmartContract.ABI.Entry.Param.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.SmartContract.ABI.Entry.Param.toObject(opt_includeInstance, this);
      };
      TronWebProto.SmartContract.ABI.Entry.Param.toObject = function(includeInstance, msg) {
        var f2, obj = {
          indexed: jspb.Message.getBooleanFieldWithDefault(msg, 1, false),
          name: jspb.Message.getFieldWithDefault(msg, 2, ""),
          type: jspb.Message.getFieldWithDefault(msg, 3, "")
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.SmartContract.ABI.Entry.Param();
      return TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setIndexed(value);
            break;
          case 2:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setName(value);
            break;
          case 3:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setType(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.SmartContract.ABI.Entry.Param.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getIndexed();
      if (f2) {
        writer.writeBool(1, f2);
      }
      f2 = message.getName();
      if (f2.length > 0) {
        writer.writeString(2, f2);
      }
      f2 = message.getType();
      if (f2.length > 0) {
        writer.writeString(3, f2);
      }
    };
    TronWebProto.SmartContract.ABI.Entry.Param.prototype.getIndexed = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 1, false)
      );
    };
    TronWebProto.SmartContract.ABI.Entry.Param.prototype.setIndexed = function(value) {
      return jspb.Message.setProto3BooleanField(this, 1, value);
    };
    TronWebProto.SmartContract.ABI.Entry.Param.prototype.getName = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.SmartContract.ABI.Entry.Param.prototype.setName = function(value) {
      return jspb.Message.setProto3StringField(this, 2, value);
    };
    TronWebProto.SmartContract.ABI.Entry.Param.prototype.getType = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.SmartContract.ABI.Entry.Param.prototype.setType = function(value) {
      return jspb.Message.setProto3StringField(this, 3, value);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.getAnonymous = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 1, false)
      );
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.setAnonymous = function(value) {
      return jspb.Message.setProto3BooleanField(this, 1, value);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.getConstant = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 2, false)
      );
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.setConstant = function(value) {
      return jspb.Message.setProto3BooleanField(this, 2, value);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.getName = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.setName = function(value) {
      return jspb.Message.setProto3StringField(this, 3, value);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.getInputsList = function() {
      return (
        /** @type{!Array<!TronWebProto.SmartContract.ABI.Entry.Param>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry.Param, 4)
      );
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.setInputsList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 4, value);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.addInputs = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, TronWebProto.SmartContract.ABI.Entry.Param, opt_index);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.clearInputsList = function() {
      return this.setInputsList([]);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.getOutputsList = function() {
      return (
        /** @type{!Array<!TronWebProto.SmartContract.ABI.Entry.Param>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry.Param, 5)
      );
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.setOutputsList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 5, value);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.addOutputs = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, TronWebProto.SmartContract.ABI.Entry.Param, opt_index);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.clearOutputsList = function() {
      return this.setOutputsList([]);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.getType = function() {
      return (
        /** @type {!TronWebProto.SmartContract.ABI.Entry.EntryType} */
        jspb.Message.getFieldWithDefault(this, 6, 0)
      );
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.setType = function(value) {
      return jspb.Message.setProto3EnumField(this, 6, value);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.getPayable = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 7, false)
      );
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.setPayable = function(value) {
      return jspb.Message.setProto3BooleanField(this, 7, value);
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.getStatemutability = function() {
      return (
        /** @type {!TronWebProto.SmartContract.ABI.Entry.StateMutabilityType} */
        jspb.Message.getFieldWithDefault(this, 8, 0)
      );
    };
    TronWebProto.SmartContract.ABI.Entry.prototype.setStatemutability = function(value) {
      return jspb.Message.setProto3EnumField(this, 8, value);
    };
    TronWebProto.SmartContract.ABI.prototype.getEntrysList = function() {
      return (
        /** @type{!Array<!TronWebProto.SmartContract.ABI.Entry>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry, 1)
      );
    };
    TronWebProto.SmartContract.ABI.prototype.setEntrysList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 1, value);
    };
    TronWebProto.SmartContract.ABI.prototype.addEntrys = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, TronWebProto.SmartContract.ABI.Entry, opt_index);
    };
    TronWebProto.SmartContract.ABI.prototype.clearEntrysList = function() {
      return this.setEntrysList([]);
    };
    TronWebProto.SmartContract.prototype.getOriginAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.SmartContract.prototype.getOriginAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOriginAddress())
      );
    };
    TronWebProto.SmartContract.prototype.getOriginAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOriginAddress())
      );
    };
    TronWebProto.SmartContract.prototype.setOriginAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.SmartContract.prototype.getContractAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.SmartContract.prototype.getContractAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getContractAddress())
      );
    };
    TronWebProto.SmartContract.prototype.getContractAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getContractAddress())
      );
    };
    TronWebProto.SmartContract.prototype.setContractAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.SmartContract.prototype.getAbi = function() {
      return (
        /** @type{?TronWebProto.SmartContract.ABI} */
        jspb.Message.getWrapperField(this, TronWebProto.SmartContract.ABI, 3)
      );
    };
    TronWebProto.SmartContract.prototype.setAbi = function(value) {
      return jspb.Message.setWrapperField(this, 3, value);
    };
    TronWebProto.SmartContract.prototype.clearAbi = function() {
      return this.setAbi(void 0);
    };
    TronWebProto.SmartContract.prototype.hasAbi = function() {
      return jspb.Message.getField(this, 3) != null;
    };
    TronWebProto.SmartContract.prototype.getBytecode = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 4, "")
      );
    };
    TronWebProto.SmartContract.prototype.getBytecode_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getBytecode())
      );
    };
    TronWebProto.SmartContract.prototype.getBytecode_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getBytecode())
      );
    };
    TronWebProto.SmartContract.prototype.setBytecode = function(value) {
      return jspb.Message.setProto3BytesField(this, 4, value);
    };
    TronWebProto.SmartContract.prototype.getCallValue = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.SmartContract.prototype.setCallValue = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    TronWebProto.SmartContract.prototype.getConsumeUserResourcePercent = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 6, 0)
      );
    };
    TronWebProto.SmartContract.prototype.setConsumeUserResourcePercent = function(value) {
      return jspb.Message.setProto3IntField(this, 6, value);
    };
    TronWebProto.SmartContract.prototype.getName = function() {
      return (
        /** @type {string} */
        jspb.Message.getFieldWithDefault(this, 7, "")
      );
    };
    TronWebProto.SmartContract.prototype.setName = function(value) {
      return jspb.Message.setProto3StringField(this, 7, value);
    };
    TronWebProto.SmartContract.prototype.getOriginEnergyLimit = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 8, 0)
      );
    };
    TronWebProto.SmartContract.prototype.setOriginEnergyLimit = function(value) {
      return jspb.Message.setProto3IntField(this, 8, value);
    };
    TronWebProto.SmartContract.prototype.getCodeHash = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 9, "")
      );
    };
    TronWebProto.SmartContract.prototype.getCodeHash_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getCodeHash())
      );
    };
    TronWebProto.SmartContract.prototype.getCodeHash_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getCodeHash())
      );
    };
    TronWebProto.SmartContract.prototype.setCodeHash = function(value) {
      return jspb.Message.setProto3BytesField(this, 9, value);
    };
    TronWebProto.SmartContract.prototype.getTrxHash = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 10, "")
      );
    };
    TronWebProto.SmartContract.prototype.getTrxHash_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getTrxHash())
      );
    };
    TronWebProto.SmartContract.prototype.getTrxHash_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getTrxHash())
      );
    };
    TronWebProto.SmartContract.prototype.setTrxHash = function(value) {
      return jspb.Message.setProto3BytesField(this, 10, value);
    };
    TronWebProto.SmartContract.prototype.getVersion = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 11, 0)
      );
    };
    TronWebProto.SmartContract.prototype.setVersion = function(value) {
      return jspb.Message.setProto3IntField(this, 11, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.ContractState.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.ContractState.toObject(opt_includeInstance, this);
      };
      TronWebProto.ContractState.toObject = function(includeInstance, msg) {
        var f2, obj = {
          energyUsage: jspb.Message.getFieldWithDefault(msg, 1, 0),
          energyFactor: jspb.Message.getFieldWithDefault(msg, 2, 0),
          updateCycle: jspb.Message.getFieldWithDefault(msg, 3, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.ContractState.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.ContractState();
      return TronWebProto.ContractState.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.ContractState.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setEnergyUsage(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setEnergyFactor(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setUpdateCycle(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.ContractState.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.ContractState.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.ContractState.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getEnergyUsage();
      if (f2 !== 0) {
        writer.writeInt64(1, f2);
      }
      f2 = message.getEnergyFactor();
      if (f2 !== 0) {
        writer.writeInt64(2, f2);
      }
      f2 = message.getUpdateCycle();
      if (f2 !== 0) {
        writer.writeInt64(3, f2);
      }
    };
    TronWebProto.ContractState.prototype.getEnergyUsage = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    TronWebProto.ContractState.prototype.setEnergyUsage = function(value) {
      return jspb.Message.setProto3IntField(this, 1, value);
    };
    TronWebProto.ContractState.prototype.getEnergyFactor = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.ContractState.prototype.setEnergyFactor = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.ContractState.prototype.getUpdateCycle = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.ContractState.prototype.setUpdateCycle = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.CreateSmartContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.CreateSmartContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.CreateSmartContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          newContract: (f2 = msg.getNewContract()) && TronWebProto.SmartContract.toObject(includeInstance, f2),
          callTokenValue: jspb.Message.getFieldWithDefault(msg, 3, 0),
          tokenId: jspb.Message.getFieldWithDefault(msg, 4, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.CreateSmartContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.CreateSmartContract();
      return TronWebProto.CreateSmartContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.CreateSmartContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = new TronWebProto.SmartContract();
            reader.readMessage(value, TronWebProto.SmartContract.deserializeBinaryFromReader);
            msg.setNewContract(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setCallTokenValue(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setTokenId(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.CreateSmartContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.CreateSmartContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.CreateSmartContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getNewContract();
      if (f2 != null) {
        writer.writeMessage(2, f2, TronWebProto.SmartContract.serializeBinaryToWriter);
      }
      f2 = message.getCallTokenValue();
      if (f2 !== 0) {
        writer.writeInt64(3, f2);
      }
      f2 = message.getTokenId();
      if (f2 !== 0) {
        writer.writeInt64(4, f2);
      }
    };
    TronWebProto.CreateSmartContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.CreateSmartContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.CreateSmartContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.CreateSmartContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.CreateSmartContract.prototype.getNewContract = function() {
      return (
        /** @type{?TronWebProto.SmartContract} */
        jspb.Message.getWrapperField(this, TronWebProto.SmartContract, 2)
      );
    };
    TronWebProto.CreateSmartContract.prototype.setNewContract = function(value) {
      return jspb.Message.setWrapperField(this, 2, value);
    };
    TronWebProto.CreateSmartContract.prototype.clearNewContract = function() {
      return this.setNewContract(void 0);
    };
    TronWebProto.CreateSmartContract.prototype.hasNewContract = function() {
      return jspb.Message.getField(this, 2) != null;
    };
    TronWebProto.CreateSmartContract.prototype.getCallTokenValue = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.CreateSmartContract.prototype.setCallTokenValue = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.CreateSmartContract.prototype.getTokenId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.CreateSmartContract.prototype.setTokenId = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.TriggerSmartContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.TriggerSmartContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.TriggerSmartContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          contractAddress: msg.getContractAddress_asB64(),
          callValue: jspb.Message.getFieldWithDefault(msg, 3, 0),
          data: msg.getData_asB64(),
          callTokenValue: jspb.Message.getFieldWithDefault(msg, 5, 0),
          tokenId: jspb.Message.getFieldWithDefault(msg, 6, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.TriggerSmartContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.TriggerSmartContract();
      return TronWebProto.TriggerSmartContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.TriggerSmartContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setContractAddress(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setCallValue(value);
            break;
          case 4:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setData(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setCallTokenValue(value);
            break;
          case 6:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setTokenId(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.TriggerSmartContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.TriggerSmartContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.TriggerSmartContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getContractAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
      f2 = message.getCallValue();
      if (f2 !== 0) {
        writer.writeInt64(3, f2);
      }
      f2 = message.getData_asU8();
      if (f2.length > 0) {
        writer.writeBytes(4, f2);
      }
      f2 = message.getCallTokenValue();
      if (f2 !== 0) {
        writer.writeInt64(5, f2);
      }
      f2 = message.getTokenId();
      if (f2 !== 0) {
        writer.writeInt64(6, f2);
      }
    };
    TronWebProto.TriggerSmartContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.TriggerSmartContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.TriggerSmartContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.TriggerSmartContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.TriggerSmartContract.prototype.getContractAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.TriggerSmartContract.prototype.getContractAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getContractAddress())
      );
    };
    TronWebProto.TriggerSmartContract.prototype.getContractAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getContractAddress())
      );
    };
    TronWebProto.TriggerSmartContract.prototype.setContractAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.TriggerSmartContract.prototype.getCallValue = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.TriggerSmartContract.prototype.setCallValue = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.TriggerSmartContract.prototype.getData = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 4, "")
      );
    };
    TronWebProto.TriggerSmartContract.prototype.getData_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getData())
      );
    };
    TronWebProto.TriggerSmartContract.prototype.getData_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getData())
      );
    };
    TronWebProto.TriggerSmartContract.prototype.setData = function(value) {
      return jspb.Message.setProto3BytesField(this, 4, value);
    };
    TronWebProto.TriggerSmartContract.prototype.getCallTokenValue = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.TriggerSmartContract.prototype.setCallTokenValue = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    TronWebProto.TriggerSmartContract.prototype.getTokenId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 6, 0)
      );
    };
    TronWebProto.TriggerSmartContract.prototype.setTokenId = function(value) {
      return jspb.Message.setProto3IntField(this, 6, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.ClearABIContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.ClearABIContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.ClearABIContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          contractAddress: msg.getContractAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.ClearABIContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.ClearABIContract();
      return TronWebProto.ClearABIContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.ClearABIContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setContractAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.ClearABIContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.ClearABIContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.ClearABIContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getContractAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
    };
    TronWebProto.ClearABIContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.ClearABIContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.ClearABIContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.ClearABIContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.ClearABIContract.prototype.getContractAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.ClearABIContract.prototype.getContractAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getContractAddress())
      );
    };
    TronWebProto.ClearABIContract.prototype.getContractAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getContractAddress())
      );
    };
    TronWebProto.ClearABIContract.prototype.setContractAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.UpdateSettingContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.UpdateSettingContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.UpdateSettingContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          contractAddress: msg.getContractAddress_asB64(),
          consumeUserResourcePercent: jspb.Message.getFieldWithDefault(msg, 3, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.UpdateSettingContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.UpdateSettingContract();
      return TronWebProto.UpdateSettingContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.UpdateSettingContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setContractAddress(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setConsumeUserResourcePercent(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.UpdateSettingContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.UpdateSettingContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.UpdateSettingContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getContractAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
      f2 = message.getConsumeUserResourcePercent();
      if (f2 !== 0) {
        writer.writeInt64(3, f2);
      }
    };
    TronWebProto.UpdateSettingContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.UpdateSettingContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.UpdateSettingContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.UpdateSettingContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.UpdateSettingContract.prototype.getContractAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.UpdateSettingContract.prototype.getContractAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getContractAddress())
      );
    };
    TronWebProto.UpdateSettingContract.prototype.getContractAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getContractAddress())
      );
    };
    TronWebProto.UpdateSettingContract.prototype.setContractAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.UpdateSettingContract.prototype.getConsumeUserResourcePercent = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.UpdateSettingContract.prototype.setConsumeUserResourcePercent = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.UpdateEnergyLimitContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.UpdateEnergyLimitContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.UpdateEnergyLimitContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          contractAddress: msg.getContractAddress_asB64(),
          originEnergyLimit: jspb.Message.getFieldWithDefault(msg, 3, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.UpdateEnergyLimitContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.UpdateEnergyLimitContract();
      return TronWebProto.UpdateEnergyLimitContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.UpdateEnergyLimitContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setContractAddress(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setOriginEnergyLimit(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.UpdateEnergyLimitContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.UpdateEnergyLimitContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getContractAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
      f2 = message.getOriginEnergyLimit();
      if (f2 !== 0) {
        writer.writeInt64(3, f2);
      }
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getContractAddress())
      );
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getContractAddress())
      );
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.setContractAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.getOriginEnergyLimit = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.UpdateEnergyLimitContract.prototype.setOriginEnergyLimit = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.SmartContractDataWrapper.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.SmartContractDataWrapper.toObject(opt_includeInstance, this);
      };
      TronWebProto.SmartContractDataWrapper.toObject = function(includeInstance, msg) {
        var f2, obj = {
          smartContract: (f2 = msg.getSmartContract()) && TronWebProto.SmartContract.toObject(includeInstance, f2),
          runtimecode: msg.getRuntimecode_asB64(),
          contractState: (f2 = msg.getContractState()) && TronWebProto.ContractState.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.SmartContractDataWrapper.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.SmartContractDataWrapper();
      return TronWebProto.SmartContractDataWrapper.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.SmartContractDataWrapper.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new TronWebProto.SmartContract();
            reader.readMessage(value, TronWebProto.SmartContract.deserializeBinaryFromReader);
            msg.setSmartContract(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setRuntimecode(value);
            break;
          case 3:
            var value = new TronWebProto.ContractState();
            reader.readMessage(value, TronWebProto.ContractState.deserializeBinaryFromReader);
            msg.setContractState(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.SmartContractDataWrapper.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.SmartContractDataWrapper.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.SmartContractDataWrapper.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getSmartContract();
      if (f2 != null) {
        writer.writeMessage(1, f2, TronWebProto.SmartContract.serializeBinaryToWriter);
      }
      f2 = message.getRuntimecode_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
      f2 = message.getContractState();
      if (f2 != null) {
        writer.writeMessage(3, f2, TronWebProto.ContractState.serializeBinaryToWriter);
      }
    };
    TronWebProto.SmartContractDataWrapper.prototype.getSmartContract = function() {
      return (
        /** @type{?TronWebProto.SmartContract} */
        jspb.Message.getWrapperField(this, TronWebProto.SmartContract, 1)
      );
    };
    TronWebProto.SmartContractDataWrapper.prototype.setSmartContract = function(value) {
      return jspb.Message.setWrapperField(this, 1, value);
    };
    TronWebProto.SmartContractDataWrapper.prototype.clearSmartContract = function() {
      return this.setSmartContract(void 0);
    };
    TronWebProto.SmartContractDataWrapper.prototype.hasSmartContract = function() {
      return jspb.Message.getField(this, 1) != null;
    };
    TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getRuntimecode())
      );
    };
    TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getRuntimecode())
      );
    };
    TronWebProto.SmartContractDataWrapper.prototype.setRuntimecode = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.SmartContractDataWrapper.prototype.getContractState = function() {
      return (
        /** @type{?TronWebProto.ContractState} */
        jspb.Message.getWrapperField(this, TronWebProto.ContractState, 3)
      );
    };
    TronWebProto.SmartContractDataWrapper.prototype.setContractState = function(value) {
      return jspb.Message.setWrapperField(this, 3, value);
    };
    TronWebProto.SmartContractDataWrapper.prototype.clearContractState = function() {
      return this.setContractState(void 0);
    };
    TronWebProto.SmartContractDataWrapper.prototype.hasContractState = function() {
      return jspb.Message.getField(this, 3) != null;
    };
    goog.object.extend(exports, TronWebProto);
  }
});

// node_modules/tronweb/lib/esm/protocol/core/contract/witness_contract_pb.cjs
var require_witness_contract_pb = __commonJS({
  "node_modules/tronweb/lib/esm/protocol/core/contract/witness_contract_pb.cjs"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    goog.exportSymbol("TronWebProto.VoteWitnessContract", null, global2);
    goog.exportSymbol("TronWebProto.VoteWitnessContract.Vote", null, global2);
    goog.exportSymbol("TronWebProto.WitnessCreateContract", null, global2);
    goog.exportSymbol("TronWebProto.WitnessUpdateContract", null, global2);
    TronWebProto.WitnessCreateContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.WitnessCreateContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.WitnessCreateContract.displayName = "TronWebProto.WitnessCreateContract";
    }
    TronWebProto.WitnessUpdateContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.WitnessUpdateContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.WitnessUpdateContract.displayName = "TronWebProto.WitnessUpdateContract";
    }
    TronWebProto.VoteWitnessContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.VoteWitnessContract.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.VoteWitnessContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.VoteWitnessContract.displayName = "TronWebProto.VoteWitnessContract";
    }
    TronWebProto.VoteWitnessContract.Vote = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.VoteWitnessContract.Vote, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.VoteWitnessContract.Vote.displayName = "TronWebProto.VoteWitnessContract.Vote";
    }
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.WitnessCreateContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.WitnessCreateContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.WitnessCreateContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          url: msg.getUrl_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.WitnessCreateContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.WitnessCreateContract();
      return TronWebProto.WitnessCreateContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.WitnessCreateContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setUrl(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.WitnessCreateContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.WitnessCreateContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.WitnessCreateContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getUrl_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
    };
    TronWebProto.WitnessCreateContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.WitnessCreateContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.WitnessCreateContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.WitnessCreateContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.WitnessCreateContract.prototype.getUrl = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.WitnessCreateContract.prototype.getUrl_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getUrl()
        )
      );
    };
    TronWebProto.WitnessCreateContract.prototype.getUrl_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getUrl()
        )
      );
    };
    TronWebProto.WitnessCreateContract.prototype.setUrl = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.WitnessUpdateContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.WitnessUpdateContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.WitnessUpdateContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          updateUrl: msg.getUpdateUrl_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.WitnessUpdateContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.WitnessUpdateContract();
      return TronWebProto.WitnessUpdateContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.WitnessUpdateContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 12:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setUpdateUrl(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.WitnessUpdateContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.WitnessUpdateContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.WitnessUpdateContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getUpdateUrl_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          12,
          f2
        );
      }
    };
    TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.WitnessUpdateContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 12, "")
      );
    };
    TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getUpdateUrl()
        )
      );
    };
    TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getUpdateUrl()
        )
      );
    };
    TronWebProto.WitnessUpdateContract.prototype.setUpdateUrl = function(value) {
      return jspb.Message.setProto3BytesField(this, 12, value);
    };
    TronWebProto.VoteWitnessContract.repeatedFields_ = [2];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.VoteWitnessContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.VoteWitnessContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.VoteWitnessContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          votesList: jspb.Message.toObjectList(
            msg.getVotesList(),
            TronWebProto.VoteWitnessContract.Vote.toObject,
            includeInstance
          ),
          support: jspb.Message.getBooleanFieldWithDefault(msg, 3, false)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.VoteWitnessContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.VoteWitnessContract();
      return TronWebProto.VoteWitnessContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.VoteWitnessContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = new TronWebProto.VoteWitnessContract.Vote();
            reader.readMessage(value, TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader);
            msg.addVotes(value);
            break;
          case 3:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setSupport(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.VoteWitnessContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.VoteWitnessContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.VoteWitnessContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getVotesList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter
        );
      }
      f2 = message.getSupport();
      if (f2) {
        writer.writeBool(
          3,
          f2
        );
      }
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.VoteWitnessContract.Vote.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.VoteWitnessContract.Vote.toObject(opt_includeInstance, this);
      };
      TronWebProto.VoteWitnessContract.Vote.toObject = function(includeInstance, msg) {
        var f2, obj = {
          voteAddress: msg.getVoteAddress_asB64(),
          voteCount: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.VoteWitnessContract.Vote.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.VoteWitnessContract.Vote();
      return TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setVoteAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setVoteCount(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.VoteWitnessContract.Vote.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getVoteAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getVoteCount();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
    };
    TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getVoteAddress()
        )
      );
    };
    TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getVoteAddress()
        )
      );
    };
    TronWebProto.VoteWitnessContract.Vote.prototype.setVoteAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.VoteWitnessContract.Vote.prototype.getVoteCount = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.VoteWitnessContract.Vote.prototype.setVoteCount = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.VoteWitnessContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.VoteWitnessContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.VoteWitnessContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.VoteWitnessContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.VoteWitnessContract.prototype.getVotesList = function() {
      return (
        /** @type{!Array<!TronWebProto.VoteWitnessContract.Vote>} */
        jspb.Message.getRepeatedWrapperField(this, TronWebProto.VoteWitnessContract.Vote, 2)
      );
    };
    TronWebProto.VoteWitnessContract.prototype.setVotesList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 2, value);
    };
    TronWebProto.VoteWitnessContract.prototype.addVotes = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, TronWebProto.VoteWitnessContract.Vote, opt_index);
    };
    TronWebProto.VoteWitnessContract.prototype.clearVotesList = function() {
      return this.setVotesList([]);
    };
    TronWebProto.VoteWitnessContract.prototype.getSupport = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 3, false)
      );
    };
    TronWebProto.VoteWitnessContract.prototype.setSupport = function(value) {
      return jspb.Message.setProto3BooleanField(this, 3, value);
    };
    goog.object.extend(exports, TronWebProto);
  }
});

// node_modules/tronweb/lib/esm/protocol/core/contract/storage_contract_pb.cjs
var require_storage_contract_pb = __commonJS({
  "node_modules/tronweb/lib/esm/protocol/core/contract/storage_contract_pb.cjs"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    goog.exportSymbol("TronWebProto.BuyStorageBytesContract", null, global2);
    goog.exportSymbol("TronWebProto.BuyStorageContract", null, global2);
    goog.exportSymbol("TronWebProto.SellStorageContract", null, global2);
    goog.exportSymbol("TronWebProto.UpdateBrokerageContract", null, global2);
    TronWebProto.BuyStorageBytesContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.BuyStorageBytesContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.BuyStorageBytesContract.displayName = "TronWebProto.BuyStorageBytesContract";
    }
    TronWebProto.BuyStorageContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.BuyStorageContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.BuyStorageContract.displayName = "TronWebProto.BuyStorageContract";
    }
    TronWebProto.SellStorageContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.SellStorageContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.SellStorageContract.displayName = "TronWebProto.SellStorageContract";
    }
    TronWebProto.UpdateBrokerageContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.UpdateBrokerageContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.UpdateBrokerageContract.displayName = "TronWebProto.UpdateBrokerageContract";
    }
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.BuyStorageBytesContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.BuyStorageBytesContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.BuyStorageBytesContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          bytes: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.BuyStorageBytesContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.BuyStorageBytesContract();
      return TronWebProto.BuyStorageBytesContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.BuyStorageBytesContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setBytes(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.BuyStorageBytesContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.BuyStorageBytesContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.BuyStorageBytesContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getBytes();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
    };
    TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.BuyStorageBytesContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.BuyStorageBytesContract.prototype.getBytes = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.BuyStorageBytesContract.prototype.setBytes = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.BuyStorageContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.BuyStorageContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.BuyStorageContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          quant: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.BuyStorageContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.BuyStorageContract();
      return TronWebProto.BuyStorageContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.BuyStorageContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setQuant(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.BuyStorageContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.BuyStorageContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.BuyStorageContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getQuant();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
    };
    TronWebProto.BuyStorageContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.BuyStorageContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.BuyStorageContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.BuyStorageContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.BuyStorageContract.prototype.getQuant = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.BuyStorageContract.prototype.setQuant = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.SellStorageContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.SellStorageContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.SellStorageContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          storageBytes: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.SellStorageContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.SellStorageContract();
      return TronWebProto.SellStorageContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.SellStorageContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setStorageBytes(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.SellStorageContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.SellStorageContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.SellStorageContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getStorageBytes();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
    };
    TronWebProto.SellStorageContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.SellStorageContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.SellStorageContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.SellStorageContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.SellStorageContract.prototype.getStorageBytes = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.SellStorageContract.prototype.setStorageBytes = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.UpdateBrokerageContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.UpdateBrokerageContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.UpdateBrokerageContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          brokerage: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.UpdateBrokerageContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.UpdateBrokerageContract();
      return TronWebProto.UpdateBrokerageContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.UpdateBrokerageContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt32()
            );
            msg.setBrokerage(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.UpdateBrokerageContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.UpdateBrokerageContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.UpdateBrokerageContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getBrokerage();
      if (f2 !== 0) {
        writer.writeInt32(
          2,
          f2
        );
      }
    };
    TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.UpdateBrokerageContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.UpdateBrokerageContract.prototype.getBrokerage = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.UpdateBrokerageContract.prototype.setBrokerage = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    goog.object.extend(exports, TronWebProto);
  }
});

// node_modules/tronweb/lib/esm/protocol/core/contract/account_contract_pb.cjs
var require_account_contract_pb = __commonJS({
  "node_modules/tronweb/lib/esm/protocol/core/contract/account_contract_pb.cjs"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    var core_Tron_pb = require_Tron_pb();
    goog.object.extend(proto, core_Tron_pb);
    goog.exportSymbol("TronWebProto.AccountCreateContract", null, global2);
    goog.exportSymbol("TronWebProto.AccountPermissionUpdateContract", null, global2);
    goog.exportSymbol("TronWebProto.AccountUpdateContract", null, global2);
    goog.exportSymbol("TronWebProto.SetAccountIdContract", null, global2);
    TronWebProto.AccountCreateContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.AccountCreateContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.AccountCreateContract.displayName = "TronWebProto.AccountCreateContract";
    }
    TronWebProto.AccountUpdateContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.AccountUpdateContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.AccountUpdateContract.displayName = "TronWebProto.AccountUpdateContract";
    }
    TronWebProto.SetAccountIdContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.SetAccountIdContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.SetAccountIdContract.displayName = "TronWebProto.SetAccountIdContract";
    }
    TronWebProto.AccountPermissionUpdateContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, TronWebProto.AccountPermissionUpdateContract.repeatedFields_, null);
    };
    goog.inherits(TronWebProto.AccountPermissionUpdateContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.AccountPermissionUpdateContract.displayName = "TronWebProto.AccountPermissionUpdateContract";
    }
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.AccountCreateContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.AccountCreateContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.AccountCreateContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          accountAddress: msg.getAccountAddress_asB64(),
          type: jspb.Message.getFieldWithDefault(msg, 3, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.AccountCreateContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.AccountCreateContract();
      return TronWebProto.AccountCreateContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.AccountCreateContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAccountAddress(value);
            break;
          case 3:
            var value = (
              /** @type {!TronWebProto.AccountType} */
              reader.readEnum()
            );
            msg.setType(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.AccountCreateContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.AccountCreateContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.AccountCreateContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getAccountAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
      f2 = message.getType();
      if (f2 !== 0) {
        writer.writeEnum(3, f2);
      }
    };
    TronWebProto.AccountCreateContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.AccountCreateContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.AccountCreateContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.AccountCreateContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.AccountCreateContract.prototype.getAccountAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.AccountCreateContract.prototype.getAccountAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getAccountAddress())
      );
    };
    TronWebProto.AccountCreateContract.prototype.getAccountAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getAccountAddress())
      );
    };
    TronWebProto.AccountCreateContract.prototype.setAccountAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.AccountCreateContract.prototype.getType = function() {
      return (
        /** @type {!TronWebProto.AccountType} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.AccountCreateContract.prototype.setType = function(value) {
      return jspb.Message.setProto3EnumField(this, 3, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.AccountUpdateContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.AccountUpdateContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.AccountUpdateContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          accountName: msg.getAccountName_asB64(),
          ownerAddress: msg.getOwnerAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.AccountUpdateContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.AccountUpdateContract();
      return TronWebProto.AccountUpdateContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.AccountUpdateContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAccountName(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.AccountUpdateContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.AccountUpdateContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.AccountUpdateContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAccountName_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
    };
    TronWebProto.AccountUpdateContract.prototype.getAccountName = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.AccountUpdateContract.prototype.getAccountName_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getAccountName())
      );
    };
    TronWebProto.AccountUpdateContract.prototype.getAccountName_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getAccountName())
      );
    };
    TronWebProto.AccountUpdateContract.prototype.setAccountName = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.AccountUpdateContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.AccountUpdateContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.AccountUpdateContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.AccountUpdateContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.SetAccountIdContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.SetAccountIdContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.SetAccountIdContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          accountId: msg.getAccountId_asB64(),
          ownerAddress: msg.getOwnerAddress_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.SetAccountIdContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.SetAccountIdContract();
      return TronWebProto.SetAccountIdContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.SetAccountIdContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setAccountId(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.SetAccountIdContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.SetAccountIdContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.SetAccountIdContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getAccountId_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(2, f2);
      }
    };
    TronWebProto.SetAccountIdContract.prototype.getAccountId = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.SetAccountIdContract.prototype.getAccountId_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getAccountId())
      );
    };
    TronWebProto.SetAccountIdContract.prototype.getAccountId_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getAccountId())
      );
    };
    TronWebProto.SetAccountIdContract.prototype.setAccountId = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.SetAccountIdContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.SetAccountIdContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.SetAccountIdContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.SetAccountIdContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.AccountPermissionUpdateContract.repeatedFields_ = [4];
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.AccountPermissionUpdateContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.AccountPermissionUpdateContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.AccountPermissionUpdateContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          owner: (f2 = msg.getOwner()) && core_Tron_pb.Permission.toObject(includeInstance, f2),
          witness: (f2 = msg.getWitness()) && core_Tron_pb.Permission.toObject(includeInstance, f2),
          activesList: jspb.Message.toObjectList(msg.getActivesList(), core_Tron_pb.Permission.toObject, includeInstance)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.AccountPermissionUpdateContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.AccountPermissionUpdateContract();
      return TronWebProto.AccountPermissionUpdateContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.AccountPermissionUpdateContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = new core_Tron_pb.Permission();
            reader.readMessage(value, core_Tron_pb.Permission.deserializeBinaryFromReader);
            msg.setOwner(value);
            break;
          case 3:
            var value = new core_Tron_pb.Permission();
            reader.readMessage(value, core_Tron_pb.Permission.deserializeBinaryFromReader);
            msg.setWitness(value);
            break;
          case 4:
            var value = new core_Tron_pb.Permission();
            reader.readMessage(value, core_Tron_pb.Permission.deserializeBinaryFromReader);
            msg.addActives(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.AccountPermissionUpdateContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.AccountPermissionUpdateContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(1, f2);
      }
      f2 = message.getOwner();
      if (f2 != null) {
        writer.writeMessage(2, f2, core_Tron_pb.Permission.serializeBinaryToWriter);
      }
      f2 = message.getWitness();
      if (f2 != null) {
        writer.writeMessage(3, f2, core_Tron_pb.Permission.serializeBinaryToWriter);
      }
      f2 = message.getActivesList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(4, f2, core_Tron_pb.Permission.serializeBinaryToWriter);
      }
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(this.getOwnerAddress())
      );
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(this.getOwnerAddress())
      );
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.getOwner = function() {
      return (
        /** @type{?TronWebProto.Permission} */
        jspb.Message.getWrapperField(this, core_Tron_pb.Permission, 2)
      );
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.setOwner = function(value) {
      return jspb.Message.setWrapperField(this, 2, value);
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.clearOwner = function() {
      return this.setOwner(void 0);
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.hasOwner = function() {
      return jspb.Message.getField(this, 2) != null;
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.getWitness = function() {
      return (
        /** @type{?TronWebProto.Permission} */
        jspb.Message.getWrapperField(this, core_Tron_pb.Permission, 3)
      );
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.setWitness = function(value) {
      return jspb.Message.setWrapperField(this, 3, value);
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.clearWitness = function() {
      return this.setWitness(void 0);
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.hasWitness = function() {
      return jspb.Message.getField(this, 3) != null;
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.getActivesList = function() {
      return (
        /** @type{!Array<!TronWebProto.Permission>} */
        jspb.Message.getRepeatedWrapperField(this, core_Tron_pb.Permission, 4)
      );
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.setActivesList = function(value) {
      return jspb.Message.setRepeatedWrapperField(this, 4, value);
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.addActives = function(opt_value, opt_index) {
      return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, TronWebProto.Permission, opt_index);
    };
    TronWebProto.AccountPermissionUpdateContract.prototype.clearActivesList = function() {
      return this.setActivesList([]);
    };
    goog.object.extend(exports, TronWebProto);
  }
});

// node_modules/tronweb/lib/esm/protocol/core/contract/proposal_contract_pb.cjs
var require_proposal_contract_pb = __commonJS({
  "node_modules/tronweb/lib/esm/protocol/core/contract/proposal_contract_pb.cjs"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    goog.exportSymbol("TronWebProto.ProposalApproveContract", null, global2);
    goog.exportSymbol("TronWebProto.ProposalCreateContract", null, global2);
    goog.exportSymbol("TronWebProto.ProposalDeleteContract", null, global2);
    TronWebProto.ProposalApproveContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.ProposalApproveContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.ProposalApproveContract.displayName = "TronWebProto.ProposalApproveContract";
    }
    TronWebProto.ProposalCreateContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.ProposalCreateContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.ProposalCreateContract.displayName = "TronWebProto.ProposalCreateContract";
    }
    TronWebProto.ProposalDeleteContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.ProposalDeleteContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.ProposalDeleteContract.displayName = "TronWebProto.ProposalDeleteContract";
    }
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.ProposalApproveContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.ProposalApproveContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.ProposalApproveContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          proposalId: jspb.Message.getFieldWithDefault(msg, 2, 0),
          isAddApproval: jspb.Message.getBooleanFieldWithDefault(msg, 3, false)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.ProposalApproveContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.ProposalApproveContract();
      return TronWebProto.ProposalApproveContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.ProposalApproveContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setProposalId(value);
            break;
          case 3:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setIsAddApproval(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.ProposalApproveContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.ProposalApproveContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.ProposalApproveContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getProposalId();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
      f2 = message.getIsAddApproval();
      if (f2) {
        writer.writeBool(
          3,
          f2
        );
      }
    };
    TronWebProto.ProposalApproveContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.ProposalApproveContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ProposalApproveContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ProposalApproveContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.ProposalApproveContract.prototype.getProposalId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.ProposalApproveContract.prototype.setProposalId = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.ProposalApproveContract.prototype.getIsAddApproval = function() {
      return (
        /** @type {boolean} */
        jspb.Message.getBooleanFieldWithDefault(this, 3, false)
      );
    };
    TronWebProto.ProposalApproveContract.prototype.setIsAddApproval = function(value) {
      return jspb.Message.setProto3BooleanField(this, 3, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.ProposalCreateContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.ProposalCreateContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.ProposalCreateContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          parametersMap: (f2 = msg.getParametersMap()) ? f2.toObject(includeInstance, void 0) : []
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.ProposalCreateContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.ProposalCreateContract();
      return TronWebProto.ProposalCreateContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.ProposalCreateContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = msg.getParametersMap();
            reader.readMessage(value, function(message, reader2) {
              jspb.Map.deserializeBinary(message, reader2, jspb.BinaryReader.prototype.readInt64, jspb.BinaryReader.prototype.readInt64, null, 0, 0);
            });
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.ProposalCreateContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.ProposalCreateContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.ProposalCreateContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getParametersMap(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(2, writer, jspb.BinaryWriter.prototype.writeInt64, jspb.BinaryWriter.prototype.writeInt64);
      }
    };
    TronWebProto.ProposalCreateContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.ProposalCreateContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ProposalCreateContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ProposalCreateContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.ProposalCreateContract.prototype.getParametersMap = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<number,number>} */
        jspb.Message.getMapField(
          this,
          2,
          opt_noLazyCreate,
          null
        )
      );
    };
    TronWebProto.ProposalCreateContract.prototype.clearParametersMap = function() {
      this.getParametersMap().clear();
      return this;
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.ProposalDeleteContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.ProposalDeleteContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.ProposalDeleteContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          proposalId: jspb.Message.getFieldWithDefault(msg, 2, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.ProposalDeleteContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.ProposalDeleteContract();
      return TronWebProto.ProposalDeleteContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.ProposalDeleteContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setProposalId(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.ProposalDeleteContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.ProposalDeleteContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.ProposalDeleteContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getProposalId();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
    };
    TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ProposalDeleteContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.ProposalDeleteContract.prototype.getProposalId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.ProposalDeleteContract.prototype.setProposalId = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    goog.object.extend(exports, TronWebProto);
  }
});

// node_modules/tronweb/lib/esm/protocol/core/contract/exchange_contract_pb.cjs
var require_exchange_contract_pb = __commonJS({
  "node_modules/tronweb/lib/esm/protocol/core/contract/exchange_contract_pb.cjs"(exports) {
    var jspb = require_google_protobuf();
    var goog = jspb;
    var global2 = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global2 !== "undefined" && global2 || typeof self !== "undefined" && self || (function() {
      return this;
    }).call(null) || Function("return this")();
    goog.exportSymbol("TronWebProto.ExchangeCreateContract", null, global2);
    goog.exportSymbol("TronWebProto.ExchangeInjectContract", null, global2);
    goog.exportSymbol("TronWebProto.ExchangeTransactionContract", null, global2);
    goog.exportSymbol("TronWebProto.ExchangeWithdrawContract", null, global2);
    TronWebProto.ExchangeCreateContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.ExchangeCreateContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.ExchangeCreateContract.displayName = "TronWebProto.ExchangeCreateContract";
    }
    TronWebProto.ExchangeInjectContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.ExchangeInjectContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.ExchangeInjectContract.displayName = "TronWebProto.ExchangeInjectContract";
    }
    TronWebProto.ExchangeWithdrawContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.ExchangeWithdrawContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.ExchangeWithdrawContract.displayName = "TronWebProto.ExchangeWithdrawContract";
    }
    TronWebProto.ExchangeTransactionContract = function(opt_data) {
      jspb.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(TronWebProto.ExchangeTransactionContract, jspb.Message);
    if (goog.DEBUG && !COMPILED) {
      TronWebProto.ExchangeTransactionContract.displayName = "TronWebProto.ExchangeTransactionContract";
    }
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.ExchangeCreateContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.ExchangeCreateContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.ExchangeCreateContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          firstTokenId: msg.getFirstTokenId_asB64(),
          firstTokenBalance: jspb.Message.getFieldWithDefault(msg, 3, 0),
          secondTokenId: msg.getSecondTokenId_asB64(),
          secondTokenBalance: jspb.Message.getFieldWithDefault(msg, 5, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.ExchangeCreateContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.ExchangeCreateContract();
      return TronWebProto.ExchangeCreateContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.ExchangeCreateContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setFirstTokenId(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setFirstTokenBalance(value);
            break;
          case 4:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setSecondTokenId(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setSecondTokenBalance(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.ExchangeCreateContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.ExchangeCreateContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.ExchangeCreateContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getFirstTokenId_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getFirstTokenBalance();
      if (f2 !== 0) {
        writer.writeInt64(
          3,
          f2
        );
      }
      f2 = message.getSecondTokenId_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          4,
          f2
        );
      }
      f2 = message.getSecondTokenBalance();
      if (f2 !== 0) {
        writer.writeInt64(
          5,
          f2
        );
      }
    };
    TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 2, "")
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getFirstTokenId()
        )
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getFirstTokenId()
        )
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.setFirstTokenId = function(value) {
      return jspb.Message.setProto3BytesField(this, 2, value);
    };
    TronWebProto.ExchangeCreateContract.prototype.getFirstTokenBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.setFirstTokenBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 3, value);
    };
    TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 4, "")
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getSecondTokenId()
        )
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getSecondTokenId()
        )
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.setSecondTokenId = function(value) {
      return jspb.Message.setProto3BytesField(this, 4, value);
    };
    TronWebProto.ExchangeCreateContract.prototype.getSecondTokenBalance = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.ExchangeCreateContract.prototype.setSecondTokenBalance = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.ExchangeInjectContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.ExchangeInjectContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.ExchangeInjectContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          exchangeId: jspb.Message.getFieldWithDefault(msg, 2, 0),
          tokenId: msg.getTokenId_asB64(),
          quant: jspb.Message.getFieldWithDefault(msg, 4, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.ExchangeInjectContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.ExchangeInjectContract();
      return TronWebProto.ExchangeInjectContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.ExchangeInjectContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExchangeId(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setTokenId(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setQuant(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.ExchangeInjectContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.ExchangeInjectContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.ExchangeInjectContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getExchangeId();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
      f2 = message.getTokenId_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getQuant();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
    };
    TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ExchangeInjectContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.ExchangeInjectContract.prototype.getExchangeId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.ExchangeInjectContract.prototype.setExchangeId = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.ExchangeInjectContract.prototype.getTokenId = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.ExchangeInjectContract.prototype.getTokenId_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getTokenId()
        )
      );
    };
    TronWebProto.ExchangeInjectContract.prototype.getTokenId_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getTokenId()
        )
      );
    };
    TronWebProto.ExchangeInjectContract.prototype.setTokenId = function(value) {
      return jspb.Message.setProto3BytesField(this, 3, value);
    };
    TronWebProto.ExchangeInjectContract.prototype.getQuant = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.ExchangeInjectContract.prototype.setQuant = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.ExchangeWithdrawContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.ExchangeWithdrawContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.ExchangeWithdrawContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          exchangeId: jspb.Message.getFieldWithDefault(msg, 2, 0),
          tokenId: msg.getTokenId_asB64(),
          quant: jspb.Message.getFieldWithDefault(msg, 4, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.ExchangeWithdrawContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.ExchangeWithdrawContract();
      return TronWebProto.ExchangeWithdrawContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.ExchangeWithdrawContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExchangeId(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setTokenId(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setQuant(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.ExchangeWithdrawContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.ExchangeWithdrawContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.ExchangeWithdrawContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getExchangeId();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
      f2 = message.getTokenId_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getQuant();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
    };
    TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ExchangeWithdrawContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.ExchangeWithdrawContract.prototype.getExchangeId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.ExchangeWithdrawContract.prototype.setExchangeId = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.ExchangeWithdrawContract.prototype.getTokenId = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.ExchangeWithdrawContract.prototype.getTokenId_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getTokenId()
        )
      );
    };
    TronWebProto.ExchangeWithdrawContract.prototype.getTokenId_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getTokenId()
        )
      );
    };
    TronWebProto.ExchangeWithdrawContract.prototype.setTokenId = function(value) {
      return jspb.Message.setProto3BytesField(this, 3, value);
    };
    TronWebProto.ExchangeWithdrawContract.prototype.getQuant = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.ExchangeWithdrawContract.prototype.setQuant = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    if (jspb.Message.GENERATE_TO_OBJECT) {
      TronWebProto.ExchangeTransactionContract.prototype.toObject = function(opt_includeInstance) {
        return TronWebProto.ExchangeTransactionContract.toObject(opt_includeInstance, this);
      };
      TronWebProto.ExchangeTransactionContract.toObject = function(includeInstance, msg) {
        var f2, obj = {
          ownerAddress: msg.getOwnerAddress_asB64(),
          exchangeId: jspb.Message.getFieldWithDefault(msg, 2, 0),
          tokenId: msg.getTokenId_asB64(),
          quant: jspb.Message.getFieldWithDefault(msg, 4, 0),
          expected: jspb.Message.getFieldWithDefault(msg, 5, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    TronWebProto.ExchangeTransactionContract.deserializeBinary = function(bytes3) {
      var reader = new jspb.BinaryReader(bytes3);
      var msg = new TronWebProto.ExchangeTransactionContract();
      return TronWebProto.ExchangeTransactionContract.deserializeBinaryFromReader(msg, reader);
    };
    TronWebProto.ExchangeTransactionContract.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setOwnerAddress(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExchangeId(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setTokenId(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setQuant(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setExpected(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    TronWebProto.ExchangeTransactionContract.prototype.serializeBinary = function() {
      var writer = new jspb.BinaryWriter();
      TronWebProto.ExchangeTransactionContract.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    TronWebProto.ExchangeTransactionContract.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOwnerAddress_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getExchangeId();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
      f2 = message.getTokenId_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getQuant();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
      f2 = message.getExpected();
      if (f2 !== 0) {
        writer.writeInt64(
          5,
          f2
        );
      }
    };
    TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 1, "")
      );
    };
    TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getOwnerAddress()
        )
      );
    };
    TronWebProto.ExchangeTransactionContract.prototype.setOwnerAddress = function(value) {
      return jspb.Message.setProto3BytesField(this, 1, value);
    };
    TronWebProto.ExchangeTransactionContract.prototype.getExchangeId = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    TronWebProto.ExchangeTransactionContract.prototype.setExchangeId = function(value) {
      return jspb.Message.setProto3IntField(this, 2, value);
    };
    TronWebProto.ExchangeTransactionContract.prototype.getTokenId = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb.Message.getFieldWithDefault(this, 3, "")
      );
    };
    TronWebProto.ExchangeTransactionContract.prototype.getTokenId_asB64 = function() {
      return (
        /** @type {string} */
        jspb.Message.bytesAsB64(
          this.getTokenId()
        )
      );
    };
    TronWebProto.ExchangeTransactionContract.prototype.getTokenId_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb.Message.bytesAsU8(
          this.getTokenId()
        )
      );
    };
    TronWebProto.ExchangeTransactionContract.prototype.setTokenId = function(value) {
      return jspb.Message.setProto3BytesField(this, 3, value);
    };
    TronWebProto.ExchangeTransactionContract.prototype.getQuant = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    TronWebProto.ExchangeTransactionContract.prototype.setQuant = function(value) {
      return jspb.Message.setProto3IntField(this, 4, value);
    };
    TronWebProto.ExchangeTransactionContract.prototype.getExpected = function() {
      return (
        /** @type {number} */
        jspb.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    TronWebProto.ExchangeTransactionContract.prototype.setExpected = function(value) {
      return jspb.Message.setProto3IntField(this, 5, value);
    };
    goog.object.extend(exports, TronWebProto);
  }
});

// node_modules/tronweb/lib/esm/utils/accounts.js
var accounts_exports = {};
__export(accounts_exports, {
  generateAccount: () => generateAccount,
  generateAccountWithMnemonic: () => generateAccountWithMnemonic,
  generateRandom: () => generateRandom
});

// node_modules/tronweb/lib/esm/utils/bytes.js
var bytes_exports = {};
__export(bytes_exports, {
  base64DecodeFromString: () => base64DecodeFromString,
  base64EncodeToString: () => base64EncodeToString,
  byte2hexStr: () => byte2hexStr,
  byteArray2hexStr: () => byteArray2hexStr,
  bytesToString: () => bytesToString,
  hextoString: () => hextoString
});

// node_modules/tronweb/lib/esm/utils/base64.js
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var Base64 = class {
  encode(input) {
    let output3 = "";
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2))
        enc3 = enc4 = 64;
      else if (isNaN(chr3))
        enc4 = 64;
      output3 = output3 + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
    }
    return output3;
  }
  encodeIgnoreUtf8(inputBytes) {
    let output3 = "";
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    while (i < inputBytes.length) {
      chr1 = inputBytes[i++];
      chr2 = inputBytes[i++];
      chr3 = inputBytes[i++];
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2))
        enc3 = enc4 = 64;
      else if (isNaN(chr3))
        enc4 = 64;
      output3 = output3 + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
    }
    return output3;
  }
  decode(input) {
    let output3 = "";
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output3 = output3 + String.fromCharCode(chr1);
      if (enc3 != 64)
        output3 = output3 + String.fromCharCode(chr2);
      if (enc4 != 64)
        output3 = output3 + String.fromCharCode(chr3);
    }
    return this._utf8_decode(output3);
  }
  decodeToByteArray(input) {
    let output3 = "";
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output3 = output3 + String.fromCharCode(chr1);
      if (enc3 != 64)
        output3 = output3 + String.fromCharCode(chr2);
      if (enc4 != 64)
        output3 = output3 + String.fromCharCode(chr3);
    }
    return this._out2ByteArray(output3);
  }
  _out2ByteArray(utftext) {
    const byteArray = new Array(utftext.length);
    let i = 0;
    let c = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      byteArray[i] = c;
      i++;
    }
    return byteArray;
  }
  _utf8_encode(string) {
    string = string.replace(/\r\n/g, "\n");
    let utftext = "";
    for (let n2 = 0; n2 < string.length; n2++) {
      const c = string.charCodeAt(n2);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  }
  _utf8_decode(utftext) {
    let string = "";
    let i = 0;
    let c = 0;
    let c2 = 0;
    let c3 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      } else if (c > 191 && c < 224) {
        c2 = utftext.charCodeAt(i + 1);
        string += String.fromCharCode((c & 31) << 6 | c2 & 63);
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        i += 3;
      }
    }
    return string;
  }
};

// node_modules/tronweb/lib/esm/utils/bytes.js
function byte2hexStr(byte) {
  if (byte < 0 || byte > 255)
    throw new Error("Input must be a byte");
  const hexByteMap = "0123456789ABCDEF";
  let str = "";
  str += hexByteMap.charAt(byte >> 4);
  str += hexByteMap.charAt(byte & 15);
  return str;
}
function bytesToString(arr) {
  let str = "";
  for (let i = 0; i < arr.length; i++) {
    const one = arr[i].toString(2);
    const v = one.match(/^1+?(?=0)/);
    if (v && one.length === 8) {
      const bytesLength = v[0].length;
      let store = arr[i].toString(2).slice(7 - bytesLength);
      for (let st = 1; st < bytesLength; st++)
        store += arr[st + i].toString(2).slice(2);
      str += String.fromCharCode(parseInt(store, 2));
      i += bytesLength - 1;
    } else {
      str += String.fromCharCode(arr[i]);
    }
  }
  return str;
}
function hextoString(hex) {
  const arr = hex.replace(/^0x/, "").split("");
  let out = "";
  for (let i = 0; i < arr.length / 2; i++) {
    const tmp = `0x${arr[i * 2]}${arr[i * 2 + 1]}`;
    out += String.fromCharCode(parseInt(tmp));
  }
  return out;
}
function byteArray2hexStr(byteArray) {
  let str = "";
  for (let i = 0; i < byteArray.length; i++)
    str += byte2hexStr(byteArray[i]);
  return str;
}
function base64DecodeFromString(string64) {
  return new Base64().decodeToByteArray(string64);
}
function base64EncodeToString(bytes3) {
  const b2 = new Base64();
  const string64 = b2.encodeIgnoreUtf8(bytes3);
  return string64;
}

// node_modules/tronweb/lib/esm/utils/crypto.js
var crypto_exports = {};
__export(crypto_exports, {
  ECKeySign: () => ECKeySign,
  SHA256: () => SHA2563,
  _signTypedData: () => _signTypedData,
  arrayToBase64String: () => arrayToBase64String,
  computeAddress: () => computeAddress2,
  decode58Check: () => decode58Check,
  decodeBase58Address: () => decodeBase58Address,
  ecRecover: () => ecRecover,
  genPriKey: () => genPriKey,
  getAddressFromPriKey: () => getAddressFromPriKey,
  getAddressFromPriKeyBase64String: () => getAddressFromPriKeyBase64String,
  getBase58CheckAddress: () => getBase58CheckAddress,
  getBase58CheckAddressFromPriKeyBase64String: () => getBase58CheckAddressFromPriKeyBase64String,
  getHexStrAddressFromPriKeyBase64String: () => getHexStrAddressFromPriKeyBase64String,
  getPubKeyFromPriKey: () => getPubKeyFromPriKey,
  getRowBytesFromTransactionBase64: () => getRowBytesFromTransactionBase64,
  isAddressValid: () => isAddressValid,
  passwordToAddress: () => passwordToAddress,
  pkToAddress: () => pkToAddress,
  sha3: () => sha32,
  signBytes: () => signBytes,
  signTransaction: () => signTransaction
});

// node_modules/tronweb/lib/esm/utils/address.js
var address_exports = {};
__export(address_exports, {
  ADDRESS_PREFIX: () => ADDRESS_PREFIX,
  ADDRESS_PREFIX_BYTE: () => ADDRESS_PREFIX_BYTE,
  ADDRESS_PREFIX_REGEX: () => ADDRESS_PREFIX_REGEX,
  ADDRESS_SIZE: () => ADDRESS_SIZE,
  TRON_BIP39_PATH_INDEX_0: () => TRON_BIP39_PATH_INDEX_0,
  TRON_BIP39_PATH_PREFIX: () => TRON_BIP39_PATH_PREFIX,
  fromHex: () => fromHex,
  fromPrivateKey: () => fromPrivateKey,
  isAddress: () => isAddress2,
  isChecksumAddress: () => isChecksumAddress,
  toChecksumAddress: () => toChecksumAddress,
  toHex: () => toHex
});

// node_modules/tronweb/lib/esm/utils/code.js
var code_exports = {};
__export(code_exports, {
  arrayEquals: () => arrayEquals,
  base64DecodeFromString: () => base64DecodeFromString,
  base64EncodeToString: () => base64EncodeToString,
  bin2String: () => bin2String,
  byte2hexStr: () => byte2hexStr,
  byteArray2hexStr: () => byteArray2hexStr,
  bytesToString: () => bytesToString,
  getStringType: () => getStringType,
  hexChar2byte: () => hexChar2byte,
  hexStr2byteArray: () => hexStr2byteArray,
  hextoString: () => hextoString,
  isHexChar: () => isHexChar,
  isNumber: () => isNumber,
  strToDate: () => strToDate,
  stringToBytes: () => stringToBytes
});
function bin2String(array) {
  return bytesToString(array);
}
function arrayEquals(array1, array2, strict = false) {
  if (array1.length != array2.length)
    return false;
  for (let i = 0; i < array1.length; i++) {
    if (strict) {
      if (array1[i] != array2[i])
        return false;
    } else if (JSON.stringify(array1[i]) != JSON.stringify(array2[i]))
      return false;
  }
  return true;
}
function stringToBytes(str) {
  const bytes3 = [];
  const len = str.length;
  let c;
  for (let i = 0; i < len; i++) {
    c = str.charCodeAt(i);
    if (c >= 65536 && c <= 1114111) {
      bytes3.push(c >> 18 & 7 | 240);
      bytes3.push(c >> 12 & 63 | 128);
      bytes3.push(c >> 6 & 63 | 128);
      bytes3.push(c & 63 | 128);
    } else if (c >= 2048 && c <= 65535) {
      bytes3.push(c >> 12 & 15 | 224);
      bytes3.push(c >> 6 & 63 | 128);
      bytes3.push(c & 63 | 128);
    } else if (c >= 128 && c <= 2047) {
      bytes3.push(c >> 6 & 31 | 192);
      bytes3.push(c & 63 | 128);
    } else
      bytes3.push(c & 255);
  }
  return bytes3;
}
function hexChar2byte(c) {
  let d;
  if (c >= "A" && c <= "F")
    d = c.charCodeAt(0) - "A".charCodeAt(0) + 10;
  else if (c >= "a" && c <= "f")
    d = c.charCodeAt(0) - "a".charCodeAt(0) + 10;
  else if (c >= "0" && c <= "9")
    d = c.charCodeAt(0) - "0".charCodeAt(0);
  if (typeof d === "number")
    return d;
  else
    throw new Error("The passed hex char is not a valid hex char");
}
function isHexChar(c) {
  if (c >= "A" && c <= "F" || c >= "a" && c <= "f" || c >= "0" && c <= "9") {
    return 1;
  }
  return 0;
}
function hexStr2byteArray(str, strict = false) {
  let len = str.length;
  if (strict) {
    if (len % 2) {
      str = `0${str}`;
      len++;
    }
  }
  const byteArray = [];
  let d = 0;
  let j = 0;
  let k = 0;
  for (let i = 0; i < len; i++) {
    const c = str.charAt(i);
    if (isHexChar(c)) {
      d <<= 4;
      d += hexChar2byte(c);
      j++;
      if (0 === j % 2) {
        byteArray[k++] = d;
        d = 0;
      }
    } else
      throw new Error("The passed hex char is not a valid hex string");
  }
  return byteArray;
}
function strToDate(str) {
  if (!/^\d{4}-\d{2}-\d{2}( \d{2}-\d{2}-\d{2}|)/.test(str))
    throw new Error("The passed date string is not valid");
  const tempStrs = str.split(" ");
  const dateStrs = tempStrs[0].split("-");
  const year = parseInt(dateStrs[0], 10);
  const month = parseInt(dateStrs[1], 10) - 1;
  const day = parseInt(dateStrs[2], 10);
  if (tempStrs.length > 1) {
    const timeStrs = tempStrs[1].split("-");
    const hour = parseInt(timeStrs[0], 10);
    const minute = parseInt(timeStrs[1], 10);
    const second = parseInt(timeStrs[2], 10);
    return new Date(year, month, day, hour, minute, second);
  }
  return new Date(year, month, day);
}
function isNumber(c) {
  if (c >= "0" && c <= "9")
    return 1;
  return 0;
}
function getStringType(str) {
  if (null == str)
    return -1;
  if (str.length == 0 || str == "")
    return -1;
  let i = 0;
  if (str.length == 40) {
    for (; i < 40; i++) {
      const c = str.charAt(i);
      if (!isHexChar(c))
        break;
    }
  }
  if (i == 40)
    return 1;
  for (i = 0; i < str.length; i++) {
    const c = str.charAt(i);
    if (!isNumber(c))
      break;
  }
  if (i == str.length)
    return 2;
  for (i = 0; i < str.length; i++) {
    const c = str.charAt(i);
    if (c > " ")
      return 3;
  }
  return -1;
}

// node_modules/tronweb/lib/esm/utils/validations.js
var validations_exports = {};
__export(validations_exports, {
  hasProperties: () => hasProperties,
  hasProperty: () => hasProperty,
  isArray: () => isArray,
  isBigNumber: () => isBigNumber,
  isBoolean: () => isBoolean,
  isFunction: () => isFunction,
  isHex: () => isHex,
  isInteger: () => isInteger,
  isJson: () => isJson,
  isNotNullOrUndefined: () => isNotNullOrUndefined,
  isObject: () => isObject,
  isString: () => isString,
  isValidURL: () => isValidURL,
  mapEvent: () => mapEvent,
  padLeft: () => padLeft,
  parseEvent: () => parseEvent,
  sleep: () => sleep
});

// node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b2) {
    var alphabet, c, caseChanged, e, i, isNum2, len, str, x = this;
    if (!(x instanceof BigNumber2)) return new BigNumber2(v, b2);
    if (b2 == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum2 = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++) ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum2);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b2, 2, ALPHABET2.length, "Base");
      if (b2 == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum2 = typeof v == "number") {
        if (v * 0 != 0) return parseNumeric(x, str, isNum2, b2);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET2.slice(0, b2);
      e = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum2, b2);
        }
      }
      isNum2 = false;
      str = convertBase(str, b2, 10, x.s);
      if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
      else e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++) ;
    for (len = str.length; str.charCodeAt(--len) === 48; ) ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum2 && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;
        if (i < len) {
          if (i) x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0") ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object") FORMAT = v;
          else throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET2 = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET: ALPHABET2
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber2.DEBUG) return true;
    var i, n2, c = v.c, e = v.e, s = v.s;
    out: if ({}.toString.call(c) == "[object Array]") {
      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        }
        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE;
        if (String(c[0]).length == i) {
          for (i = 0; i < c.length; i++) {
            n2 = c[i];
            if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2)) break out;
          }
          if (n2 !== 0) return true;
        }
      }
    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b2, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b2 = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b2[0];
              a[i + 1] = b2[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--) ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
        if (i < LOG_BASE) e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i < args.length; ) sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = /* @__PURE__ */ function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET2, decimal) : (alphabet = decimal, ALPHABET2));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop()) ;
      if (!xc[0]) return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; ) ;
        for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = /* @__PURE__ */ function() {
    function multiply(x, k, base) {
      var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry) x = [carry].concat(x);
      return x;
    }
    function compare2(a, b2, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b2[i]) {
            cmp = a[i] > b2[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b2, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b2[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b2[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e, i, more, n2, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++) ;
      if (yc[i] > (xc[i] || 0)) e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n2 = mathfloor(base / (yc[0] + 1));
        if (n2 > 1) {
          yc = multiply(yc, n2, base);
          xc = multiply(xc, n2, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0) ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++;
        do {
          n2 = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
            n2 = mathfloor(rem0 / yc0);
            if (n2 > 1) {
              if (n2 >= base) n2 = base - 1;
              prod = multiply(yc, n2, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n2--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n2 == 0) {
                cmp = n2 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n2++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n2++;
            rem = [0];
          }
          qc[i++] = n2;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0]) qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n2, i, rm, id2) {
    var c0, e, ne, len, str;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n2.c) return n2.toString();
    c0 = n2.c[0];
    ne = n2.e;
    if (i == null) {
      str = coeffToString(n2.c);
      str = id2 == 1 || id2 == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n2 = round(new BigNumber2(n2), i, rm);
      e = n2.e;
      str = coeffToString(n2.c);
      len = str.length;
      if (id2 == 1 || id2 == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++) ;
        str = toExponential(str, e);
      } else {
        i -= ne;
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i > 0) for (str += "."; i--; str += "0") ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len) str += ".";
            for (; i--; str += "0") ;
          }
        }
      }
    }
    return n2.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n2) {
    var k, y, i = 1, x = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      y = new BigNumber2(args[i]);
      if (!y.s || (k = compare(x, y)) === n2 || k === 0 && x.s === n2) {
        x = y;
      }
    }
    return x;
  }
  function normalise(n2, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop()) ;
    for (j = c[0]; j >= 10; j /= 10, i++) ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n2.c = n2.e = null;
    } else if (e < MIN_EXP) {
      n2.c = [n2.e = 0];
    } else {
      n2.e = e;
      n2.c = c;
    }
    return n2;
  }
  parseNumeric = /* @__PURE__ */ function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum2, b2) {
      var base, s = isNum2 ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum2) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b2 || b2 == base ? p1 : m;
          });
          if (b2) {
            base = b2;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s) return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round(x, sd, rm, r) {
    var d, i, j, k, n2, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n2 = xc[ni = 0];
          rd = mathfloor(n2 / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0)) ;
              n2 = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n2 = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++) ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : mathfloor(n2 / pows10[d - j - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n2 : n2 % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n2 / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n2 / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++) ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop()) ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n2) {
    var str, e = n2.e;
    if (e === null) return n2.toString();
    str = coeffToString(n2.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n2.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0) x.s = 1;
    return x;
  };
  P.comparedTo = function(y, b2) {
    return compare(this, new BigNumber2(y, b2));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n2, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c)) return null;
    n2 = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v]) for (; v % 10 == 0; v /= 10, n2--) ;
    if (n2 < 0) n2 = 0;
    return n2;
  };
  P.dividedBy = P.div = function(y, b2) {
    return div(this, new BigNumber2(y, b2), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b2) {
    return div(this, new BigNumber2(y, b2), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n2, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n2 = new BigNumber2(n2);
    if (n2.c && !n2.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
    }
    if (m != null) m = new BigNumber2(m);
    nIsBig = n2.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n2.c || !n2.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n2.s * (2 - isOdd(n2)) : +valueOf(n2)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n2.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp) x = x.mod(m);
    } else if (n2.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n2) ? -0 : 0;
      if (x.e > -1) k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg) n2.s = 1;
      nIsOdd = isOdd(n2);
    } else {
      i = Math.abs(+valueOf(n2));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;
        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n2 = n2.times(half);
        round(n2, n2.e + 1, 1);
        if (n2.e > 14) {
          nIsOdd = isOdd(n2);
        } else {
          i = +valueOf(n2);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n2 = new BigNumber2(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n2, n2.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b2) {
    return compare(this, new BigNumber2(y, b2)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b2) {
    return compare(this, new BigNumber2(y, b2)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b2) {
    return (b2 = compare(this, new BigNumber2(y, b2))) === 1 || b2 === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b2) {
    return compare(this, new BigNumber2(y, b2)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b2) {
    return (b2 = compare(this, new BigNumber2(y, b2))) === -1 || b2 === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b2) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b2);
    b2 = y.s;
    if (!a || !b2) return new BigNumber2(NaN);
    if (a != b2) {
      y.s = -b2;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return xc ? (y.s = -b2, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b2, y) : new BigNumber2(xc[0] ? x : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b2 = a; b2--; t.push(0)) ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b2 = yc.length)) ? a : b2;
      for (a = b2 = 0; b2 < j; b2++) {
        if (xc[b2] != yc[b2]) {
          xLTy = xc[b2] < yc[b2];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    b2 = (j = yc.length) - (i = xc.length);
    if (b2 > 0) for (; b2--; xc[i++] = 0) ;
    b2 = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b2) ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function(y, b2) {
    var q, s, x = this;
    y = new BigNumber2(y, b2);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b2) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b2)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y, b2) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b2);
    b2 = y.s;
    if (!a || !b2) return new BigNumber2(NaN);
    if (a != b2) {
      y.s = -b2;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0)) ;
      t.reverse();
    }
    a = xc.length;
    b2 = yc.length;
    if (a - b2 < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b2 = a;
    }
    for (a = 0; b2; ) {
      a = (xc[--b2] = xc[b2] + yc[b2] + a) / BASE | 0;
      xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n2, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c)) return null;
    v = c.length - 1;
    n2 = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n2--) ;
      for (v = c[0]; v >= 10; v /= 10, n2++) ;
    }
    if (sd && x.e + 1 > n2) n2 = x.e + 1;
    return n2;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n2, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n2 = coeffToString(c);
      if ((n2.length + e) % 2 == 0) n2 += "0";
      s = Math.sqrt(+n2);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n2 = "5e" + e;
      } else {
        n2 = s.toExponential();
        n2 = n2.slice(0, n2.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n2);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n2 = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e) --s;
          n2 = n2.slice(s - 3, s + 1);
          if (n2 == "9999" || !rep && n2 == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P.toFraction = function(md) {
    var d, d0, d1, d2, e, exp, n2, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n2 = new BigNumber2(md);
      if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
      }
    }
    if (!xc) return new BigNumber2(x);
    d = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n2.comparedTo(d) > 0 ? e > 0 ? d : n1 : n2;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n2 = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n2, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n2.minus(q.times(d2 = d));
      n2 = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function(b2) {
    var str, n2 = this, s = n2.s, e = n2.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0) str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b2 == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e) : toFixedPoint(coeffToString(n2.c), e, "0");
      } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
        n2 = round(new BigNumber2(n2), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
      } else {
        intCheck(b2, 2, ALPHABET2.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n2.c), e, "0"), 10, b2, s, true);
      }
      if (s < 0 && n2.c[0]) str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null) BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n2) {
  var i = n2 | 0;
  return n2 > 0 || n2 === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z = LOG_BASE - s.length;
    for (; z--; s = "0" + s) ;
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; ) ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b2, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j) return null;
  a = xc && !xc[0];
  b2 = yc && !yc[0];
  if (a || b2) return a ? b2 ? 0 : -j : i;
  if (i != j) return i;
  a = i < 0;
  b2 = k == l;
  if (!xc || !yc) return b2 ? 0 : !xc ^ a ? 1 : -1;
  if (!b2) return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n2, min, max, name) {
  if (n2 < min || n2 > max || n2 !== mathfloor(n2)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min || n2 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
  }
}
function isOdd(n2) {
  var k = n2.c.length - 1;
  return bitFloor(n2.e / LOG_BASE) == k && n2.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z) {
  var len, zs;
  if (e < 0) {
    for (zs = z + "."; ++e; zs += z) ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z) ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone();

// node_modules/tronweb/lib/esm/utils/validations.js
var import_validator = __toESM(require_validator(), 1);
function isValidURL(url) {
  if (typeof url !== "string")
    return false;
  return import_validator.default.isURL(url.toString(), {
    protocols: ["http", "https"],
    require_tld: false
  });
}
function isObject(obj) {
  return obj === Object(obj) && Object.prototype.toString.call(obj) !== "[object Array]";
}
function isArray(array) {
  return Array.isArray(array);
}
function isJson(string) {
  try {
    return !!JSON.parse(string);
  } catch (ex) {
    return false;
  }
}
function isBoolean(bool) {
  return typeof bool === "boolean";
}
function isBigNumber(number3) {
  return !!number3 && (number3 instanceof BigNumber || number3.constructor && number3.constructor.name === "BigNumber");
}
function isString(string) {
  return typeof string === "string" || !!string && string.constructor && string.constructor.name === "String";
}
function isFunction(obj) {
  return typeof obj === "function";
}
function isHex(string) {
  return typeof string === "string" && !isNaN(parseInt(string, 16)) && /^(0x|)[a-fA-F0-9]+$/.test(string);
}
function isInteger(number3) {
  if (number3 === null)
    return false;
  return Number.isInteger(Number(number3));
}
function hasProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}
function hasProperties(obj, ...properties) {
  return properties.length && !properties.map((property) => {
    return hasProperty(obj, property);
  }).includes(false);
}
function mapEvent(event) {
  const data = {
    block: event.block_number,
    timestamp: event.block_timestamp,
    contract: event.contract_address,
    name: event.event_name,
    transaction: event.transaction_id,
    result: event.result,
    resourceNode: event.resource_Node || (event._unconfirmed ? "fullNode" : "solidityNode")
  };
  if (event._unconfirmed) {
    data.unconfirmed = event._unconfirmed;
  }
  if (event._fingerprint) {
    data.fingerprint = event._fingerprint;
  }
  return data;
}
function parseEvent(event, { inputs: abi }) {
  if (!event.result)
    return event;
  if (isObject(event.result)) {
    for (let i = 0; i < abi.length; i++) {
      const obj = abi[i];
      if (obj.type == "address" && obj.name in event.result)
        event.result[obj.name] = ADDRESS_PREFIX + event.result[obj.name].substr(2).toLowerCase();
    }
  } else if (isArray(event.result)) {
    event.result = event.result.reduce((obj, result, index) => {
      const { name, type } = abi[index];
      if (type == "address")
        result = ADDRESS_PREFIX + result.substr(2).toLowerCase();
      obj[name] = result;
      return obj;
    }, {});
  }
  return event;
}
function padLeft(input, padding3, amount) {
  let res = input.toString();
  while (res.length < amount)
    res = padding3 + res;
  return res;
}
function isNotNullOrUndefined(val) {
  return val !== null && typeof val !== "undefined";
}
async function sleep(millis = 1e3) {
  return new Promise((resolve) => setTimeout(resolve, millis));
}

// node_modules/tronweb/lib/esm/utils/ethersUtils.js
var ethersUtils_exports = {};
__export(ethersUtils_exports, {
  AbiCoder: () => AbiCoder,
  FormatTypes: () => FormatTypes,
  Interface: () => Interface2,
  Mnemonic: () => Mnemonic,
  Signature: () => Signature,
  SigningKey: () => SigningKey,
  Wordlist: () => Wordlist,
  arrayify: () => arrayify,
  concat: () => concat,
  ethersHDNodeWallet: () => HDNodeWallet,
  id: () => id,
  isValidMnemonic: () => isValidMnemonic,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  recoverAddress: () => recoverAddress,
  sha256: () => sha2562,
  splitSignature: () => splitSignature,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8String: () => toUtf8String,
  wordlists: () => wordlists
});

// node_modules/tronweb/node_modules/ethers/lib.esm/_version.js
var version = "6.13.5";

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/properties.js
function checkType(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v, index) => {
    accum[keys[index]] = v;
    return accum;
  }, {});
}
function defineProperties(target, values, types) {
  for (let key in values) {
    let value = values[key];
    const type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/errors.js
function stringify(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code) {
  return error && error.code === code;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/data.js
function _getBytes(value, name, copy) {
  if (value instanceof Uint8Array) {
    if (copy) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
var HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes3 = getBytes(data);
  let result = "0x";
  for (let i = 0; i < bytes3.length; i++) {
    const v = bytes3[i];
    result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes3 = getBytes(data);
  if (end != null && end > bytes3.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes3,
      length: bytes3.length,
      offset: end
    });
  }
  return hexlify(bytes3.slice(start == null ? 0 : start, end == null ? bytes3.length : end));
}
function zeroPad(data, length, left) {
  const bytes3 = getBytes(data);
  assert(length >= bytes3.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes3),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes3, length - bytes3.length);
  } else {
    result.set(bytes3, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/maths.js
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var maxValue = 9007199254740991;
function fromTwos(_value2, _width) {
  const value = getUint(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value2
  });
  if (value >> width - BN_1) {
    const mask2 = (BN_1 << width) - BN_1;
    return -((~value & mask2) + BN_1);
  }
  return value;
}
function toTwos(_value2, _width) {
  let value = getBigInt(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1 << width - BN_1;
  if (value < BN_0) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
    const mask2 = (BN_1 << width) - BN_1;
    return (~value & mask2) + BN_1;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
  }
  return value;
}
function mask(_value2, _bits) {
  const value = getUint(_value2, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1 << bits) - BN_1;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
var Nibbles = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles[v >> 4];
      result += Nibbles[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e) {
        assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value2, _width) {
  const value = getUint(_value2, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value2
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value2) {
  const value = getUint(_value2, "value");
  if (value === BN_0) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/base58.js
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
var BN_02 = BigInt(0);
var BN_58 = BigInt(58);
function encodeBase58(_value2) {
  const bytes3 = getBytes(_value2);
  let value = toBigInt(bytes3);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0; i < bytes3.length; i++) {
    if (bytes3[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_02;
  for (let i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/base64-browser.js
function decodeBase64(textData) {
  textData = atob(textData);
  const data = new Uint8Array(textData.length);
  for (let i = 0; i < textData.length; i++) {
    data[i] = textData.charCodeAt(i);
  }
  return getBytes(data);
}
function encodeBase64(_data5) {
  const data = getBytes(_data5);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/events.js
var _listener;
var EventPayload = class {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter2) {
    /**
     *  The event filter.
     */
    __publicField(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    __publicField(this, "emitter");
    __privateAdd(this, _listener);
    __privateSet(this, _listener, listener);
    defineProperties(this, { emitter, filter: filter2 });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (__privateGet(this, _listener) == null) {
      return;
    }
    await this.emitter.off(this.filter, __privateGet(this, _listener));
  }
};
_listener = new WeakMap();

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/utf8.js
function errorFunc(reason, offset, bytes3, output3, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes3);
}
function ignoreFunc(reason, offset, bytes3, output3, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1; o < bytes3.length; o++) {
      if (bytes3[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes3.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes3, output3, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output3.push(badCodepoint);
    return 0;
  }
  output3.push(65533);
  return ignoreFunc(reason, offset, bytes3, output3, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes3 = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes3.length) {
    const c = bytes3[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes3, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes3, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes3.length) {
      i += onError("OVERRUN", i - 1, bytes3, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes3[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes3, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes3, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes3, onError));
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/geturl-browser.js
function createGetUrl(options) {
  async function getUrl(req, _signal2) {
    assert(_signal2 == null || !_signal2.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let error = null;
    const controller = new AbortController();
    const timer = setTimeout(() => {
      error = makeError("request timeout", "TIMEOUT");
      controller.abort();
    }, req.timeout);
    if (_signal2) {
      _signal2.addListener(() => {
        error = makeError("request cancelled", "CANCELLED");
        controller.abort();
      });
    }
    const init = {
      method: req.method,
      headers: new Headers(Array.from(req)),
      body: req.body || void 0,
      signal: controller.signal
    };
    let resp;
    try {
      resp = await fetch(req.url, init);
    } catch (_error2) {
      clearTimeout(timer);
      if (error) {
        throw error;
      }
      throw _error2;
    }
    clearTimeout(timer);
    const headers = {};
    resp.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value;
    });
    const respBody = await resp.arrayBuffer();
    const body = respBody == null ? null : new Uint8Array(respBody);
    return {
      statusCode: resp.status,
      statusMessage: resp.statusText,
      headers,
      body
    };
  }
  return getUrl;
}
var defaultGetUrl = createGetUrl({});

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/fetch.js
var MAX_ATTEMPTS = 12;
var SLOT_INTERVAL = 250;
var defaultGetUrlFunc = createGetUrl();
var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
var reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
var locked = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
var Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
var fetchSignals = /* @__PURE__ */ new WeakMap();
var _listeners, _cancelled;
var FetchCancelSignal = class {
  constructor(request) {
    __privateAdd(this, _listeners);
    __privateAdd(this, _cancelled);
    __privateSet(this, _listeners, []);
    __privateSet(this, _cancelled, false);
    fetchSignals.set(request, () => {
      if (__privateGet(this, _cancelled)) {
        return;
      }
      __privateSet(this, _cancelled, true);
      for (const listener of __privateGet(this, _listeners)) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      __privateSet(this, _listeners, []);
    });
  }
  addListener(listener) {
    assert(!__privateGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    __privateGet(this, _listeners).push(listener);
  }
  get cancelled() {
    return __privateGet(this, _cancelled);
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
};
_listeners = new WeakMap();
_cancelled = new WeakMap();
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
var _allowInsecure, _gzip, _headers, _method, _timeout, _url, _body, _bodyType, _creds, _preflight, _process, _retry, _signal, _throttle, _getUrlFunc, _FetchRequest_instances, send_fn;
var _FetchRequest = class _FetchRequest {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    __privateAdd(this, _FetchRequest_instances);
    __privateAdd(this, _allowInsecure);
    __privateAdd(this, _gzip);
    __privateAdd(this, _headers);
    __privateAdd(this, _method);
    __privateAdd(this, _timeout);
    __privateAdd(this, _url);
    __privateAdd(this, _body);
    __privateAdd(this, _bodyType);
    __privateAdd(this, _creds);
    // Hooks
    __privateAdd(this, _preflight);
    __privateAdd(this, _process);
    __privateAdd(this, _retry);
    __privateAdd(this, _signal);
    __privateAdd(this, _throttle);
    __privateAdd(this, _getUrlFunc);
    __privateSet(this, _url, String(url));
    __privateSet(this, _allowInsecure, false);
    __privateSet(this, _gzip, true);
    __privateSet(this, _headers, {});
    __privateSet(this, _method, "");
    __privateSet(this, _timeout, 3e5);
    __privateSet(this, _throttle, {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    });
    __privateSet(this, _getUrlFunc, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return __privateGet(this, _url);
  }
  set url(url) {
    __privateSet(this, _url, String(url));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (__privateGet(this, _body) == null) {
      return null;
    }
    return new Uint8Array(__privateGet(this, _body));
  }
  set body(body) {
    if (body == null) {
      __privateSet(this, _body, void 0);
      __privateSet(this, _bodyType, void 0);
    } else if (typeof body === "string") {
      __privateSet(this, _body, toUtf8Bytes(body));
      __privateSet(this, _bodyType, "text/plain");
    } else if (body instanceof Uint8Array) {
      __privateSet(this, _body, body);
      __privateSet(this, _bodyType, "application/octet-stream");
    } else if (typeof body === "object") {
      __privateSet(this, _body, toUtf8Bytes(JSON.stringify(body)));
      __privateSet(this, _bodyType, "application/json");
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return __privateGet(this, _body) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (__privateGet(this, _method)) {
      return __privateGet(this, _method);
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    __privateSet(this, _method, String(method).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, __privateGet(this, _headers));
    if (__privateGet(this, _creds)) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(__privateGet(this, _creds)))}`;
    }
    ;
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && __privateGet(this, _bodyType)) {
      headers["content-type"] = __privateGet(this, _bodyType);
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key, value) {
    __privateGet(this, _headers)[String(key).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    __privateSet(this, _headers, {});
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return __privateGet(this, _creds) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    __privateSet(this, _creds, `${username}:${password}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return __privateGet(this, _gzip);
  }
  set allowGzip(value) {
    __privateSet(this, _gzip, !!value);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!__privateGet(this, _allowInsecure);
  }
  set allowInsecureAuthentication(value) {
    __privateSet(this, _allowInsecure, !!value);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return __privateGet(this, _timeout);
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    __privateSet(this, _timeout, timeout);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return __privateGet(this, _preflight) || null;
  }
  set preflightFunc(preflight) {
    __privateSet(this, _preflight, preflight);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return __privateGet(this, _process) || null;
  }
  set processFunc(process2) {
    __privateSet(this, _process, process2);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return __privateGet(this, _retry) || null;
  }
  set retryFunc(retry) {
    __privateSet(this, _retry, retry);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return __privateGet(this, _getUrlFunc) || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    __privateSet(this, _getUrlFunc, value);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _body) ? hexlify(__privateGet(this, _body)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      __privateGet(this, _throttle).slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      __privateGet(this, _throttle).maxAttempts = params.maxAttempts;
    }
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert(__privateGet(this, _signal) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    __privateSet(this, _signal, new FetchCancelSignal(this));
    return __privateMethod(this, _FetchRequest_instances, send_fn).call(this, 0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert(__privateGet(this, _signal) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new _FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    __privateSet(req, _headers, Object.assign({}, __privateGet(this, _headers)));
    if (__privateGet(this, _body)) {
      __privateSet(req, _body, new Uint8Array(__privateGet(this, _body)));
    }
    __privateSet(req, _bodyType, __privateGet(this, _bodyType));
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone2 = new _FetchRequest(this.url);
    __privateSet(clone2, _method, __privateGet(this, _method));
    if (__privateGet(this, _body)) {
      __privateSet(clone2, _body, __privateGet(this, _body));
    }
    __privateSet(clone2, _bodyType, __privateGet(this, _bodyType));
    __privateSet(clone2, _headers, Object.assign({}, __privateGet(this, _headers)));
    __privateSet(clone2, _creds, __privateGet(this, _creds));
    if (this.allowGzip) {
      clone2.allowGzip = true;
    }
    clone2.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone2.allowInsecureAuthentication = true;
    }
    __privateSet(clone2, _preflight, __privateGet(this, _preflight));
    __privateSet(clone2, _process, __privateGet(this, _process));
    __privateSet(clone2, _retry, __privateGet(this, _retry));
    __privateSet(clone2, _throttle, Object.assign({}, __privateGet(this, _throttle)));
    __privateSet(clone2, _getUrlFunc, __privateGet(this, _getUrlFunc));
    return clone2;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl) {
    if (locked) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options) {
    return createGetUrl(options);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
};
_allowInsecure = new WeakMap();
_gzip = new WeakMap();
_headers = new WeakMap();
_method = new WeakMap();
_timeout = new WeakMap();
_url = new WeakMap();
_body = new WeakMap();
_bodyType = new WeakMap();
_creds = new WeakMap();
_preflight = new WeakMap();
_process = new WeakMap();
_retry = new WeakMap();
_signal = new WeakMap();
_throttle = new WeakMap();
_getUrlFunc = new WeakMap();
_FetchRequest_instances = new WeakSet();
send_fn = async function(attempt, expires, delay, _request2, _response) {
  var _a3, _b, _c;
  if (attempt >= __privateGet(this, _throttle).maxAttempts) {
    return _response.makeServerError("exceeded maximum retry limit");
  }
  assert(getTime() <= expires, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: _request2
  });
  if (delay > 0) {
    await wait(delay);
  }
  let req = this.clone();
  const scheme = (req.url.split(":")[0] || "").toLowerCase();
  if (scheme in Gateways) {
    const result = await Gateways[scheme](req.url, checkSignal(__privateGet(_request2, _signal)));
    if (result instanceof FetchResponse) {
      let response2 = result;
      if (this.processFunc) {
        checkSignal(__privateGet(_request2, _signal));
        try {
          response2 = await this.processFunc(req, response2);
        } catch (error) {
          if (error.throttle == null || typeof error.stall !== "number") {
            response2.makeServerError("error in post-processing function", error).assertOk();
          }
        }
      }
      return response2;
    }
    req = result;
  }
  if (this.preflightFunc) {
    req = await this.preflightFunc(req);
  }
  const resp = await this.getUrlFunc(req, checkSignal(__privateGet(_request2, _signal)));
  let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request2);
  if (response.statusCode === 301 || response.statusCode === 302) {
    try {
      const location = response.headers.location || "";
      return __privateMethod(_a3 = req.redirect(location), _FetchRequest_instances, send_fn).call(_a3, attempt + 1, expires, 0, _request2, response);
    } catch (error) {
    }
    return response;
  } else if (response.statusCode === 429) {
    if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
      const retryAfter = response.headers["retry-after"];
      let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
        delay2 = parseInt(retryAfter);
      }
      return __privateMethod(_b = req.clone(), _FetchRequest_instances, send_fn).call(_b, attempt + 1, expires, delay2, _request2, response);
    }
  }
  if (this.processFunc) {
    checkSignal(__privateGet(_request2, _signal));
    try {
      response = await this.processFunc(req, response);
    } catch (error) {
      if (error.throttle == null || typeof error.stall !== "number") {
        response.makeServerError("error in post-processing function", error).assertOk();
      }
      let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      ;
      if (error.stall >= 0) {
        delay2 = error.stall;
      }
      return __privateMethod(_c = req.clone(), _FetchRequest_instances, send_fn).call(_c, attempt + 1, expires, delay2, _request2, response);
    }
  }
  return response;
};
var FetchRequest = _FetchRequest;
var _statusCode, _statusMessage, _headers2, _body2, _request, _error;
var _FetchResponse = class _FetchResponse {
  constructor(statusCode, statusMessage, headers, body, request) {
    __privateAdd(this, _statusCode);
    __privateAdd(this, _statusMessage);
    __privateAdd(this, _headers2);
    __privateAdd(this, _body2);
    __privateAdd(this, _request);
    __privateAdd(this, _error);
    __privateSet(this, _statusCode, statusCode);
    __privateSet(this, _statusMessage, statusMessage);
    __privateSet(this, _headers2, Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {}));
    __privateSet(this, _body2, body == null ? null : new Uint8Array(body));
    __privateSet(this, _request, request || null);
    __privateSet(this, _error, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _body2) ? hexlify(__privateGet(this, _body2)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return __privateGet(this, _statusCode);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return __privateGet(this, _statusMessage);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, __privateGet(this, _headers2));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return __privateGet(this, _body2) == null ? null : new Uint8Array(__privateGet(this, _body2));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return __privateGet(this, _body2) == null ? "" : toUtf8String(__privateGet(this, _body2));
    } catch (error) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, __privateGet(this, _request) || void 0);
    __privateSet(response, _error, { message, error });
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall) {
    if (stall == null) {
      stall = -1;
    } else {
      assertArgument(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
    }
    const error = new Error(message || "throttling requests");
    defineProperties(error, { stall, throttle: true });
    throw error;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return __privateGet(this, _body2) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return __privateGet(this, _request);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return __privateGet(this, _error).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = __privateGet(this, _error);
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (__privateGet(this, _body2)) {
        responseBody = toUtf8String(__privateGet(this, _body2));
      }
    } catch (e) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
_statusCode = new WeakMap();
_statusMessage = new WeakMap();
_headers2 = new WeakMap();
_body2 = new WeakMap();
_request = new WeakMap();
_error = new WeakMap();
var FetchResponse = _FetchResponse;
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all3, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/fixednumber.js
var BN_N1 = BigInt(-1);
var BN_03 = BigInt(0);
var BN_12 = BigInt(1);
var BN_5 = BigInt(5);
var Zeros = "0000";
while (Zeros.length < 80) {
  Zeros += Zeros;
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/rlp-decode.js
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset2
    });
  };
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data[offset]) };
}
function decodeRlp(_data5) {
  const data = getBytes(_data5, "data");
  const decoded = _decode(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data5);
  return decoded.result;
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/rlp-encode.js
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes(object2, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
var nibbles = "0123456789abcdef";
function encodeRlp(object2) {
  let result = "0x";
  for (const v of _encode(object2)) {
    result += nibbles[v >> 4];
    result += nibbles[v & 15];
  }
  return result;
}

// node_modules/tronweb/node_modules/ethers/lib.esm/utils/uuid.js
function uuidV4(randomBytes5) {
  const bytes3 = getBytes(randomBytes5, "randomBytes");
  bytes3[6] = bytes3[6] & 15 | 64;
  bytes3[8] = bytes3[8] & 63 | 128;
  const value = hexlify(bytes3);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js
var WordSize = 32;
var Padding = new Uint8Array(WordSize);
var passProperties = ["then"];
var _guard = {};
var resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names) {
  resultNames.set(result, names);
}
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names, items, deep) {
  if (names.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names.reduce((accum, name, index) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
var _names;
var _Result = class _Result extends Array {
  /**
   *  @private
   */
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard) {
      items = args;
      names = [];
      wrap = false;
    }
    super(items.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    __privateAdd(this, _names);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index) => {
      const name = names[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    __privateSet(this, _names, []);
    if (__privateGet(this, _names) == null) {
      void __privateGet(this, _names);
    }
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      if (deep && item instanceof _Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names = getNames(this);
    return names.reduce((accum, name, index) => {
      assert(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names2 = getNames(this);
    const result = [], names = [];
    for (let i = start; i < end; i++) {
      result.push(this[i]);
      names.push(_names2[i]);
    }
    return new _Result(_guard, result, names);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names2 = getNames(this);
    const result = [], names = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names.push(_names2[i]);
      }
    }
    return new _Result(_guard, result, names);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name) {
    const index = getNames(this).indexOf(name);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys) {
    return new _Result(_guard, items, keys);
  }
};
_names = new WeakMap();
var Result = _Result;
function getValue(value) {
  let bytes3 = toBeArray(value);
  assert(bytes3.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes3, length: WordSize, offset: bytes3.length });
  if (bytes3.length !== WordSize) {
    bytes3 = getBytesCopy(concat([Padding.slice(bytes3.length % WordSize), bytes3]));
  }
  return bytes3;
}
var Coder = class {
  constructor(name, type, localName, dynamic) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    __publicField(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    __publicField(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    __publicField(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    __publicField(this, "dynamic");
    defineProperties(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
};
var _data, _dataLength, _Writer_instances, writeData_fn;
var Writer = class {
  constructor() {
    __privateAdd(this, _Writer_instances);
    // An array of WordSize lengthed objects to concatenation
    __privateAdd(this, _data);
    __privateAdd(this, _dataLength);
    __privateSet(this, _data, []);
    __privateSet(this, _dataLength, 0);
  }
  get data() {
    return concat(__privateGet(this, _data));
  }
  get length() {
    return __privateGet(this, _dataLength);
  }
  appendWriter(writer) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes3 = getBytesCopy(value);
    const paddingOffset = bytes3.length % WordSize;
    if (paddingOffset) {
      bytes3 = getBytesCopy(concat([bytes3, Padding.slice(paddingOffset)]));
    }
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, bytes3);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getValue(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = __privateGet(this, _data).length;
    __privateGet(this, _data).push(Padding);
    __privateSet(this, _dataLength, __privateGet(this, _dataLength) + WordSize);
    return (value) => {
      __privateGet(this, _data)[offset] = getValue(value);
    };
  }
};
_data = new WeakMap();
_dataLength = new WeakMap();
_Writer_instances = new WeakSet();
writeData_fn = function(data) {
  __privateGet(this, _data).push(data);
  __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data.length);
  return data.length;
};
var _data2, _offset, _bytesRead, _parent, _maxInflation, _Reader_instances, incrementBytesRead_fn, peekBytes_fn;
var _Reader = class _Reader {
  constructor(data, allowLoose, maxInflation) {
    __privateAdd(this, _Reader_instances);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    __publicField(this, "allowLoose");
    __privateAdd(this, _data2);
    __privateAdd(this, _offset);
    __privateAdd(this, _bytesRead);
    __privateAdd(this, _parent);
    __privateAdd(this, _maxInflation);
    defineProperties(this, { allowLoose: !!allowLoose });
    __privateSet(this, _data2, getBytesCopy(data));
    __privateSet(this, _bytesRead, 0);
    __privateSet(this, _parent, null);
    __privateSet(this, _maxInflation, maxInflation != null ? maxInflation : 1024);
    __privateSet(this, _offset, 0);
  }
  get data() {
    return hexlify(__privateGet(this, _data2));
  }
  get dataLength() {
    return __privateGet(this, _data2).length;
  }
  get consumed() {
    return __privateGet(this, _offset);
  }
  get bytes() {
    return new Uint8Array(__privateGet(this, _data2));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new _Reader(__privateGet(this, _data2).slice(__privateGet(this, _offset) + offset), this.allowLoose, __privateGet(this, _maxInflation));
    __privateSet(reader, _parent, this);
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes3 = __privateMethod(this, _Reader_instances, peekBytes_fn).call(this, 0, length, !!loose);
    __privateMethod(this, _Reader_instances, incrementBytesRead_fn).call(this, length);
    __privateSet(this, _offset, __privateGet(this, _offset) + bytes3.length);
    return bytes3.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
};
_data2 = new WeakMap();
_offset = new WeakMap();
_bytesRead = new WeakMap();
_parent = new WeakMap();
_maxInflation = new WeakMap();
_Reader_instances = new WeakSet();
incrementBytesRead_fn = function(count) {
  var _a3;
  if (__privateGet(this, _parent)) {
    return __privateMethod(_a3 = __privateGet(this, _parent), _Reader_instances, incrementBytesRead_fn).call(_a3, count);
  }
  __privateSet(this, _bytesRead, __privateGet(this, _bytesRead) + count);
  assert(__privateGet(this, _maxInflation) < 1 || __privateGet(this, _bytesRead) <= __privateGet(this, _maxInflation) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _maxInflation)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: getBytesCopy(__privateGet(this, _data2)),
    offset: __privateGet(this, _offset),
    length: count,
    info: {
      bytesRead: __privateGet(this, _bytesRead),
      dataLength: this.dataLength
    }
  });
};
peekBytes_fn = function(offset, length, loose) {
  let alignedLength = Math.ceil(length / WordSize) * WordSize;
  if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data2).length) {
    if (this.allowLoose && loose && __privateGet(this, _offset) + length <= __privateGet(this, _data2).length) {
      alignedLength = length;
    } else {
      assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: getBytesCopy(__privateGet(this, _data2)),
        length: __privateGet(this, _data2).length,
        offset: __privateGet(this, _offset) + alignedLength
      });
    }
  }
  return __privateGet(this, _data2).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
};
var Reader = _Reader;

// node_modules/tronweb/node_modules/@noble/hashes/esm/_assert.js
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash3.outputLen);
  number(hash3.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/tronweb/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/tronweb/node_modules/@noble/hashes/esm/utils.js
var u8a = (a) => a instanceof Uint8Array;
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
var nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function checkOpts(defaults2, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/tronweb/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash3);
    const key = toBytes(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
hmac.create = (hash3, key) => new HMAC(hash3, key);

// node_modules/tronweb/node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash3, _password, _salt, _opts) {
  hash(hash3);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number(c);
  number(dkLen);
  number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash3, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf2(hash3, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/tronweb/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/tronweb/node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b2, c) => a & b2 ^ ~a & c;
var Maj = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T13 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T22 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T13 | 0;
      D = C;
      C = B;
      B = A;
      A = T13 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/tronweb/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/tronweb/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/tronweb/node_modules/ethers/lib.esm/crypto/crypto-browser.js
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal = getGlobal();
var crypto3 = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256.create();
    case "sha512":
      return sha512.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  const algo = { sha256, sha512 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  const algo = { sha256, sha512 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes2(length) {
  assert(crypto3 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  const result = new Uint8Array(length);
  crypto3.getRandomValues(result);
  return result;
}

// node_modules/tronweb/node_modules/ethers/lib.esm/crypto/hmac.js
var locked2 = false;
var _computeHmac = function(algorithm, key, data) {
  return createHmac(algorithm, key).update(data).digest();
};
var __computeHmac = _computeHmac;
function computeHmac(algorithm, _key, _data5) {
  const key = getBytes(_key, "key");
  const data = getBytes(_data5, "data");
  return hexlify(__computeHmac(algorithm, key, data));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked2 = true;
};
computeHmac.register = function(func) {
  if (locked2) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);

// node_modules/tronweb/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    number(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/tronweb/node_modules/ethers/lib.esm/crypto/keccak.js
var locked3 = false;
var _keccak256 = function(data) {
  return keccak_256(data);
};
var __keccak256 = _keccak256;
function keccak256(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked3 = true;
};
keccak256.register = function(func) {
  if (locked3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);

// node_modules/tronweb/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
var Pi = Id.map((i) => (9 * i + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  else if (group === 1)
    return x & y | ~x & z;
  else if (group === 2)
    return (x | ~y) ^ z;
  else if (group === 3)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
var BUF = new Uint32Array(16);
var RIPEMD160 = class extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/tronweb/node_modules/ethers/lib.esm/crypto/ripemd160.js
var locked4 = false;
var _ripemd160 = function(data) {
  return ripemd160(data);
};
var __ripemd160 = _ripemd160;
function ripemd1602(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__ripemd160(data));
}
ripemd1602._ = _ripemd160;
ripemd1602.lock = function() {
  locked4 = true;
};
ripemd1602.register = function(func) {
  if (locked4) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd1602);

// node_modules/tronweb/node_modules/ethers/lib.esm/crypto/pbkdf2.js
var locked5 = false;
var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
var __pbkdf2 = _pbkdf2;
function pbkdf22(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf22._ = _pbkdf2;
pbkdf22.lock = function() {
  locked5 = true;
};
pbkdf22.register = function(func) {
  if (locked5) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf22);

// node_modules/tronweb/node_modules/ethers/lib.esm/crypto/random.js
var locked6 = false;
var _randomBytes = function(length) {
  return new Uint8Array(randomBytes2(length));
};
var __randomBytes = _randomBytes;
function randomBytes3(length) {
  return __randomBytes(length);
}
randomBytes3._ = _randomBytes;
randomBytes3.lock = function() {
  locked6 = true;
};
randomBytes3.register = function(func) {
  if (locked6) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes3);

// node_modules/tronweb/node_modules/@noble/hashes/esm/scrypt.js
var rotl2 = (a, b2) => a << b2 | a >>> 32 - b2;
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl2(x00 + x12 | 0, 7);
    x08 ^= rotl2(x04 + x00 | 0, 9);
    x12 ^= rotl2(x08 + x04 | 0, 13);
    x00 ^= rotl2(x12 + x08 | 0, 18);
    x09 ^= rotl2(x05 + x01 | 0, 7);
    x13 ^= rotl2(x09 + x05 | 0, 9);
    x01 ^= rotl2(x13 + x09 | 0, 13);
    x05 ^= rotl2(x01 + x13 | 0, 18);
    x14 ^= rotl2(x10 + x06 | 0, 7);
    x02 ^= rotl2(x14 + x10 | 0, 9);
    x06 ^= rotl2(x02 + x14 | 0, 13);
    x10 ^= rotl2(x06 + x02 | 0, 18);
    x03 ^= rotl2(x15 + x11 | 0, 7);
    x07 ^= rotl2(x03 + x15 | 0, 9);
    x11 ^= rotl2(x07 + x03 | 0, 13);
    x15 ^= rotl2(x11 + x07 | 0, 18);
    x01 ^= rotl2(x00 + x03 | 0, 7);
    x02 ^= rotl2(x01 + x00 | 0, 9);
    x03 ^= rotl2(x02 + x01 | 0, 13);
    x00 ^= rotl2(x03 + x02 | 0, 18);
    x06 ^= rotl2(x05 + x04 | 0, 7);
    x07 ^= rotl2(x06 + x05 | 0, 9);
    x04 ^= rotl2(x07 + x06 | 0, 13);
    x05 ^= rotl2(x04 + x07 | 0, 18);
    x11 ^= rotl2(x10 + x09 | 0, 7);
    x08 ^= rotl2(x11 + x10 | 0, 9);
    x09 ^= rotl2(x08 + x11 | 0, 13);
    x10 ^= rotl2(x09 + x08 | 0, 18);
    x12 ^= rotl2(x15 + x14 | 0, 7);
    x13 ^= rotl2(x12 + x15 | 0, 9);
    x14 ^= rotl2(x13 + x12 | 0, 13);
    x15 ^= rotl2(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N3, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N3);
  number(r);
  number(p);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N3 <= 1 || (N3 & N3 - 1) !== 0 || N3 >= 2 ** (blockSize / 8) || N3 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N3 + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N3));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N3 * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N3, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt(password, salt, opts) {
  const { N: N3, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0; i < N3 - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N3 - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    for (let i = 0; i < N3; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N3;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N: N3, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop(N3 - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V, (N3 - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    await asyncLoop(N3, asyncTick, () => {
      const j = B32[Pi2 + blockSize32 - 16] % N3;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}

// node_modules/tronweb/node_modules/ethers/lib.esm/crypto/scrypt.js
var lockedSync = false;
var lockedAsync = false;
var _scryptAsync = async function(passwd, salt, N3, r, p, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N: N3, r, p, dkLen, onProgress });
};
var _scryptSync = function(passwd, salt, N3, r, p, dkLen) {
  return scrypt(passwd, salt, { N: N3, r, p, dkLen });
};
var __scryptAsync = _scryptAsync;
var __scryptSync = _scryptSync;
async function scrypt2(_passwd, _salt, N3, r, p, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N3, r, p, dkLen, progress));
}
scrypt2._ = _scryptAsync;
scrypt2.lock = function() {
  lockedAsync = true;
};
scrypt2.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt2);
function scryptSync(_passwd, _salt, N3, r, p, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N3, r, p, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);

// node_modules/tronweb/node_modules/ethers/lib.esm/crypto/sha2.js
var _sha256 = function(data) {
  return createHash("sha256").update(data).digest();
};
var _sha512 = function(data) {
  return createHash("sha512").update(data).digest();
};
var __sha256 = _sha256;
var __sha512 = _sha512;
var locked256 = false;
var locked512 = false;
function sha2562(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__sha256(data));
}
sha2562._ = _sha256;
sha2562.lock = function() {
  locked256 = true;
};
sha2562.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha2562);
function sha5122(_data5) {
  const data = getBytes(_data5, "data");
  return hexlify(__sha512(data));
}
sha5122._ = _sha512;
sha5122.lock = function() {
  locked512 = true;
};
sha5122.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha2562);

// node_modules/tronweb/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var u8a2 = (a) => a instanceof Uint8Array;
var hexes2 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes3) {
  if (!u8a2(bytes3))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes2[bytes3[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex(bytes3));
}
function bytesToNumberLE(bytes3) {
  if (!u8a2(bytes3))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a2(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n2; n2 >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n2;
}
var bitSet = (n2, pos, value) => {
  return n2 | (value ? _1n2 : _0n2) << BigInt(pos);
};
var bitMask = (n2) => (_2n2 << BigInt(n2 - 1)) - _1n2;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b2) => hmacFn(k, v, ...b2);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators3, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators3))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}

// node_modules/tronweb/node_modules/@noble/curves/esm/abstract/modular.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b2) {
  const result = a % b2;
  return result >= _0n3 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number3, modulo) {
  if (number3 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod(number3, modulo);
  let b2 = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x - u * q;
    const n2 = y - v * q;
    b2 = a, a = r, x = u, y = v, u = m, v = n2;
  }
  const gcd = b2;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q, S2, Z;
  for (Q = P - _1n3, S2 = 0; Q % _2n3 === _0n3; Q /= _2n3, S2++)
    ;
  for (Z = _2n3; Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
    ;
  if (S2 === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp3, n2) {
      const root = Fp3.pow(n2, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp3, n2) {
    if (Fp3.pow(n2, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r = S2;
    let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x = Fp3.pow(n2, Q1div2);
    let b2 = Fp3.pow(n2, Q);
    while (!Fp3.eql(b2, Fp3.ONE)) {
      if (Fp3.eql(b2, Fp3.ZERO))
        return Fp3.ZERO;
      let m = 1;
      for (let t2 = Fp3.sqr(b2); m < r; m++) {
        if (Fp3.eql(t2, Fp3.ONE))
          break;
        t2 = Fp3.sqr(t2);
      }
      const ge3 = Fp3.pow(g, _1n3 << BigInt(r - m - 1));
      g = Fp3.sqr(ge3);
      x = Fp3.mul(x, ge3);
      b2 = Fp3.mul(b2, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp3, n2) {
      const root = Fp3.pow(n2, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp3, n2) {
      const n22 = Fp3.mul(n2, _2n3);
      const v = Fp3.pow(n22, c1);
      const nv = Fp3.mul(n2, v);
      const i = Fp3.mul(Fp3.mul(nv, _2n3), v);
      const root = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f2.ONE;
  if (power === _1n3)
    return num;
  let p = f2.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f2.mul(p, d);
    d = f2.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen3, isLE3 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen3);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b2, c) => c ? b2 : a,
    toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE3 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE3 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/tronweb/node_modules/@noble/curves/esm/abstract/curve.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p = c.ZERO;
      let d = elm;
      while (n2 > _0n4) {
        if (n2 & _1n4)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n4;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n2) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P, precomputesMap, n2, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/tronweb/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a } = opts;
  if (endo) {
    if (!Fp3.eql(a, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp3 } = CURVE;
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a.x), Fp3.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b: b2 } = CURVE;
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b2);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp3.eql(i, Fp3.ZERO);
      if (is0(x) && is0(y))
        return Point3.ZERO;
      return new Point3(x, y, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point3.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp3.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp3.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp3.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U22 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp3.mul(b2, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point3(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a = CURVE.a;
      const b3 = Fp3.mul(CURVE.b, _3n2);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point3(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp3.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I = Point3.ZERO;
      if (n2 === _0n5)
        return I;
      assertGE(n2);
      if (n2 === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(n2);
        point = p;
        fake = f2;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b2) {
      const G = Point3.BASE;
      const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp3.ONE : Fp3.inv(z);
      const ax = Fp3.mul(x, iz);
      const ay = Fp3.mul(y, iz);
      const zz = Fp3.mul(z, iz);
      if (is0)
        return { x: Fp3.ZERO, y: Fp3.ZERO };
      if (!Fp3.eql(zz, Fp3.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes3(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point3.ZERO = new Point3(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp3.ORDER;
  }
  function modN3(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp3.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp3.sqrt(y2);
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp3.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n5;
    return number3 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN3(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE(b2.slice(from, to));
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN3(-h * ir);
      const u2 = modN3(s * ir);
      const Q = Point3.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN3(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point3.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    const num = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN3(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes5 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes5(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point3.BASE.multiply(k).toAffine();
      const r = modN3(q.x);
      if (r === _0n5)
        return;
      const s = modN3(ik * modN3(m + r * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a3;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig2 = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig2 = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig2 = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig2 = new Signature2(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point3.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig2;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN3(h * is);
    const u2 = modN3(r * is);
    const R = (_a3 = Point3.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a3.toAffine();
    if (!R)
      return false;
    const v = modN3(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point3,
    Signature: Signature2,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp3, Z) {
  const q = Fp3.ORDER;
  let l = _0n5;
  for (let o = q - _1n5; o % _2n4 === _0n5; o /= _2n4)
    l += _1n5;
  const c1 = l;
  const _2n_pow_c1_1 = _2n4 << c1 - _1n5 - _1n5;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;
  const c2 = (q - _1n5) / _2n_pow_c1;
  const c3 = (c2 - _1n5) / _2n4;
  const c4 = _2n_pow_c1 - _1n5;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp3.pow(Z, c2);
  const c7 = Fp3.pow(Z, (c2 + _1n5) / _2n4);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp3.pow(v, c4);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v);
    let tv5 = Fp3.mul(u, tv3);
    tv5 = Fp3.pow(tv5, c3);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v);
    tv3 = Fp3.mul(tv5, u);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c5);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c7);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n5; i--) {
      let tv52 = i - _2n4;
      tv52 = _2n4 << tv52 - _1n5;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e1 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e1);
      tv4 = Fp3.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp3.ORDER % _4n2 === _3n2) {
    const c12 = (Fp3.ORDER - _3n2) / _4n2;
    const c22 = Fp3.sqrt(Fp3.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp3.sqr(v);
      const tv2 = Fp3.mul(u, v);
      tv1 = Fp3.mul(tv1, tv2);
      let y1 = Fp3.pow(tv1, c12);
      y1 = Fp3.mul(y1, tv2);
      const y2 = Fp3.mul(y1, c22);
      const tv3 = Fp3.mul(Fp3.sqr(y1), v);
      const isQR = Fp3.eql(tv3, u);
      let y = Fp3.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp3, opts) {
  validateField(Fp3);
  if (!Fp3.isValid(opts.A) || !Fp3.isValid(opts.B) || !Fp3.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp3, opts.Z);
  if (!Fp3.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp3.sqr(u);
    tv1 = Fp3.mul(tv1, opts.Z);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, opts.B);
    tv4 = Fp3.cmov(opts.Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, opts.A);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, opts.A);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, opts.B);
    tv2 = Fp3.add(tv2, tv5);
    x = Fp3.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp3.mul(tv1, u);
    y = Fp3.mul(y, value);
    x = Fp3.cmov(x, tv3, isValid);
    y = Fp3.cmov(y, value, isValid);
    const e1 = Fp3.isOdd(u) === Fp3.isOdd(y);
    y = Fp3.cmov(Fp3.neg(y), y, e1);
    x = Fp3.div(x, tv4);
    return { x, y };
  };
}

// node_modules/tronweb/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function validateDST(dst) {
  if (dst instanceof Uint8Array)
    return dst;
  if (typeof dst === "string")
    return utf8ToBytes2(dst);
  throw new Error("DST must be Uint8Array or string");
}
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b2) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b2[i];
  }
  return arr;
}
function isBytes(item) {
  if (!(item instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function isNum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b2 = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b2[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b2[i - 1]), i2osp(i + 1, 1), DST_prime];
    b2[i] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b2);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash3, expand, DST: _DST } = options;
  isBytes(msg);
  isNum(count);
  const DST = validateDST(_DST);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash3);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash3);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point3, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point3.fromAffine(mapToCurve(u[0]));
      const u1 = Point3.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point3.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// node_modules/tronweb/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/tronweb/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a, b2) => (a + b2 / _2n5) / b2;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n5, P) * b3 % P;
  const b9 = pow2(b6, _3n5, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n5, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n5, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n2);
      const c2 = divNearest(-b1 * k, n2);
      let k1 = mod(k - c1 * a1 - c2 * a2, n2);
      let k2 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n6 = BigInt(0);
var fe = (x) => typeof x === "bigint" && _0n6 < x && x < secp256k1P;
var ge = (x) => typeof x === "bigint" && _0n6 < x && x < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n2) => numberToBytesBE(n2, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q, a, b2) => Point.BASE.multiplyAndAddUnsafe(Q, a, b2);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n5 !== _0n6)
    y = modP(-y);
  const p = new Point(x, y, _1n6);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n6)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x, y } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/tronweb/node_modules/ethers/lib.esm/constants/addresses.js
var ZeroAddress = "0x0000000000000000000000000000000000000000";

// node_modules/tronweb/node_modules/ethers/lib.esm/constants/hashes.js
var ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";

// node_modules/tronweb/node_modules/ethers/lib.esm/constants/numbers.js
var N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var WeiPerEther = BigInt("1000000000000000000");
var MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
var MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/tronweb/node_modules/ethers/lib.esm/constants/strings.js
var MessagePrefix = "Ethereum Signed Message:\n";

// node_modules/tronweb/node_modules/ethers/lib.esm/crypto/signature.js
var BN_04 = BigInt(0);
var BN_13 = BigInt(1);
var BN_2 = BigInt(2);
var BN_27 = BigInt(27);
var BN_28 = BigInt(28);
var BN_35 = BigInt(35);
var _guard2 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
var _r, _s, _v, _networkV;
var _Signature = class _Signature {
  /**
   *  @private
   */
  constructor(guard, r, s, v) {
    __privateAdd(this, _r);
    __privateAdd(this, _s);
    __privateAdd(this, _v);
    __privateAdd(this, _networkV);
    assertPrivate(guard, _guard2, "Signature");
    __privateSet(this, _r, r);
    __privateSet(this, _s, s);
    __privateSet(this, _v, v);
    __privateSet(this, _networkV, null);
  }
  /**
   *  The ``r`` value for a signautre.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return __privateGet(this, _r);
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    __privateSet(this, _r, hexlify(value));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    return __privateGet(this, _s);
  }
  set s(_value2) {
    assertArgument(dataLength(_value2) === 32, "invalid s", "value", _value2);
    const value = hexlify(_value2);
    assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    __privateSet(this, _s, value);
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return __privateGet(this, _v);
  }
  set v(value) {
    const v = getNumber(value, "value");
    assertArgument(v === 27 || v === 28, "invalid v", "v", value);
    __privateSet(this, _v, v);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return __privateGet(this, _networkV);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v = this.networkV;
    if (v == null) {
      return null;
    }
    return _Signature.getChainId(v);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone2 = new _Signature(_guard2, this.r, this.s, this.v);
    if (this.networkV) {
      __privateSet(clone2, _networkV, this.networkV);
    }
    return clone2;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v) {
    const bv = getBigInt(v, "v");
    if (bv == BN_27 || bv == BN_28) {
      return BN_04;
    }
    assertArgument(bv >= BN_35, "invalid EIP-155 v", "v", v);
    return (bv - BN_35) / BN_2;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v) {
    return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v) {
    const bv = getBigInt(v);
    if (bv === BN_04 || bv === BN_27) {
      return 27;
    }
    if (bv === BN_13 || bv === BN_28) {
      return 28;
    }
    assertArgument(bv >= BN_35, "invalid v", "v", v);
    return bv & BN_13 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    ;
    if (sig == null) {
      return new _Signature(_guard2, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes3 = getBytes(sig, "signature");
      if (bytes3.length === 64) {
        const r2 = hexlify(bytes3.slice(0, 32));
        const s2 = bytes3.slice(32, 64);
        const v2 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new _Signature(_guard2, r2, hexlify(s2), v2);
      }
      if (bytes3.length === 65) {
        const r2 = hexlify(bytes3.slice(0, 32));
        const s2 = bytes3.slice(32, 64);
        assertError((s2[0] & 128) === 0, "non-canonical s");
        const v2 = _Signature.getNormalizedV(bytes3[64]);
        return new _Signature(_guard2, r2, hexlify(s2), v2);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _Signature) {
      return sig.clone();
    }
    const _r2 = sig.r;
    assertError(_r2 != null, "missing r");
    const r = toUint256(_r2);
    const s = function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint256(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes3 = getBytes(yParityAndS);
        bytes3[0] &= 127;
        return hexlify(bytes3);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes(s)[0] & 128) == 0, "non-canonical s");
    const { networkV, v } = function(_v2, yParityAndS, yParity) {
      if (_v2 != null) {
        const v2 = getBigInt(_v2);
        return {
          networkV: v2 >= BN_35 ? v2 : void 0,
          v: _Signature.getNormalizedV(v2)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new _Signature(_guard2, r, s, v);
    if (networkV) {
      __privateSet(result, _networkV, networkV);
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
};
_r = new WeakMap();
_s = new WeakMap();
_v = new WeakMap();
_networkV = new WeakMap();
var Signature = _Signature;

// node_modules/tronweb/node_modules/ethers/lib.esm/crypto/signing-key.js
var _privateKey;
var _SigningKey = class _SigningKey {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    __privateAdd(this, _privateKey);
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    __privateSet(this, _privateKey, hexlify(privateKey));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return __privateGet(this, _privateKey);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(__privateGet(this, _privateKey)), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key, compressed) {
    let bytes3 = getBytes(key, "key");
    if (bytes3.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes3, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes3.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes3, 1);
      bytes3 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes3);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};
_privateKey = new WeakMap();
var SigningKey = _SigningKey;

// node_modules/tronweb/node_modules/ethers/lib.esm/address/address.js
var BN_05 = BigInt(0);
var BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
var Base36 = function() {
  ;
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_05;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}

// node_modules/tronweb/node_modules/ethers/lib.esm/address/checks.js
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/typed.js
var _gaurd = {};
function n(value, width) {
  let signed = false;
  if (width < 0) {
    signed = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, { signed, width });
}
function b(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
var _typedSymbol = Symbol.for("_ethers_typed");
var _options;
var _Typed = class _Typed {
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    __publicField(this, "type");
    /**
     *  The actual value.
     */
    __publicField(this, "value");
    __privateAdd(this, _options);
    /**
     *  @_ignore:
     */
    __publicField(this, "_typedSymbol");
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type, value });
    __privateSet(this, _options, options);
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v) => v.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return __privateGet(this, _options);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (__privateGet(this, _options) === true) {
      return -1;
    }
    if (__privateGet(this, _options) === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new _Typed(_gaurd, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v) {
    return n(v, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v) {
    return n(v, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v) {
    return n(v, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v) {
    return n(v, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v) {
    return n(v, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v) {
    return n(v, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v) {
    return n(v, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v) {
    return n(v, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v) {
    return n(v, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v) {
    return n(v, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v) {
    return n(v, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v) {
    return n(v, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v) {
    return n(v, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v) {
    return n(v, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v) {
    return n(v, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v) {
    return n(v, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v) {
    return n(v, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v) {
    return n(v, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v) {
    return n(v, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v) {
    return n(v, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v) {
    return n(v, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v) {
    return n(v, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v) {
    return n(v, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v) {
    return n(v, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v) {
    return n(v, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v) {
    return n(v, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v) {
    return n(v, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v) {
    return n(v, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v) {
    return n(v, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v) {
    return n(v, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v) {
    return n(v, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v) {
    return n(v, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v) {
    return n(v, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v) {
    return n(v, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v) {
    return n(v, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v) {
    return n(v, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v) {
    return n(v, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v) {
    return n(v, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v) {
    return n(v, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v) {
    return n(v, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v) {
    return n(v, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v) {
    return n(v, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v) {
    return n(v, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v) {
    return n(v, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v) {
    return n(v, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v) {
    return n(v, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v) {
    return n(v, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v) {
    return n(v, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v) {
    return n(v, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v) {
    return n(v, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v) {
    return n(v, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v) {
    return n(v, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v) {
    return n(v, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v) {
    return n(v, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v) {
    return n(v, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v) {
    return n(v, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v) {
    return n(v, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v) {
    return n(v, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v) {
    return n(v, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v) {
    return n(v, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v) {
    return n(v, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v) {
    return n(v, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v) {
    return b(v, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v) {
    return b(v, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v) {
    return b(v, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v) {
    return b(v, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v) {
    return b(v, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v) {
    return b(v, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v) {
    return b(v, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v) {
    return b(v, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v) {
    return b(v, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v) {
    return b(v, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v) {
    return b(v, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v) {
    return b(v, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v) {
    return b(v, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v) {
    return b(v, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v) {
    return b(v, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v) {
    return b(v, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v) {
    return b(v, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v) {
    return b(v, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v) {
    return b(v, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v) {
    return b(v, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v) {
    return b(v, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v) {
    return b(v, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v) {
    return b(v, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v) {
    return b(v, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v) {
    return b(v, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v) {
    return b(v, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v) {
    return b(v, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v) {
    return b(v, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v) {
    return b(v, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v) {
    return b(v, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v) {
    return b(v, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v) {
    return b(v, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v) {
    return new _Typed(_gaurd, "address", v);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v) {
    return new _Typed(_gaurd, "bool", !!v);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v) {
    return new _Typed(_gaurd, "bytes", v);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v) {
    return new _Typed(_gaurd, "string", v);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v, dynamic) {
    throw new Error("not implemented yet");
    return new _Typed(_gaurd, "array", v, dynamic);
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v, name) {
    throw new Error("not implemented yet");
    return new _Typed(_gaurd, "tuple", v, name);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v) {
    return new _Typed(_gaurd, "overrides", Object.assign({}, v));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};
_options = new WeakMap();
var Typed = _Typed;

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/address.js
var AddressCoder = class extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value2) {
    let value = Typed.dereference(_value2, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/anonymous.js
var AnonymousCoder = class extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    __publicField(this, "coder");
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}
var ArrayCoder = class extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    __publicField(this, "coder");
    __publicField(this, "length");
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/boolean.js
var BooleanCoder = class extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/bytes.js
var DynamicBytesCoder = class extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
};
var BytesCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js
var FixedBytesCoder = class extends Coder {
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    __publicField(this, "size");
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value2) {
    let data = getBytesCopy(Typed.dereference(_value2, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value2);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/null.js
var Empty = new Uint8Array([]);
var NullCoder = class extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/number.js
var BN_06 = BigInt(0);
var BN_14 = BigInt(1);
var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var NumberCoder = class extends Coder {
  constructor(size, signed, localName) {
    const name = (signed ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    __publicField(this, "size");
    __publicField(this, "signed");
    defineProperties(this, { size, signed }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value2) {
    let value = getBigInt(Typed.dereference(_value2, this.type));
    let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_14)) {
        this._throwError("value out-of-bounds", _value2);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_06 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/string.js
var StringCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value2) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value2, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/coders/tuple.js
var TupleCoder = class extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    __publicField(this, "coders");
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/hash/id.js
function id(value) {
  return keccak256(toUtf8Bytes(value));
}

// node_modules/@adraffy/ens-normalize/dist/index.mjs
var S0 = 44032;
var L0 = 4352;
var V0 = 4449;
var T0 = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S1 = S0 + S_COUNT;
var L1 = L0 + L_COUNT;
var V1 = V0 + V_COUNT;
var T1 = T0 + T_COUNT;

// node_modules/tronweb/node_modules/ethers/lib.esm/hash/namehash.js
var Zeros2 = new Uint8Array(32);
Zeros2.fill(0);

// node_modules/tronweb/node_modules/ethers/lib.esm/transaction/accesslist.js
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b2) => a.address.localeCompare(b2.address));
  return result;
}

// node_modules/tronweb/node_modules/ethers/lib.esm/transaction/address.js
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}

// node_modules/tronweb/node_modules/ethers/lib.esm/transaction/transaction.js
var BN_07 = BigInt(0);
var BN_22 = BigInt(2);
var BN_272 = BigInt(27);
var BN_282 = BigInt(28);
var BN_352 = BigInt(35);
var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var BLOB_SIZE = 4096 * 32;
function getVersionedHash(version3, hash3) {
  let versioned = version3.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha2562(hash3).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value2, param) {
  if (_value2 === "0x") {
    return 0;
  }
  return getNumber(_value2, param);
}
function handleUint(_value2, param) {
  if (_value2 === "0x") {
    return BN_07;
  }
  const value = getBigInt(_value2, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value2, name) {
  const value = getBigInt(_value2, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data) {
  const fields = decodeRlp(data);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_07
  };
  if (fields.length === 6) {
    return tx;
  }
  const v = handleUint(fields[6], "v");
  const r = handleUint(fields[7], "r");
  const s = handleUint(fields[8], "s");
  if (r === BN_07 && s === BN_07) {
    tx.chainId = v;
  } else {
    let chainId = (v - BN_352) / BN_22;
    if (chainId < BN_07) {
      chainId = BN_07;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_07 || (v === BN_272 || v === BN_282), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_07;
  if (tx.chainId != BN_07) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_07) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v = BigInt(27 + sig.yParity);
  if (chainId !== BN_07) {
    v = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r = zeroPadValue(fields[1], 32);
  const s = zeroPadValue(fields[2], 32);
  const signature = Signature.from({ r, s, yParity });
  tx.signature = signature;
}
function _parseEip1559(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data) {
  const fields = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data) {
  let fields = decodeRlp(getBytes(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields)]);
}
var _type, _to, _data3, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId, _sig, _accessList, _maxFeePerBlobGas, _blobVersionedHashes, _kzg, _blobs, _Transaction_instances, getSerialized_fn;
var _Transaction = class _Transaction {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    __privateAdd(this, _Transaction_instances);
    __privateAdd(this, _type);
    __privateAdd(this, _to);
    __privateAdd(this, _data3);
    __privateAdd(this, _nonce);
    __privateAdd(this, _gasLimit);
    __privateAdd(this, _gasPrice);
    __privateAdd(this, _maxPriorityFeePerGas);
    __privateAdd(this, _maxFeePerGas);
    __privateAdd(this, _value);
    __privateAdd(this, _chainId);
    __privateAdd(this, _sig);
    __privateAdd(this, _accessList);
    __privateAdd(this, _maxFeePerBlobGas);
    __privateAdd(this, _blobVersionedHashes);
    __privateAdd(this, _kzg);
    __privateAdd(this, _blobs);
    __privateSet(this, _type, null);
    __privateSet(this, _to, null);
    __privateSet(this, _nonce, 0);
    __privateSet(this, _gasLimit, BN_07);
    __privateSet(this, _gasPrice, null);
    __privateSet(this, _maxPriorityFeePerGas, null);
    __privateSet(this, _maxFeePerGas, null);
    __privateSet(this, _data3, "0x");
    __privateSet(this, _value, BN_07);
    __privateSet(this, _chainId, BN_07);
    __privateSet(this, _sig, null);
    __privateSet(this, _accessList, null);
    __privateSet(this, _maxFeePerBlobGas, null);
    __privateSet(this, _blobVersionedHashes, null);
    __privateSet(this, _blobs, null);
    __privateSet(this, _kzg, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return __privateGet(this, _type);
  }
  set type(value) {
    switch (value) {
      case null:
        __privateSet(this, _type, null);
        break;
      case 0:
      case "legacy":
        __privateSet(this, _type, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        __privateSet(this, _type, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        __privateSet(this, _type, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        __privateSet(this, _type, 3);
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = __privateGet(this, _to);
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    __privateSet(this, _to, value == null ? null : getAddress(value));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return __privateGet(this, _nonce);
  }
  set nonce(value) {
    __privateSet(this, _nonce, getNumber(value, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return __privateGet(this, _gasLimit);
  }
  set gasLimit(value) {
    __privateSet(this, _gasLimit, getBigInt(value));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = __privateGet(this, _gasPrice);
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_07;
    }
    return value;
  }
  set gasPrice(value) {
    __privateSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = __privateGet(this, _maxPriorityFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_07;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    __privateSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = __privateGet(this, _maxFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_07;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    __privateSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return __privateGet(this, _data3);
  }
  set data(value) {
    __privateSet(this, _data3, hexlify(value));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return __privateGet(this, _value);
  }
  set value(value) {
    __privateSet(this, _value, getBigInt(value, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return __privateGet(this, _chainId);
  }
  set chainId(value) {
    __privateSet(this, _chainId, getBigInt(value));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return __privateGet(this, _sig) || null;
  }
  set signature(value) {
    __privateSet(this, _sig, value == null ? null : Signature.from(value));
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = __privateGet(this, _accessList) || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    __privateSet(this, _accessList, value == null ? null : accessListify(value));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = __privateGet(this, _maxFeePerBlobGas);
    if (value == null && this.type === 3) {
      return BN_07;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    __privateSet(this, _maxFeePerBlobGas, value == null ? null : getBigInt(value, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = __privateGet(this, _blobVersionedHashes);
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    __privateSet(this, _blobVersionedHashes, value);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (__privateGet(this, _blobs) == null) {
      return null;
    }
    return __privateGet(this, _blobs).map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs2) {
    if (_blobs2 == null) {
      __privateSet(this, _blobs, null);
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0; i < _blobs2.length; i++) {
      const blob = _blobs2[i];
      if (isBytesLike(blob)) {
        assert(__privateGet(this, _kzg), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes(blob);
        assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
        if (data.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data);
          data = padded;
        }
        const commit = __privateGet(this, _kzg).blobToKzgCommitment(data);
        const proof = hexlify(__privateGet(this, _kzg).computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify(data),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    __privateSet(this, _blobs, blobs);
    __privateSet(this, _blobVersionedHashes, versionedHashes);
  }
  get kzg() {
    return __privateGet(this, _kzg);
  }
  set kzg(kzg) {
    __privateSet(this, _kzg, kzg);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(__privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types = this.inferTypes();
    if (types.indexOf(2) >= 0) {
      return 2;
    }
    return types.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = __privateGet(this, _maxFeePerBlobGas) != null || __privateGet(this, _blobVersionedHashes);
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types = [];
    if (this.type != null) {
      types.push(this.type);
    } else {
      if (hasFee) {
        types.push(2);
      } else if (hasGasPrice) {
        types.push(1);
        if (!hasAccessList) {
          types.push(0);
        }
      } else if (hasAccessList) {
        types.push(1);
        types.push(2);
      } else if (hasBlob && this.to) {
        types.push(3);
      } else {
        types.push(0);
        types.push(1);
        types.push(2);
        types.push(3);
      }
    }
    types.sort();
    return types;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s = (v) => {
      if (v == null) {
        return null;
      }
      return v.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip2930(payload));
        case 2:
          return _Transaction.from(_parseEip1559(payload));
        case 3:
          return _Transaction.from(_parseEip4844(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new _Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
};
_type = new WeakMap();
_to = new WeakMap();
_data3 = new WeakMap();
_nonce = new WeakMap();
_gasLimit = new WeakMap();
_gasPrice = new WeakMap();
_maxPriorityFeePerGas = new WeakMap();
_maxFeePerGas = new WeakMap();
_value = new WeakMap();
_chainId = new WeakMap();
_sig = new WeakMap();
_accessList = new WeakMap();
_maxFeePerBlobGas = new WeakMap();
_blobVersionedHashes = new WeakMap();
_kzg = new WeakMap();
_blobs = new WeakMap();
_Transaction_instances = new WeakSet();
getSerialized_fn = function(signed, sidecar) {
  assert(!signed || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const sig = signed ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return _serializeLegacy(this, sig);
    case 1:
      return _serializeEip2930(this, sig);
    case 2:
      return _serializeEip1559(this, sig);
    case 3:
      return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
  }
  assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
var Transaction = _Transaction;

// node_modules/tronweb/node_modules/ethers/lib.esm/hash/message.js
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}

// node_modules/tronweb/node_modules/ethers/lib.esm/hash/solidity.js
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");

// node_modules/tronweb/node_modules/ethers/lib.esm/hash/typed-data.js
var padding = new Uint8Array(32);
padding.fill(0);
var BN__1 = BigInt(-1);
var BN_08 = BigInt(0);
var BN_15 = BigInt(1);
var BN_MAX_UINT2562 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes3 = getBytes(value);
  const padOffset = bytes3.length % 32;
  if (padOffset) {
    return concat([bytes3, padding.slice(padOffset)]);
  }
  return hexlify(bytes3);
}
var hexTrue = toBeHex(BN_15, 32);
var hexFalse = toBeHex(BN_08, 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value2) {
    const value = getBigInt(_value2, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes3 = getBytes(value, "domain.salt");
    assertArgument(bytes3.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes3);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT2562, signed ? width - 1 : width);
      const boundsLower = signed ? (boundsUpper + BN_15) * BN__1 : BN_08;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes3 = getBytes(value);
        assertArgument(bytes3.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
var _types, _fullTypes, _encoderCache, _TypedDataEncoder_instances, getEncoder_fn;
var _TypedDataEncoder = class _TypedDataEncoder {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types3) {
    __privateAdd(this, _TypedDataEncoder_instances);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    __publicField(this, "primaryType");
    __privateAdd(this, _types);
    __privateAdd(this, _fullTypes);
    __privateAdd(this, _encoderCache);
    __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
    __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types = {};
    Object.keys(_types3).forEach((type) => {
      types[type] = _types3[type].map(({ name, type: type2 }) => {
        let { base, index } = splitArray(type2);
        if (base === "int" && !_types3["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types3["uint"]) {
          base = "uint256";
        }
        return { name, type: base + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    __privateSet(this, _types, JSON.stringify(types));
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types3);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types3);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types3);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types3);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types3);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types3);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      __privateGet(this, _fullTypes).set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(__privateGet(this, _types));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = __privateGet(this, _encoderCache).get(type);
    if (!encoder) {
      encoder = __privateMethod(this, _TypedDataEncoder_instances, getEncoder_fn).call(this, type);
      __privateGet(this, _encoderCache).set(type, encoder);
    }
    return encoder;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = __privateGet(this, _fullTypes).get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v) => this._visit(array.prefix, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _TypedDataEncoder(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _TypedDataEncoder.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _TypedDataEncoder.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a, b2) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain),
      _TypedDataEncoder.from(types).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak256(_TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = _TypedDataEncoder.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    _TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = _TypedDataEncoder.from(types);
    types = encoder.types;
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
};
_types = new WeakMap();
_fullTypes = new WeakMap();
_encoderCache = new WeakMap();
_TypedDataEncoder_instances = new WeakSet();
getEncoder_fn = function(type) {
  {
    const encoder = getBaseEncoder(type);
    if (encoder) {
      return encoder;
    }
  }
  const array = splitArray(type).array;
  if (array) {
    const subtype = array.prefix;
    const subEncoder = this.getEncoder(subtype);
    return (value) => {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      let result = value.map(subEncoder);
      if (__privateGet(this, _fullTypes).has(subtype)) {
        result = result.map(keccak256);
      }
      return keccak256(concat(result));
    };
  }
  const fields = this.types[type];
  if (fields) {
    const encodedType = id(__privateGet(this, _fullTypes).get(type));
    return (value) => {
      const values = fields.map(({ name, type: type2 }) => {
        const result = this.getEncoder(type2)(value[name]);
        if (__privateGet(this, _fullTypes).has(type2)) {
          return keccak256(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return concat(values);
    };
  }
  assertArgument(false, `unknown type: ${type}`, "type", type);
};
var TypedDataEncoder = _TypedDataEncoder;

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/fragments.js
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
var _kwVisibDeploy = "external public payable override";
var KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
var _kwVisib = "constant external internal payable private public pure view override";
var KwVisib = setify(_kwVisib.split(" "));
var _kwTypes = "constructor error event fallback function receive struct";
var KwTypes = setify(_kwTypes.split(" "));
var _kwModifiers = "calldata memory storage payable indexed";
var KwModifiers = setify(_kwModifiers.split(" "));
var _kwOther = "tuple returns";
var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
var Keywords = setify(_keywords.split(" "));
var SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
var regexWhitespacePrefix = new RegExp("^(\\s*)");
var regexNumberPrefix = new RegExp("^([0-9]+)");
var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var _offset2, _tokens, _TokenString_instances, subTokenString_fn;
var _TokenString = class _TokenString {
  constructor(tokens) {
    __privateAdd(this, _TokenString_instances);
    __privateAdd(this, _offset2);
    __privateAdd(this, _tokens);
    __privateSet(this, _offset2, 0);
    __privateSet(this, _tokens, tokens.slice());
  }
  get offset() {
    return __privateGet(this, _offset2);
  }
  get length() {
    return __privateGet(this, _tokens).length - __privateGet(this, _offset2);
  }
  clone() {
    return new _TokenString(__privateGet(this, _tokens));
  }
  reset() {
    __privateSet(this, _offset2, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = __privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, top.match + 1);
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (__privateGet(this, _offset2) < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(__privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, link));
      __privateSet(this, _offset2, link);
    }
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (__privateGet(this, _offset2) >= __privateGet(this, _tokens).length) {
      throw new Error("out-of-bounds");
    }
    return __privateGet(this, _tokens)[__privateGet(this, _offset2)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    __privateWrapper(this, _offset2)._++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = __privateGet(this, _offset2); i < __privateGet(this, _tokens).length; i++) {
      const token = __privateGet(this, _tokens)[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
_offset2 = new WeakMap();
_tokens = new WeakMap();
_TokenString_instances = new WeakSet();
subTokenString_fn = function(from = 0, to = 0) {
  return new _TokenString(__privateGet(this, _tokens).slice(from, to).map((t) => {
    return Object.freeze(Object.assign({}, t, {
      match: t.match - from,
      linkBack: t.linkBack - from,
      linkNext: t.linkNext - from
    }));
  }));
};
var TokenString = _TokenString;
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
}
function allowSingle(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
var _guard3 = {};
var internal = Symbol.for("_ethers_internal");
var ParamTypeInternal = "_ParamTypeInternal";
var ErrorFragmentInternal = "_ErrorInternal";
var EventFragmentInternal = "_EventInternal";
var ConstructorFragmentInternal = "_ConstructorInternal";
var FallbackFragmentInternal = "_FallbackInternal";
var FunctionFragmentInternal = "_FunctionInternal";
var StructFragmentInternal = "_StructInternal";
var _ParamType_instances, walkAsync_fn;
var _ParamType = class _ParamType {
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    __privateAdd(this, _ParamType_instances);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    __publicField(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    __publicField(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    __publicField(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    __publicField(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    __publicField(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayChildren");
    assertPrivate(guard, _guard3, "ParamType");
    Object.defineProperty(this, internal, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c) => JSON.parse(c.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process2) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v) => _this.arrayChildren.walk(v, process2));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v, i) => _this.components[i].walk(v, process2));
    }
    return process2(this.type, value);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process2) {
    const promises = [];
    const result = [value];
    __privateMethod(this, _ParamType_instances, walkAsync_fn).call(this, promises, value, process2, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => _ParamType.from(t));
        type2 = `tuple(${comps.map((c) => c.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard3, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard3, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard3, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c) => _ParamType.from(c)) : null;
      const tuple = new _ParamType(_guard3, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new _ParamType(_guard3, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal] === ParamTypeInternal;
  }
};
_ParamType_instances = new WeakSet();
walkAsync_fn = function(promises, value, process2, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    const childType = this.arrayChildren;
    const result2 = value.slice();
    result2.forEach((value2, index) => {
      var _a3;
      __privateMethod(_a3 = childType, _ParamType_instances, walkAsync_fn).call(_a3, promises, value2, process2, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  if (this.isTuple()) {
    const components = this.components;
    let result2;
    if (Array.isArray(value)) {
      result2 = value.slice();
    } else {
      if (value == null || typeof value !== "object") {
        throw new Error("invalid tuple value");
      }
      result2 = components.map((param) => {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error(`missing value for component ${param.name}`);
        }
        return value[param.name];
      });
    }
    if (result2.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    result2.forEach((value2, index) => {
      var _a3;
      __privateMethod(_a3 = components[index], _ParamType_instances, walkAsync_fn).call(_a3, promises, value2, process2, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  const result = process2(this.type, value);
  if (result.then) {
    promises.push(async function() {
      setValue(await result);
    }());
  } else {
    setValue(result);
  }
};
var ParamType = _ParamType;
var Fragment = class _Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    /**
     *  The type of the fragment.
     */
    __publicField(this, "type");
    /**
     *  The inputs for the fragment.
     */
    __publicField(this, "inputs");
    assertPrivate(guard, _guard3, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        _Fragment.from(JSON.parse(obj));
      } catch (e) {
      }
      return _Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
};
var NamedFragment = class extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    /**
     *  The name of the fragment.
     */
    __publicField(this, "name");
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
};
function joinParams(format, params) {
  return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
}
var ErrorFragment = class _ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new _ErrorFragment(_guard3, name, inputs);
    }
    return new _ErrorFragment(_guard3, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === ErrorFragmentInternal;
  }
};
var EventFragment = class _EventFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    /**
     *  Whether this event is anonymous.
     */
    __publicField(this, "anonymous");
    Object.defineProperty(this, internal, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new _EventFragment(_guard3, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (_EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new _EventFragment(_guard3, name, inputs, anonymous);
    }
    return new _EventFragment(_guard3, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === EventFragmentInternal;
  }
};
var ConstructorFragment = class _ConstructorFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    /**
     *  Whether the constructor can receive an endowment.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format) {
    assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [`constructor${joinParams(format, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new _ConstructorFragment(_guard3, "constructor", inputs, payable, gas);
    }
    return new _ConstructorFragment(_guard3, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === ConstructorFragmentInternal;
  }
};
var FallbackFragment = class _FallbackFragment extends Fragment {
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new _FallbackFragment(_guard3, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new _FallbackFragment(_guard3, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new _FallbackFragment(_guard3, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new _FallbackFragment(_guard3, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === FallbackFragmentInternal;
  }
};
var FunctionFragment = class _FunctionFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    __publicField(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    __publicField(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    __publicField(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new _FunctionFragment(_guard3, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new _FunctionFragment(_guard3, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new _FunctionFragment(_guard3, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === FunctionFragmentInternal;
  }
};
var StructFragment = class _StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return _StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new _StructFragment(_guard3, name, inputs);
    }
    return new _StructFragment(_guard3, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal] === StructFragmentInternal;
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/abi-coder.js
var PanicReasons = /* @__PURE__ */ new Map();
PanicReasons.set(0, "GENERIC_PANIC");
PanicReasons.set(1, "ASSERT_FALSE");
PanicReasons.set(17, "OVERFLOW");
PanicReasons.set(18, "DIVIDE_BY_ZERO");
PanicReasons.set(33, "ENUM_RANGE_ERROR");
PanicReasons.set(34, "BAD_STORAGE_DATA");
PanicReasons.set(49, "STACK_UNDERFLOW");
PanicReasons.set(50, "ARRAY_RANGE_ERROR");
PanicReasons.set(65, "OUT_OF_MEMORY");
PanicReasons.set(81, "UNINITIALIZED_FUNCTION_CALL");
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var defaultCoder = null;
var defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder2) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message = "execution reverted";
    const bytes3 = getBytes(data);
    data = hexlify(data);
    if (bytes3.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes3.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes3.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder2.decode(["string"], bytes3.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes3.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder2.decode(["uint256"], bytes3.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction,
    invocation,
    revert
  });
}
var _AbiCoder_instances, getCoder_fn;
var _AbiCoder = class _AbiCoder {
  constructor() {
    __privateAdd(this, _AbiCoder_instances);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types) {
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types, values) {
    assertArgumentCount(values.length, types.length, "types/values length mismatch");
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types, data, loose) {
    const coders = types.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new _AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException(action, tx, data, _AbiCoder.defaultAbiCoder());
  }
};
_AbiCoder_instances = new WeakSet();
getCoder_fn = function(param) {
  if (param.isArray()) {
    return new ArrayCoder(__privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
  }
  if (param.isTuple()) {
    return new TupleCoder(param.components.map((c) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, c)), param.name);
  }
  switch (param.baseType) {
    case "address":
      return new AddressCoder(param.name);
    case "bool":
      return new BooleanCoder(param.name);
    case "string":
      return new StringCoder(param.name);
    case "bytes":
      return new BytesCoder(param.name);
    case "":
      return new NullCoder(param.name);
  }
  let match = param.type.match(paramTypeNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
    return new NumberCoder(size / 8, match[1] === "int", param.name);
  }
  match = param.type.match(paramTypeBytes);
  if (match) {
    let size = parseInt(match[1]);
    assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
    return new FixedBytesCoder(size, param.name);
  }
  assertArgument(false, "invalid type", "type", param.type);
};
var AbiCoder = _AbiCoder;

// node_modules/tronweb/node_modules/ethers/lib.esm/abi/interface.js
var LogDescription = class {
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Event.
     */
    __publicField(this, "name");
    /**
     *  The full Event signature.
     */
    __publicField(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    __publicField(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    __publicField(this, "args");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature,
      topic,
      args
    });
  }
};
var TransactionDescription = class {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    __publicField(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    __publicField(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    __publicField(this, "value");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector,
      value
    });
  }
};
var ErrorDescription = class {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    /**
     *  The matching fragment.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Error.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    __publicField(this, "args");
    /**
     *  The full Error signature.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Error.
     */
    __publicField(this, "selector");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector
    });
  }
};
var Indexed = class {
  /**
   *  @_ignore:
   */
  constructor(hash3) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    __publicField(this, "hash");
    /**
     *  @_ignore:
     */
    __publicField(this, "_isIndexed");
    defineProperties(this, { hash: hash3, _isIndexed: true });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
};
var PanicReasons2 = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons2[code.toString()]) {
        reason = PanicReasons2[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
var _errors, _events, _functions, _abiCoder, _Interface_instances, getFunction_fn, getEvent_fn;
var _Interface = class _Interface {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    __privateAdd(this, _Interface_instances);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    __publicField(this, "fragments");
    /**
     *  The Contract constructor.
     */
    __publicField(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    __publicField(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    __publicField(this, "receive");
    __privateAdd(this, _errors);
    __privateAdd(this, _events);
    __privateAdd(this, _functions);
    //    #structs: Map<string, StructFragment>;
    __privateAdd(this, _abiCoder);
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    __privateSet(this, _functions, /* @__PURE__ */ new Map());
    __privateSet(this, _errors, /* @__PURE__ */ new Map());
    __privateSet(this, _events, /* @__PURE__ */ new Map());
    const frags = [];
    for (const a of abi) {
      try {
        frags.push(Fragment.from(a));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    __privateSet(this, _abiCoder, this.getAbiCoder());
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = __privateGet(this, _functions);
          break;
        case "event":
          bucket = __privateGet(this, _events);
          break;
        case "error":
          bucket = __privateGet(this, _errors);
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f2) => f2.format(format));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!__privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names = Array.from(__privateGet(this, _functions).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(__privateGet(this, _functions).get(name), i);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!__privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names = Array.from(__privateGet(this, _events).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(__privateGet(this, _events).get(name), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of __privateGet(this, _errors).values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of __privateGet(this, _errors)) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = __privateGet(this, _errors).get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names = Array.from(__privateGet(this, _errors).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(__privateGet(this, _errors).get(name), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return __privateGet(this, _abiCoder).decode(params, data);
  }
  _encodeParams(params, values) {
    return __privateGet(this, _abiCoder).encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes3 = getBytesCopy(data);
    if (bytes3.length % 32 === 0) {
      try {
        return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes3);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes3),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data5, tx) {
    const data = getBytes(_data5, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = __privateGet(this, _abiCoder).decode(ef.inputs, data.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(__privateGet(this, _abiCoder).encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        __privateGet(this, _abiCoder).encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, concat(topics)) : null;
    const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new _Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};
_errors = new WeakMap();
_events = new WeakMap();
_functions = new WeakMap();
_abiCoder = new WeakMap();
_Interface_instances = new WeakSet();
// Find a function definition by any means necessary (unless it is ambiguous)
getFunction_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const selector = key.toLowerCase();
    for (const fragment of __privateGet(this, _functions).values()) {
      if (selector === fragment.selector) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _functions)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      const lastValue = values.length > 0 ? values[values.length - 1] : null;
      let valueLength = values.length;
      let allowOptions = true;
      if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j = 0; j < values.length; j++) {
          if (!Typed.isTyped(values[j])) {
            continue;
          }
          if (j >= inputs.length) {
            if (values[j].type === "overrides") {
              continue;
            }
            matching.splice(i, 1);
            break;
          }
          if (values[j].type !== inputs[j].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
      const lastArg = values[values.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
      assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _functions).get(FunctionFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
// Find an event definition by any means necessary (unless it is ambiguous)
getEvent_fn = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const eventTopic = key.toLowerCase();
    for (const fragment of __privateGet(this, _events).values()) {
      if (eventTopic === fragment.topicHash) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _events)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      for (let i = matching.length - 1; i >= 0; i--) {
        if (matching[i].inputs.length < values.length) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j = 0; j < values.length; j++) {
          if (!Typed.isTyped(values[j])) {
            continue;
          }
          if (values[j].type !== inputs[j].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
      assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _events).get(EventFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
var Interface = _Interface;

// node_modules/tronweb/node_modules/ethers/lib.esm/providers/provider.js
var BN_09 = BigInt(0);
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}
var Log = class {
  /**
   *  @_ignore:
   */
  constructor(log, provider) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    __publicField(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    __publicField(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    __publicField(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    __publicField(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    __publicField(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    __publicField(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    __publicField(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    __publicField(this, "transactionIndex");
    this.provider = provider;
    const topics = Object.freeze(log.topics.slice());
    defineProperties(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
};
var _logs;
var TransactionReceipt = class {
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    __publicField(this, "to");
    /**
     *  The sender of the transaction.
     */
    __publicField(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    __publicField(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    __publicField(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    __publicField(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    __publicField(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    __publicField(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    __publicField(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    __publicField(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    __publicField(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    __publicField(this, "root");
    __privateAdd(this, _logs);
    __privateSet(this, _logs, Object.freeze(tx.logs.map((log) => {
      return new Log(log, provider);
    })));
    let gasPrice = BN_09;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return __privateGet(this, _logs);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash3,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash3,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
};
_logs = new WeakMap();
var _startBlock;
var _TransactionResponse = class _TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(tx, provider) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    __publicField(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    __publicField(this, "index");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    __publicField(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    __publicField(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    __publicField(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    __publicField(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    __publicField(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    __publicField(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    __publicField(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    __publicField(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    __publicField(this, "value");
    /**
     *  The chain ID.
     */
    __publicField(this, "chainId");
    /**
     *  The signature.
     */
    __publicField(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    __publicField(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    __publicField(this, "blobVersionedHashes");
    __privateAdd(this, _startBlock);
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    __privateSet(this, _startBlock, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash3, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash3,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature,
      to,
      index,
      type,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout2) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout2 == null ? 0 : _timeout2;
    let startBlock = __privateGet(this, _startBlock);
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < __privateGet(this, _startBlock)) {
          nextScan = __privateGet(this, _startBlock);
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash3 of block) {
          if (hash3 === this.hash) {
            return;
          }
        }
        for (let i = 0; i < block.length; i++) {
          const tx = await block.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_09) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c) => c());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    __privateSet(tx, _startBlock, startBlock);
    return tx;
  }
};
_startBlock = new WeakMap();
var TransactionResponse = _TransactionResponse;
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}

// node_modules/tronweb/node_modules/ethers/lib.esm/contract/wrappers.js
var EventLog = class extends Log {
  /**
   * @_ignore:
   */
  constructor(log, iface, fragment) {
    super(log, log.provider);
    /**
     *  The Contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The matching event.
     */
    __publicField(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    __publicField(this, "args");
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
};
var UndecodedEventLog = class extends Log {
  /**
   * @_ignore:
   */
  constructor(log, error) {
    super(log, log.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    __publicField(this, "error");
    defineProperties(this, { error });
  }
};
var _iface;
var ContractTransactionReceipt = class extends TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    __privateAdd(this, _iface);
    __privateSet(this, _iface, iface);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? __privateGet(this, _iface).getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log, __privateGet(this, _iface), fragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return log;
    });
  }
};
_iface = new WeakMap();
var _iface2;
var ContractTransactionResponse = class extends TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(iface, provider, tx) {
    super(tx, provider);
    __privateAdd(this, _iface2);
    __privateSet(this, _iface2, iface);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(__privateGet(this, _iface2), this.provider, receipt);
  }
};
_iface2 = new WeakMap();
var ContractUnknownEventPayload = class extends EventPayload {
  /**
   *  @_event:
   */
  constructor(contract, listener, filter2, log) {
    super(contract, listener, filter2);
    /**
     *  The log with no matching events.
     */
    __publicField(this, "log");
    defineProperties(this, { log });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
};
var ContractEventPayload = class extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter2, fragment, _log) {
    super(contract, listener, filter2, new EventLog(_log, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/contract/contract.js
var BN_010 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
var _filter;
var PreparedTopicFilter = class {
  constructor(contract, fragment, args) {
    __privateAdd(this, _filter);
    __publicField(this, "fragment");
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    __privateSet(this, _filter, async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v) => resolveAddress(v, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }());
  }
  getTopicFilter() {
    return __privateGet(this, _filter);
  }
};
_filter = new WeakMap();
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_010, "overrides.value") === BN_010;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
var internal2 = Symbol.for("_ethersInternal_contract");
var internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal2], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal2]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e) => {
      if (e == null) {
        return null;
      }
      if (Array.isArray(e)) {
        return e.map(topicHashify);
      }
      return topicHashify(e);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider = getProvider(contract.runner);
  assert(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter2 = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter2, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter2, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
var lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
var passProperties2 = ["then"];
var _a;
_a = internal2;
var _BaseContract = class _BaseContract {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi, runner, _deployTx) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    __publicField(this, "target");
    /**
     *  The contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    __publicField(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    __publicField(this, "filters");
    /**
     *  @_ignore:
     */
    __publicField(this, _a);
    /**
     *  The fallback or receive function if any.
     */
    __publicField(this, "fallback");
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal2, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider = getProvider(this.runner);
    assert(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider(this.runner);
    assert(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programatically.
   */
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash3) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter2 = { address, topics, fromBlock, toBlock };
    const provider = getProvider(this.runner);
    assert(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter2)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return new Log(log, provider);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
};
var BaseContract = _BaseContract;
function _ContractBase() {
  return BaseContract;
}
var Contract = class extends _ContractBase() {
};

// node_modules/tronweb/node_modules/ethers/lib.esm/providers/ens-resolver.js
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];

// node_modules/tronweb/node_modules/ethers/lib.esm/providers/format.js
var BN_011 = BigInt(0);
function allowNull(format, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format(value);
  };
}
function arrayOf(format, allowNull2) {
  return (array) => {
    if (allowNull2 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format(i));
  };
}
function object(format, altNames) {
  return (value) => {
    const result = {};
    for (const key in format) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format[key](value[srcKey]);
        if (nv !== void 0) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
var _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
var _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
var _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
var _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});

// node_modules/tronweb/node_modules/ethers/lib.esm/providers/abstract-provider.js
var BN_23 = BigInt(2);
var empty = new Uint8Array([]);

// node_modules/tronweb/node_modules/ethers/lib.esm/providers/abstract-signer.js
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
var AbstractSigner = class {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider) {
    /**
     *  The provider this signer is connected to.
     */
    __publicField(this, "provider");
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          pop.type = 2;
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
};
var _VoidSigner_instances, throwUnsupported_fn;
var _VoidSigner = class _VoidSigner extends AbstractSigner {
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(address, provider) {
    super(provider);
    __privateAdd(this, _VoidSigner_instances);
    /**
     *  The signer address.
     */
    __publicField(this, "address");
    defineProperties(this, { address });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _VoidSigner(this.address, provider);
  }
  async signTransaction(tx) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "transactions", "signTransaction");
  }
  async signMessage(message) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "messages", "signMessage");
  }
  async signTypedData(domain, types, value) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "typed-data", "signTypedData");
  }
};
_VoidSigner_instances = new WeakSet();
throwUnsupported_fn = function(suffix, operation) {
  assert(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
};
var VoidSigner = _VoidSigner;

// node_modules/tronweb/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js
var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
var defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};

// node_modules/tronweb/node_modules/ethers/lib.esm/providers/ws-browser.js
function getGlobal2() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var _WebSocket = getGlobal2().WebSocket;

// node_modules/tronweb/node_modules/ethers/lib.esm/providers/provider-fallback.js
var BN_16 = BigInt("1");
var BN_24 = BigInt("2");

// node_modules/tronweb/node_modules/ethers/lib.esm/providers/default-provider.js
var Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");

// node_modules/tronweb/node_modules/ethers/lib.esm/wallet/base-wallet.js
var _signingKey;
var _BaseWallet = class _BaseWallet extends AbstractSigner {
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  constructor(privateKey, provider) {
    super(provider);
    /**
     *  The wallet address.
     */
    __publicField(this, "address");
    __privateAdd(this, _signingKey);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    __privateSet(this, _signingKey, privateKey);
    const address = computeAddress(this.signingKey.publicKey);
    defineProperties(this, { address });
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  get signingKey() {
    return __privateGet(this, _signingKey);
  }
  /**
   *  The private key for this wallet.
   */
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new _BaseWallet(__privateGet(this, _signingKey), provider);
  }
  async signTransaction(tx) {
    tx = copyRequest(tx);
    const { to, from } = await resolveProperties({
      to: tx.to ? resolveAddress(tx.to, this.provider) : void 0,
      from: tx.from ? resolveAddress(tx.from, this.provider) : void 0
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  // @TODO: Add a secialized signTx and signTyped sync that enforces
  // all parameters are known?
  /**
   *  Returns the signature for %%message%% signed with this wallet.
   */
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage(message)).serialized;
  }
  async signTypedData(domain, types, value) {
    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name) => {
      assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address = await this.provider.resolveName(name);
      assert(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;
  }
};
_signingKey = new WeakMap();
var BaseWallet = _BaseWallet;

// node_modules/tronweb/node_modules/ethers/lib.esm/wordlists/decode-owl.js
var subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
var Word = /^[a-z]*$/i;
function unfold(words2, sep) {
  let initial = 97;
  return words2.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode(data, subs) {
  for (let i = subsChrs.length - 1; i >= 0; i--) {
    data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all3, item, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi); i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data) {
  assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
  return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}

// node_modules/tronweb/node_modules/ethers/lib.esm/wordlists/wordlist.js
var Wordlist = class {
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  constructor(locale) {
    __publicField(this, "locale");
    defineProperties(this, { locale });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  /**
   *  Sub-classes may override this to provider a language-specific
   *  method for joining %%words%% into a phrase.
   *
   *  By default, %%words%% are joined by a single space.
   */
  join(words2) {
    return words2.join(" ");
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js
var _data4, _checksum, _words, _WordlistOwl_instances, loadWords_fn;
var WordlistOwl = class extends Wordlist {
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  constructor(locale, data, checksum2) {
    super(locale);
    __privateAdd(this, _WordlistOwl_instances);
    __privateAdd(this, _data4);
    __privateAdd(this, _checksum);
    __privateAdd(this, _words);
    __privateSet(this, _data4, data);
    __privateSet(this, _checksum, checksum2);
    __privateSet(this, _words, null);
  }
  /**
   *  The OWL-encoded data.
   */
  get _data() {
    return __privateGet(this, _data4);
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwl(__privateGet(this, _data4));
  }
  getWord(index) {
    const words2 = __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this);
    assertArgument(index >= 0 && index < words2.length, `invalid word index: ${index}`, "index", index);
    return words2[index];
  }
  getWordIndex(word) {
    return __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this).indexOf(word);
  }
};
_data4 = new WeakMap();
_checksum = new WeakMap();
_words = new WeakMap();
_WordlistOwl_instances = new WeakSet();
loadWords_fn = function() {
  if (__privateGet(this, _words) == null) {
    const words2 = this._decodeWords();
    const checksum2 = id(words2.join("\n") + "\n");
    if (checksum2 !== __privateGet(this, _checksum)) {
      throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
    }
    __privateSet(this, _words, words2);
  }
  return __privateGet(this, _words);
};

// node_modules/tronweb/node_modules/ethers/lib.esm/wordlists/lang-en.js
var words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
var checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
var wordlist = null;
var LangEn = class _LangEn extends WordlistOwl {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("en", words, checksum);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist == null) {
      wordlist = new _LangEn();
    }
    return wordlist;
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/wallet/mnemonic.js
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
}
function getLowerMask(bits) {
  return (1 << bits) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  assertNormalize("NFKD");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const words2 = wordlist2.split(mnemonic);
  assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
  let offset = 0;
  for (let i = 0; i < words2.length; i++) {
    let index = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = getBytes(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha2562(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
var _guard4 = {};
var Mnemonic = class _Mnemonic {
  /**
   *  @private
   */
  constructor(guard, entropy, phrase, password, wordlist2) {
    /**
     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
     *
     *  Use the [[wordlist]] ``split`` method to get the individual words.
     */
    __publicField(this, "phrase");
    /**
     *  The password used for this mnemonic. If no password is used this
     *  is the empty string (i.e. ``""``) as per the specification.
     */
    __publicField(this, "password");
    /**
     *  The wordlist for this mnemonic.
     */
    __publicField(this, "wordlist");
    /**
     *  The underlying entropy which the mnemonic encodes.
     */
    __publicField(this, "entropy");
    if (password == null) {
      password = "";
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    assertPrivate(guard, _guard4, "Mnemonic");
    defineProperties(this, { phrase, password, wordlist: wordlist2, entropy });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf22(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  /**
   *  Creates a new Mnemonic for the %%phrase%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromPhrase(phrase, password, wordlist2) {
    const entropy = mnemonicToEntropy(phrase, wordlist2);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist2);
    return new _Mnemonic(_guard4, entropy, phrase, password, wordlist2);
  }
  /**
   *  Create a new **Mnemonic** from the %%entropy%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromEntropy(_entropy, password, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist2);
    return new _Mnemonic(_guard4, hexlify(entropy), phrase, password, wordlist2);
  }
  /**
   *  Returns the phrase for %%mnemonic%%.
   */
  static entropyToPhrase(_entropy, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist2);
  }
  /**
   *  Returns the entropy for %%phrase%%.
   */
  static phraseToEntropy(phrase, wordlist2) {
    return mnemonicToEntropy(phrase, wordlist2);
  }
  /**
   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
   *
   *  This checks all the provided words belong to the %%wordlist%%,
   *  that the length is valid and the checksum is correct.
   */
  static isValidMnemonic(phrase, wordlist2) {
    try {
      mnemonicToEntropy(phrase, wordlist2);
      return true;
    } catch (error) {
    }
    return false;
  }
};

// node_modules/aes-js/lib.esm/aes.js
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AES_key;
var _AES_Kd;
var _AES_Ke;
var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
var S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
var T12 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt32(bytes3) {
  const result = [];
  for (let i = 0; i < bytes3.length; i += 4) {
    result.push(bytes3[i] << 24 | bytes3[i + 1] << 16 | bytes3[i + 2] << 8 | bytes3[i + 3]);
  }
  return result;
}
var AES = class _AES {
  get key() {
    return __classPrivateFieldGet(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof _AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet(this, _AES_Ke, [], "f");
    __classPrivateFieldSet(this, _AES_Kd, [], "f");
    for (let i = 0; i <= rounds; i++) {
      __classPrivateFieldGet(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt32(this.key);
    let index;
    for (let i = 0; i < KC; i++) {
      index = i >> 2;
      __classPrivateFieldGet(this, _AES_Ke, "f")[index][i % 4] = tk[i];
      __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
    }
    let rconpointer = 0;
    let t = KC, tt;
    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i2 = 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      } else {
        for (let i2 = 1; i2 < KC / 2; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i2 = KC / 2 + 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      }
      let i = 0, r, c;
      while (i < KC && t < roundKeyCount) {
        r = t >> 2;
        c = t % 4;
        __classPrivateFieldGet(this, _AES_Ke, "f")[r][c] = tk[i];
        __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - r][c] = tk[i++];
        t++;
      }
    }
    for (let r = 1; r < rounds; r++) {
      for (let c = 0; c < 4; c++) {
        tt = __classPrivateFieldGet(this, _AES_Kd, "f")[r][c];
        __classPrivateFieldGet(this, _AES_Kd, "f")[r][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet(this, _AES_Ke, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(plaintext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet(this, _AES_Ke, "f")[0][i];
    }
    for (let r = 1; r < rounds; r++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T12[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Ke, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet(this, _AES_Ke, "f")[rounds][i];
      result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet(this, _AES_Kd, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(ciphertext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet(this, _AES_Kd, "f")[0][i];
    }
    for (let r = 1; r < rounds; r++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Kd, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet(this, _AES_Kd, "f")[rounds][i];
      result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
};
_AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();

// node_modules/aes-js/lib.esm/mode.js
var ModeOfOperation = class {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name }
    });
  }
};

// node_modules/aes-js/lib.esm/mode-cbc.js
var _CBC_iv;
var _CBC_lastBlock;
_CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();

// node_modules/aes-js/lib.esm/mode-cfb.js
var __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CFB_instances;
var _CFB_iv;
var _CFB_shiftRegister;
var _CFB_shift;
_CFB_iv = /* @__PURE__ */ new WeakMap(), _CFB_shiftRegister = /* @__PURE__ */ new WeakMap(), _CFB_instances = /* @__PURE__ */ new WeakSet(), _CFB_shift = function _CFB_shift2(data) {
  const segmentSize = this.segmentSize / 8;
  __classPrivateFieldGet2(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet2(this, _CFB_shiftRegister, "f").subarray(segmentSize));
  __classPrivateFieldGet2(this, _CFB_shiftRegister, "f").set(data.subarray(0, segmentSize), 16 - segmentSize);
};

// node_modules/aes-js/lib.esm/mode-ctr.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CTR_remaining;
var _CTR_remainingIndex;
var _CTR_counter;
var CTR = class _CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, _CTR);
    _CTR_remaining.set(this, void 0);
    _CTR_remainingIndex.set(this, void 0);
    _CTR_counter.set(this, void 0);
    __classPrivateFieldSet2(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet3(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet2(this, _CTR_remaining, __classPrivateFieldGet3(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet2(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet3(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index = 15; index >= 0; --index) {
      __classPrivateFieldGet3(this, _CTR_counter, "f")[index] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet3(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i = 15; i >= 0; i--) {
      if (__classPrivateFieldGet3(this, _CTR_counter, "f")[i] === 255) {
        __classPrivateFieldGet3(this, _CTR_counter, "f")[i] = 0;
      } else {
        __classPrivateFieldGet3(this, _CTR_counter, "f")[i]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a3, _b;
    const crypttext = new Uint8Array(plaintext);
    for (let i = 0; i < crypttext.length; i++) {
      if (__classPrivateFieldGet3(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet2(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet3(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet2(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i] ^= __classPrivateFieldGet3(this, _CTR_remaining, "f")[__classPrivateFieldSet2(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet3(this, _CTR_remainingIndex, "f"), _a3 = _b++, _b), "f"), _a3];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
};
_CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();

// node_modules/aes-js/lib.esm/mode-ofb.js
var _OFB_iv;
var _OFB_lastPrecipher;
var _OFB_lastPrecipherIndex;
_OFB_iv = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipher = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipherIndex = /* @__PURE__ */ new WeakMap();

// node_modules/tronweb/node_modules/ethers/lib.esm/wallet/utils.js
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}

// node_modules/tronweb/node_modules/ethers/lib.esm/wallet/json-keystore.js
var defaultPath = "m/44'/60'/0'/0/0";
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes3(32);
  let N3 = 1 << 17, r = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N3 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  assertArgument(typeof N3 === "number" && N3 > 0 && Number.isSafeInteger(N3) && (BigInt(N3) & BigInt(N3 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N3);
  assertArgument(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return { name: "scrypt", dkLen: 32, salt, N: N3, r, p };
}
function _encryptKeystore(key, kdf, account, options) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes3(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes3(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat([macPrefix, ciphertext]));
  const data = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client = options.client != null ? options.client : `ethers/${version}`;
    const path = account.mnemonic.path || defaultPath;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes3(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = /* @__PURE__ */ new Date();
    const timestamp = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data.address;
    data["x-ethers"] = {
      client,
      gethFilename,
      path,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
async function encryptKeystoreJson(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt2(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}

// node_modules/tronweb/node_modules/ethers/lib.esm/wallet/hdwallet.js
var defaultPath2 = "m/44'/60'/0'/0/0";
var MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
var HardenedBit = 2147483648;
var N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Nibbles2 = "0123456789abcdef";
function zpad2(value, length) {
  let result = "";
  while (value) {
    result = Nibbles2[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value2) {
  const value = getBytes(_value2);
  const check = dataSlice(sha2562(sha2562(value)), 0, 4);
  const bytes3 = concat([value, check]);
  return encodeBase58(bytes3);
}
var _guard5 = {};
function ser_I(index, chainCode, publicKey, privateKey) {
  const data = new Uint8Array(37);
  if (index & HardenedBit) {
    assert(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data.set(getBytes(privateKey), 1);
  } else {
    data.set(getBytes(publicKey));
  }
  for (let i = 24; i >= 0; i -= 8) {
    data[33 + (i >> 3)] = index >> 24 - i & 255;
  }
  const I = getBytes(computeHmac("sha512", chainCode, data));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node, path) {
  const components = path.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path);
    components.shift();
  }
  let result = node;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
}
var _HDNodeWallet_instances, account_fn, _HDNodeWallet_static, fromSeed_fn;
var _HDNodeWallet = class _HDNodeWallet extends BaseWallet {
  /**
   *  @private
   */
  constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
    super(signingKey, provider);
    __privateAdd(this, _HDNodeWallet_instances);
    /**
     *  The compressed public key.
     */
    __publicField(this, "publicKey");
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    __publicField(this, "fingerprint");
    /**
     *  The parent fingerprint.
     */
    __publicField(this, "parentFingerprint");
    /**
     *  The mnemonic used to create this HD Node, if available.
     *
     *  Sources such as extended keys do not encode the mnemonic, in
     *  which case this will be ``null``.
     */
    __publicField(this, "mnemonic");
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    __publicField(this, "chainCode");
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provide full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  encode it.
     */
    __publicField(this, "path");
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    __publicField(this, "index");
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    __publicField(this, "depth");
    assertPrivate(guard, _guard5, "HDNodeWallet");
    defineProperties(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd1602(sha2562(this.publicKey)), 0, 4);
    defineProperties(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path,
      index,
      depth
    });
    defineProperties(this, { mnemonic });
  }
  connect(provider) {
    return new _HDNodeWallet(_guard5, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    return encryptKeystoreJsonSync(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpriv`` and can be used to
   *  reconstruct this HD Node to derive its children.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488ADE4",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      concat(["0x00", this.privateKey])
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Returns a neutered HD Node, which removes the private details
   *  of an HD Node.
   *
   *  A neutered node has no private key, but can be used to derive
   *  child addresses and other public data about the HD Node.
   */
  neuter() {
    return new HDNodeVoidWallet(_guard5, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N2, 32));
    return new _HDNodeWallet(_guard5, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
  }
  /**
   *  Return the HDNode for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
  /**
   *  Creates a new HD Node from %%extendedKey%%.
   *
   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
   *  or full HD Node ([[HDNodeWallet) respectively.
   */
  static fromExtendedKey(extendedKey) {
    const bytes3 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes3.length === 82 || encodeBase58Check(bytes3.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes3[4];
    const parentFingerprint = hexlify(bytes3.slice(5, 9));
    const index = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes3.slice(13, 45));
    const key = bytes3.slice(45, 78);
    switch (hexlify(bytes3.slice(0, 4))) {
      // Public Key
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key);
        return new HDNodeVoidWallet(_guard5, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
      }
      // Private Key
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new _HDNodeWallet(_guard5, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  /**
   *  Creates a new random HDNode.
   */
  static createRandom(password, path, wordlist2) {
    var _a3;
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath2;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromEntropy(randomBytes3(16), password, wordlist2);
    return __privateMethod(_a3 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a3, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Create an HD Node from %%mnemonic%%.
   */
  static fromMnemonic(mnemonic, path) {
    var _a3;
    if (!path) {
      path = defaultPath2;
    }
    return __privateMethod(_a3 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a3, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a mnemonic %%phrase%%.
   */
  static fromPhrase(phrase, password, path, wordlist2) {
    var _a3;
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath2;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist2);
    return __privateMethod(_a3 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a3, mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  /**
   *  Creates an HD Node from a %%seed%%.
   */
  static fromSeed(seed) {
    var _a3;
    return __privateMethod(_a3 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a3, seed, null);
  }
};
_HDNodeWallet_instances = new WeakSet();
account_fn = function() {
  const account = { address: this.address, privateKey: this.privateKey };
  const m = this.mnemonic;
  if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
    account.mnemonic = {
      path: this.path,
      locale: "en",
      entropy: m.entropy
    };
  }
  return account;
};
_HDNodeWallet_static = new WeakSet();
fromSeed_fn = function(_seed, mnemonic) {
  assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
  const seed = getBytes(_seed, "seed");
  assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
  const I = getBytes(computeHmac("sha512", MasterSecret, seed));
  const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
  return new _HDNodeWallet(_guard5, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic, null);
};
__privateAdd(_HDNodeWallet, _HDNodeWallet_static);
var HDNodeWallet = _HDNodeWallet;
var HDNodeVoidWallet = class _HDNodeVoidWallet extends VoidSigner {
  /**
   *  @private
   */
  constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
    super(address, provider);
    /**
     *  The compressed public key.
     */
    __publicField(this, "publicKey");
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    __publicField(this, "fingerprint");
    /**
     *  The parent node fingerprint.
     */
    __publicField(this, "parentFingerprint");
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    __publicField(this, "chainCode");
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provider full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  enocde it.
     */
    __publicField(this, "path");
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    __publicField(this, "index");
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    __publicField(this, "depth");
    assertPrivate(guard, _guard5, "HDNodeVoidWallet");
    defineProperties(this, { publicKey });
    const fingerprint = dataSlice(ripemd1602(sha2562(publicKey)), 0, 4);
    defineProperties(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path,
      index,
      depth
    });
  }
  connect(provider) {
    return new _HDNodeVoidWallet(_guard5, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpub`` and can be used to
   *  reconstruct this neutered key to derive its children addresses.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488B21E",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
    const Ki = SigningKey.addPoints(IL, this.publicKey, true);
    const address = computeAddress(Ki);
    return new _HDNodeVoidWallet(_guard5, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);
  }
  /**
   *  Return the signer for %%path%% from this node.
   */
  derivePath(path) {
    return derivePath(this, path);
  }
};

// node_modules/tronweb/node_modules/ethers/lib.esm/wordlists/wordlists-browser.js
var wordlists = {
  en: LangEn.wordlist()
};

// node_modules/tronweb/lib/esm/utils/fragments.js
var _a2;
function setify2(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
var _kwVisib2 = "constant external internal payable private public pure view";
var KwVisib2 = setify2(_kwVisib2.split(" "));
var _kwTypes2 = "constructor error event fallback function receive struct";
var KwTypes2 = setify2(_kwTypes2.split(" "));
var _kwModifiers2 = "calldata memory storage payable indexed";
var KwModifiers2 = setify2(_kwModifiers2.split(" "));
var _kwOther2 = "tuple returns";
var _keywords2 = [_kwTypes2, _kwModifiers2, _kwOther2, _kwVisib2].join(" ");
var Keywords2 = setify2(_keywords2.split(" "));
var SimpleTokens2 = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
var regexWhitespacePrefix2 = new RegExp("^(\\s*)");
var regexNumberPrefix2 = new RegExp("^([0-9]+)");
var regexIdPrefix2 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
var regexId2 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType2 = new RegExp("^(trcToken|address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var _offset3, _tokens2, _TokenString_instances2, subTokenString_fn2;
var TokenString2 = class {
  constructor(tokens) {
    __privateAdd(this, _TokenString_instances2);
    __privateAdd(this, _offset3);
    __privateAdd(this, _tokens2);
    __privateSet(this, _offset3, 0);
    __privateSet(this, _tokens2, tokens.slice());
  }
  get offset() {
    return __privateGet(this, _offset3);
  }
  get length() {
    return __privateGet(this, _tokens2).length - __privateGet(this, _offset3);
  }
  clone() {
    return new _a2(__privateGet(this, _tokens2));
  }
  reset() {
    __privateSet(this, _offset3, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = __privateMethod(this, _TokenString_instances2, subTokenString_fn2).call(this, __privateGet(this, _offset3) + 1, top.match + 1);
    __privateSet(this, _offset3, top.match + 1);
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (__privateGet(this, _offset3) < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(__privateMethod(this, _TokenString_instances2, subTokenString_fn2).call(this, __privateGet(this, _offset3) + 1, link));
      __privateSet(this, _offset3, link);
    }
    __privateSet(this, _offset3, top.match + 1);
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (__privateGet(this, _offset3) >= __privateGet(this, _tokens2).length) {
      throw new Error("out-of-bounds");
    }
    return __privateGet(this, _tokens2)[__privateGet(this, _offset3)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    __privateWrapper(this, _offset3)._++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = __privateGet(this, _offset3); i < __privateGet(this, _tokens2).length; i++) {
      const token = __privateGet(this, _tokens2)[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
_offset3 = new WeakMap();
_tokens2 = new WeakMap();
_TokenString_instances2 = new WeakSet();
subTokenString_fn2 = function(from = 0, to = 0) {
  return new _a2(__privateGet(this, _tokens2).slice(from, to).map((t) => {
    return Object.freeze(Object.assign({}, t, {
      match: t.match - from,
      linkBack: t.linkBack - from,
      linkNext: t.linkNext - from
    }));
  }));
};
_a2 = TokenString2;
function lex2(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  const brackets = [];
  const commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix2);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = {
      depth: brackets.length,
      linkBack: -1,
      linkNext: -1,
      match: -1,
      type: "",
      text: "",
      offset,
      value: -1
    };
    tokens.push(token);
    const type = SimpleTokens2[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix2);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords2.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType2)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix2);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString2(tokens.map((t) => Object.freeze(t)));
}
function allowSingle2(set, allowed) {
  const included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName2(type, tokens) {
  if (tokens.peekKeyword(KwTypes2)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords2(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability2(tokens) {
  const modifiers = consumeKeywords2(tokens, KwVisib2);
  allowSingle2(modifiers, setify2("constant payable nonpayable".split(" ")));
  allowSingle2(modifiers, setify2("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams2(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType2.from(t, allowIndexed));
}
function consumeGas2(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi2(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens: ${tokens.toString()}`);
  }
}
var regexArrayType2 = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType2(type) {
  const match = type.match(regexType2);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
var _guard6 = {};
var internal3 = Symbol.for("_ethers_internal");
var ParamTypeInternal2 = "_ParamTypeInternal";
var ErrorFragmentInternal2 = "_ErrorInternal";
var EventFragmentInternal2 = "_EventInternal";
var ConstructorFragmentInternal2 = "_ConstructorInternal";
var FallbackFragmentInternal2 = "_FallbackInternal";
var FunctionFragmentInternal2 = "_FunctionInternal";
var StructFragmentInternal2 = "_StructInternal";
var _ParamType_instances2, walkAsync_fn2;
var _ParamType2 = class _ParamType2 {
  /**
   *  @private
   */
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    __privateAdd(this, _ParamType_instances2);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    __publicField(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    __publicField(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    __publicField(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    __publicField(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    __publicField(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayChildren");
    assertPrivate(guard, _guard6, "ParamType");
    Object.defineProperty(this, internal3, { value: ParamTypeInternal2 });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c) => JSON.parse(c.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        if (format !== "sighash") {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process2) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      return value.map((v) => {
        var _a3;
        return (_a3 = this.arrayChildren) == null ? void 0 : _a3.walk(v, process2);
      });
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      return value.map((v, i) => {
        var _a3;
        return (_a3 = this.components) == null ? void 0 : _a3[i].walk(v, process2);
      });
    }
    return process2(this.type, value);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS naes by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process2) {
    const promises = [];
    const result = [value];
    __privateMethod(this, _ParamType_instances2, walkAsync_fn2).call(this, promises, value, process2, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType2.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _ParamType2.from(lex2(obj), allowIndexed);
    } else if (obj instanceof TokenString2) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords2(obj, setify2(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => _ParamType2.from(t));
        type2 = `tuple(${comps.map((c) => c.format()).join(",")})`;
      } else {
        type2 = verifyBasicType2(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType2(_guard6, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords2(obj, KwModifiers2);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType2(_guard6, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId2), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    const arrayMatch = type.match(regexArrayType2);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType2.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType2(_guard6, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c) => _ParamType2.from(c)) : null;
      const tuple = new _ParamType2(_guard6, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType2(obj.type);
    return new _ParamType2(_guard6, name || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal3] === ParamTypeInternal2;
  }
};
_ParamType_instances2 = new WeakSet();
walkAsync_fn2 = function(promises, value, process2, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    const childType = this.arrayChildren;
    const result2 = value.slice();
    result2.forEach((value2, index) => {
      var _a3;
      __privateMethod(_a3 = childType, _ParamType_instances2, walkAsync_fn2).call(_a3, promises, value2, process2, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  if (this.isTuple()) {
    const components = this.components;
    let result2;
    if (Array.isArray(value)) {
      result2 = value.slice();
    } else {
      if (value == null || typeof value !== "object") {
        throw new Error("invalid tuple value");
      }
      result2 = components.map((param) => {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error(`missing value for component ${param.name}`);
        }
        return value[param.name];
      });
    }
    if (result2.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    result2.forEach((value2, index) => {
      var _a3;
      __privateMethod(_a3 = components[index], _ParamType_instances2, walkAsync_fn2).call(_a3, promises, value2, process2, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  const result = process2(this.type, value);
  if (result.then) {
    promises.push(async function() {
      setValue(await result);
    }());
  } else {
    setValue(result);
  }
};
var ParamType2 = _ParamType2;
var Fragment2 = class _Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    /**
     *  The type of the fragment.
     */
    __publicField(this, "type");
    /**
     *  The inputs for the fragment.
     */
    __publicField(this, "inputs");
    assertPrivate(guard, _guard6, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        _Fragment.from(JSON.parse(obj));
      } catch (e) {
      }
      return _Fragment.from(lex2(obj));
    }
    if (obj instanceof TokenString2) {
      const type = obj.peekKeyword(KwTypes2);
      switch (type) {
        case "constructor":
          return ConstructorFragment2.from(obj);
        case "error":
          return ErrorFragment2.from(obj);
        case "event":
          return EventFragment2.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment2.from(obj);
        case "function":
          return FunctionFragment2.from(obj);
        case "struct":
          return StructFragment2.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment2.from(obj);
        case "error":
          return ErrorFragment2.from(obj);
        case "event":
          return EventFragment2.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment2.from(obj);
        case "function":
          return FunctionFragment2.from(obj);
        case "struct":
          return StructFragment2.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment2.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment2.isFragment(value);
  }
};
var NamedFragment2 = class extends Fragment2 {
  /**
   *  @private
   */
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    /**
     *  The name of the fragment.
     */
    __publicField(this, "name");
    assertArgument(typeof name === "string" && name.match(regexId2), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
};
function joinParams2(format, params) {
  return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
}
var ErrorFragment2 = class _ErrorFragment extends NamedFragment2 {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal3, { value: ErrorFragmentInternal2 });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams2(format, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _ErrorFragment.from(lex2(obj));
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("error", obj);
      const inputs = consumeParams2(obj);
      consumeEoi2(obj);
      return new _ErrorFragment(_guard6, name, inputs);
    }
    return new _ErrorFragment(_guard6, obj.name, obj.inputs ? obj.inputs.map(ParamType2.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === ErrorFragmentInternal2;
  }
};
var EventFragment2 = class _EventFragment extends NamedFragment2 {
  /**
   *  @private
   */
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    /**
     *  Whether this event is anonymous.
     */
    __publicField(this, "anonymous");
    Object.defineProperty(this, internal3, { value: EventFragmentInternal2 });
    defineProperties(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams2(format, this.inputs));
    if (format !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name, params) {
    params = (params || []).map((p) => ParamType2.from(p));
    const fragment = new _EventFragment(_guard6, name, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (_EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _EventFragment.from(lex2(obj));
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("event", obj);
      const inputs = consumeParams2(obj, true);
      const anonymous = !!consumeKeywords2(obj, setify2(["anonymous"])).has("anonymous");
      consumeEoi2(obj);
      return new _EventFragment(_guard6, name, inputs, anonymous);
    }
    return new _EventFragment(_guard6, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType2.from(p, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === EventFragmentInternal2;
  }
};
var ConstructorFragment2 = class _ConstructorFragment extends Fragment2 {
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    /**
     *  Whether the constructor can receive an endowment.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal3, {
      value: ConstructorFragmentInternal2
    });
    defineProperties(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format) {
    assert(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
      operation: "format(sighash)"
    });
    if (format === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [`constructor${joinParams2(format, this.inputs)}`];
    result.push(this.payable ? "payable" : "nonpayable");
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (_ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _ConstructorFragment.from(lex2(obj));
    } else if (obj instanceof TokenString2) {
      consumeKeywords2(obj, setify2(["constructor"]));
      const inputs = consumeParams2(obj);
      const payable = !!consumeKeywords2(obj, setify2(["payable"])).has("payable");
      const gas = consumeGas2(obj);
      consumeEoi2(obj);
      return new _ConstructorFragment(_guard6, "constructor", inputs, payable, gas);
    }
    return new _ConstructorFragment(_guard6, "constructor", obj.inputs ? obj.inputs.map(ParamType2.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === ConstructorFragmentInternal2;
  }
};
var FallbackFragment2 = class _FallbackFragment extends Fragment2 {
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    Object.defineProperty(this, internal3, { value: FallbackFragmentInternal2 });
    defineProperties(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _FallbackFragment.from(lex2(obj));
    } else if (obj instanceof TokenString2) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify2(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify2(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams2(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords2(obj, setify2(["payable"]));
        consumeEoi2(obj);
        return new _FallbackFragment(_guard6, [], true);
      }
      let inputs = consumeParams2(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType2.from("bytes")];
      }
      const mutability = consumeMutability2(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords2(obj, setify2(["returns"])).has("returns")) {
        const outputs = consumeParams2(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi2(obj);
      return new _FallbackFragment(_guard6, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new _FallbackFragment(_guard6, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType2.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new _FallbackFragment(_guard6, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === FallbackFragmentInternal2;
  }
};
var FunctionFragment2 = class _FunctionFragment extends NamedFragment2 {
  /**
   *  @private
   */
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    __publicField(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    __publicField(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    __publicField(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal3, { value: FunctionFragmentInternal2 });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, {
      constant,
      gas,
      outputs,
      payable,
      stateMutability
    });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams2(format, this.inputs));
    if (format !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams2(format, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name, params) {
    params = (params || []).map((p) => ParamType2.from(p));
    const fragment = new _FunctionFragment(_guard6, name, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (_FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return _FunctionFragment.from(lex2(obj));
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("function", obj);
      const inputs = consumeParams2(obj);
      const mutability = consumeMutability2(obj);
      let outputs = [];
      if (consumeKeywords2(obj, setify2(["returns"])).has("returns")) {
        outputs = consumeParams2(obj);
      }
      const gas = consumeGas2(obj);
      consumeEoi2(obj);
      return new _FunctionFragment(_guard6, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new _FunctionFragment(_guard6, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType2.from) : [], obj.outputs ? obj.outputs.map(ParamType2.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === FunctionFragmentInternal2;
  }
};
var StructFragment2 = class _StructFragment extends NamedFragment2 {
  /**
   *  @private
   */
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal3, { value: StructFragmentInternal2 });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      return _StructFragment.from(lex2(obj));
    } else if (obj instanceof TokenString2) {
      const name = consumeName2("struct", obj);
      const inputs = consumeParams2(obj);
      consumeEoi2(obj);
      return new _StructFragment(_guard6, name, inputs);
    }
    return new _StructFragment(_guard6, obj.name, obj.inputs ? obj.inputs.map(ParamType2.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal3] === StructFragmentInternal2;
  }
};

// node_modules/tronweb/lib/esm/utils/interface.js
var LogDescription2 = class {
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Event.
     */
    __publicField(this, "name");
    /**
     *  The full Event signature.
     */
    __publicField(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    __publicField(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    __publicField(this, "args");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature,
      topic,
      args
    });
  }
};
var TransactionDescription2 = class {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    __publicField(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    __publicField(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    __publicField(this, "value");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector,
      value
    });
  }
};
var ErrorDescription2 = class {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    /**
     *  The matching fragment.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Error.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    __publicField(this, "args");
    /**
     *  The full Error signature.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Error.
     */
    __publicField(this, "selector");
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector
    });
  }
};
var Indexed2 = class {
  /**
   *  @_ignore:
   */
  constructor(hash3) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    __publicField(this, "hash");
    /**
     *  @_ignore:
     */
    __publicField(this, "_isIndexed");
    defineProperties(this, { hash: hash3, _isIndexed: true });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
};
var PanicReasons3 = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors2 = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons3[code.toString()]) {
        reason = PanicReasons3[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};
var _errors2, _events2, _functions2, _abiCoder2, _Interface_instances2, getFunction_fn2, getEvent_fn2;
var _Interface2 = class _Interface2 {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    __privateAdd(this, _Interface_instances2);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    __publicField(this, "fragments");
    /**
     *  The Contract constructor.
     */
    __publicField(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    __publicField(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    __publicField(this, "receive");
    __privateAdd(this, _errors2);
    __privateAdd(this, _events2);
    __privateAdd(this, _functions2);
    //    #structs: Map<string, StructFragment>;
    __privateAdd(this, _abiCoder2);
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    __privateSet(this, _functions2, /* @__PURE__ */ new Map());
    __privateSet(this, _errors2, /* @__PURE__ */ new Map());
    __privateSet(this, _events2, /* @__PURE__ */ new Map());
    const frags = [];
    for (const a of abi) {
      try {
        frags.push(Fragment2.from(a));
      } catch (error) {
        console.log("EE", error);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    __privateSet(this, _abiCoder2, this.getAbiCoder());
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, {
            deploy: fragment
          });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = __privateGet(this, _functions2);
          break;
        case "event":
          bucket = __privateGet(this, _events2);
          break;
        case "error":
          bucket = __privateGet(this, _errors2);
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment2.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f2) => f2.format(format));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key) {
    const fragment = __privateMethod(this, _Interface_instances2, getFunction_fn2).call(this, key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key) {
    return !!__privateMethod(this, _Interface_instances2, getFunction_fn2).call(this, key, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key, values) {
    return __privateMethod(this, _Interface_instances2, getFunction_fn2).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names = Array.from(__privateGet(this, _functions2).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(__privateGet(this, _functions2).get(name), i);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key) {
    const fragment = __privateMethod(this, _Interface_instances2, getEvent_fn2).call(this, key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key) {
    return !!__privateMethod(this, _Interface_instances2, getEvent_fn2).call(this, key, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key, values) {
    return __privateMethod(this, _Interface_instances2, getEvent_fn2).call(this, key, values || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names = Array.from(__privateGet(this, _events2).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(__privateGet(this, _events2).get(name), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors2[selector]) {
        return ErrorFragment2.from(BuiltinErrors2[selector].signature);
      }
      for (const fragment of __privateGet(this, _errors2).values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of __privateGet(this, _errors2)) {
        if (name.split(
          "("
          /* fix:) */
        )[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment2.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment2.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment2.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment2.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment2.from("error Panic(uint256)");
    }
    const result = __privateGet(this, _errors2).get(key);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names = Array.from(__privateGet(this, _errors2).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name = names[i];
      callback(__privateGet(this, _errors2).get(name), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
      getSelector(fragment: ErrorFragment | FunctionFragment): string {
          if (typeof(fragment) === "string") {
              const matches: Array<Fragment> = [ ];
  
              try { matches.push(this.getFunction(fragment)); } catch (error) { }
              try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
              if (matches.length === 0) {
                  logger.throwArgumentError("unknown fragment", "key", fragment);
              } else if (matches.length > 1) {
                  logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
              }
  
              fragment = matches[0];
          }
  
          return dataSlice(id(fragment.format()), 0, 4);
      }
          */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data) {
    return __privateGet(this, _abiCoder2).decode(params, data);
  }
  _encodeParams(params, values) {
    return __privateGet(this, _abiCoder2).encode(params, values);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes3 = getBytesCopy(data);
    if (bytes3.length % 32 === 0) {
      try {
        return __privateGet(this, _abiCoder2).decode(fragment.outputs, bytes3);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes3),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data5, tx) {
    const data = getBytes(_data5, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = __privateGet(this, _abiCoder2).decode(ef.inputs, data.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(__privateGet(this, _abiCoder2).encode(fragment.outputs, values || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", {
      count: values.length,
      expectedCount: fragment.inputs.length
    });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      }
      if (param.type === "address") {
        __privateGet(this, _abiCoder2).encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(__privateGet(this, _abiCoder2).encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: __privateGet(this, _abiCoder2).encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType2.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? __privateGet(this, _abiCoder2).decode(indexed, concat(topics)) : null;
    const resultNonIndexed = __privateGet(this, _abiCoder2).decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed2(null);
        } else if (dynamic[index]) {
          value = new Indexed2(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder2).decode(fragment.inputs, data.slice(4));
    return new TransactionDescription2(fragment, fragment.selector, args, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription2(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder2).decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription2(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface2) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface2(JSON.parse(value));
    }
    if (typeof value.format === "function") {
      return new _Interface2(value.format("json"));
    }
    return new _Interface2(value);
  }
};
_errors2 = new WeakMap();
_events2 = new WeakMap();
_functions2 = new WeakMap();
_abiCoder2 = new WeakMap();
_Interface_instances2 = new WeakSet();
// Find a function definition by any means necessary (unless it is ambiguous)
getFunction_fn2 = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const selector = key.toLowerCase();
    for (const fragment of __privateGet(this, _functions2).values()) {
      if (selector === fragment.selector) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _functions2)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      const lastValue = values.length > 0 ? values[values.length - 1] : null;
      let valueLength = values.length;
      let allowOptions = true;
      if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j = 0; j < values.length; j++) {
          if (!Typed.isTyped(values[j])) {
            continue;
          }
          if (j >= inputs.length) {
            if (values[j].type === "overrides") {
              continue;
            }
            matching.splice(i, 1);
            break;
          }
          if (values[j].type !== inputs[j].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
      const lastArg = values[values.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
      assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _functions2).get(FunctionFragment2.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
// Find an event definition by any means necessary (unless it is ambiguous)
getEvent_fn2 = function(key, values, forceUnique) {
  if (isHexString(key)) {
    const eventTopic = key.toLowerCase();
    for (const fragment of __privateGet(this, _events2).values()) {
      if (eventTopic === fragment.topicHash) {
        return fragment;
      }
    }
    return null;
  }
  if (key.indexOf("(") === -1) {
    const matching = [];
    for (const [name, fragment] of __privateGet(this, _events2)) {
      if (name.split(
        "("
        /* fix:) */
      )[0] === key) {
        matching.push(fragment);
      }
    }
    if (values) {
      for (let i = matching.length - 1; i >= 0; i--) {
        if (matching[i].inputs.length < values.length) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j = 0; j < values.length; j++) {
          if (!Typed.isTyped(values[j])) {
            continue;
          }
          if (values[j].type !== inputs[j].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
      assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
    }
    return matching[0];
  }
  const result = __privateGet(this, _events2).get(EventFragment2.from(key).format());
  if (result) {
    return result;
  }
  return null;
};
var Interface2 = _Interface2;

// node_modules/tronweb/lib/esm/utils/ethersUtils.js
var splitSignature = (sigBytes) => Signature.from(sigBytes);
var joinSignature = (splitSig) => Signature.from(splitSig).serialized;
var arrayify = (value) => getBytes(value);
var FormatTypes = {
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
};
var isValidMnemonic = Mnemonic.isValidMnemonic;
computeHmac.register((algorithm, key, data) => {
  return computeHmac._(algorithm, Buffer.from(key), Buffer.from(data));
});

// node_modules/tronweb/lib/esm/utils/address.js
var ADDRESS_SIZE = 34;
var ADDRESS_PREFIX = "41";
var ADDRESS_PREFIX_BYTE = 65;
var ADDRESS_PREFIX_REGEX = /^(41)/;
var TRON_BIP39_PATH_PREFIX = "m/44'/195'";
var TRON_BIP39_PATH_INDEX_0 = TRON_BIP39_PATH_PREFIX + "/0'/0/0";
function fromHex(address) {
  if (!isHex(address))
    return address;
  return getBase58CheckAddress(hexStr2byteArray(address.replace(/^0x/, ADDRESS_PREFIX)));
}
function toHex(address) {
  if (isHex(address))
    return address.toLowerCase().replace(/^0x/, ADDRESS_PREFIX);
  return byteArray2hexStr(decodeBase58Address(address)).toLowerCase();
}
function getChecksumAddress2(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = hexStr2byteArray(keccak256(expanded).slice(2));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return ADDRESS_PREFIX + chars.join("");
}
function toChecksumAddress(address) {
  if (!isAddress2(address))
    throw new Error(`'${address}' is not a valid address string`);
  return getChecksumAddress2(toHex(address));
}
function isChecksumAddress(address) {
  if (!isHex(address) || address.length !== 42)
    return false;
  try {
    return toChecksumAddress(address) === address;
  } catch {
    return false;
  }
}
function fromPrivateKey(privateKey, strict = false) {
  try {
    return pkToAddress(privateKey, strict);
  } catch {
    return false;
  }
}
function isAddress2(address) {
  if (!address || !isString(address))
    return false;
  if (address.length === 42) {
    try {
      return isAddress2(getBase58CheckAddress(hexStr2byteArray(address)));
    } catch (err) {
      return false;
    }
  }
  try {
    return isAddressValid(address);
  } catch (err) {
    return false;
  }
}

// node_modules/tronweb/lib/esm/utils/base58.js
var base58_exports = {};
__export(base58_exports, {
  decode58: () => decode58,
  encode58: () => encode58
});
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var ALPHABET_MAP = {};
for (let i = 0; i < ALPHABET.length; i++)
  ALPHABET_MAP[ALPHABET.charAt(i)] = i;
var BASE2 = 58;
function encode58(buffer) {
  if (buffer.length === 0)
    return "";
  let i;
  let j;
  const digits = [0];
  for (i = 0; i < buffer.length; i++) {
    for (j = 0; j < digits.length; j++)
      digits[j] <<= 8;
    digits[0] += buffer[i];
    let carry = 0;
    for (j = 0; j < digits.length; ++j) {
      digits[j] += carry;
      carry = digits[j] / BASE2 | 0;
      digits[j] %= BASE2;
    }
    while (carry) {
      digits.push(carry % BASE2);
      carry = carry / BASE2 | 0;
    }
  }
  for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++)
    digits.push(0);
  return digits.reverse().map((digit) => ALPHABET[digit]).join("");
}
function decode58(string) {
  if (string.length === 0)
    return [];
  let i;
  let j;
  const bytes3 = [0];
  for (i = 0; i < string.length; i++) {
    const c = string[i];
    if (!(c in ALPHABET_MAP))
      throw new Error("Non-base58 character");
    for (j = 0; j < bytes3.length; j++)
      bytes3[j] *= BASE2;
    bytes3[0] += ALPHABET_MAP[c];
    let carry = 0;
    for (j = 0; j < bytes3.length; ++j) {
      bytes3[j] += carry;
      carry = bytes3[j] >> 8;
      bytes3[j] &= 255;
    }
    while (carry) {
      bytes3.push(carry & 255);
      carry >>= 8;
    }
  }
  for (i = 0; string[i] === "1" && i < string.length - 1; i++)
    bytes3.push(0);
  return bytes3.reverse();
}

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString: toString2 } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString2.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray: isArray2 } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString2 = typeOfTest("string");
var isFunction2 = typeOfTest("function");
var isNumber2 = typeOfTest("number");
var isObject2 = (thing) => thing !== null && typeof thing === "object";
var isBoolean2 = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject2(val) && isFunction2(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction2(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray2(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction2(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray2(thing)) return thing;
  let i = thing.length;
  if (!isNumber2(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction2(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction2(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray2(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject2(thing) || isFunction2(thing)) && isFunction2(thing.then) && isFunction2(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction2(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var utils_default = {
  isArray: isArray2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString2,
  isNumber: isNumber2,
  isBoolean: isBoolean2,
  isObject: isObject2,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction2,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString3(encoder) {
  const _encode2 = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode2(pair[0]) + "=" + _encode2(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode2 = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode2);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports2,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value2, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value2);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value2, _header) => setHeader(_value2, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes3 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes3[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes3[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && isRelativeUrl || allowAbsoluteUrls == false) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b2, prop, caseless) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(a, b2, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b2) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a, b2) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b2, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b2), prop, true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes3 = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes3 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request2 = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request2.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request2 = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request2.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request2.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request2.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.8.3";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator2, version3, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version3 ? " in " + version3 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version3 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version3 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/tronweb/lib/esm/lib/providers/HttpProvider.js
var HttpProvider = class {
  constructor(host, timeout = 3e4, user = "", password = "", headers = {}, statusPage = "/") {
    __publicField(this, "host");
    __publicField(this, "timeout");
    __publicField(this, "user");
    __publicField(this, "password");
    __publicField(this, "headers");
    __publicField(this, "statusPage");
    __publicField(this, "instance");
    if (!isValidURL(host))
      throw new Error("Invalid URL provided to HttpProvider");
    if (isNaN(timeout) || timeout < 0)
      throw new Error("Invalid timeout duration provided");
    if (!isObject(headers))
      throw new Error("Invalid headers object provided");
    host = host.replace(/\/+$/, "");
    this.host = host;
    this.timeout = timeout;
    this.user = user;
    this.password = password;
    this.headers = headers;
    this.statusPage = statusPage;
    this.instance = axios_default.create({
      baseURL: host,
      timeout,
      headers,
      auth: user ? {
        username: user,
        password
      } : void 0
    });
  }
  setStatusPage(statusPage = "/") {
    this.statusPage = statusPage;
  }
  async isConnected(statusPage = this.statusPage) {
    return this.request(statusPage).then((data) => {
      return hasProperties(data, "blockID", "block_header");
    }).catch(() => false);
  }
  request(url, payload = {}, method = "get") {
    method = method.toLowerCase();
    return this.instance.request({
      data: method == "post" && Object.keys(payload).length ? payload : null,
      params: method == "get" && payload,
      url,
      method
    }).then(({ data }) => data);
  }
};

// node_modules/tronweb/lib/esm/lib/providers/index.js
var providers = { HttpProvider };

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// node_modules/tronweb/lib/esm/tronweb.js
var import_semver2 = __toESM(require_semver2(), 1);

// node_modules/tronweb/lib/esm/utils/abi.js
var abi_exports = {};
__export(abi_exports, {
  decodeParams: () => decodeParams,
  decodeParamsV2ByABI: () => decodeParamsV2ByABI,
  encodeParams: () => encodeParams,
  encodeParamsV2ByABI: () => encodeParamsV2ByABI
});
var abiCoder = new AbiCoder();
function _addressToHex(value) {
  return TronWeb.address.toHex(value).replace(ADDRESS_PREFIX_REGEX, "0x");
}
function decodeParams(names, types, output3, ignoreMethodHash = false) {
  if (ignoreMethodHash && output3.replace(/^0x/, "").length % 64 === 8)
    output3 = "0x" + output3.replace(/^0x/, "").substring(8);
  if (output3.replace(/^0x/, "").length % 64) {
    throw new Error("The encoded string is not valid. Its length must be a multiple of 64.");
  }
  types = types.map((type) => {
    if (/trcToken/.test(type)) {
      type = type.replace(/trcToken/, "uint256");
    }
    return type;
  });
  return abiCoder.decode(types, output3).reduce((obj, arg, index) => {
    if (types[index] == "address") {
      arg = ADDRESS_PREFIX + arg.substr(2).toLowerCase();
    }
    if (names.length) {
      obj[names[index]] = arg;
    } else {
      obj.push(arg);
    }
    return obj;
  }, names.length ? {} : []);
}
function encodeParams(types, values) {
  for (let i = 0; i < types.length; i++) {
    if (types[i] === "address") {
      values[i] = TronWeb.address.toHex(values[i]).replace(ADDRESS_PREFIX_REGEX, "0x");
    }
  }
  return abiCoder.encode(types, values);
}
function extractSize(type) {
  const size = type.match(/([a-zA-Z0-9])(\[.*\])/);
  return size ? size[2] : "";
}
function extractArrayDim(type) {
  const size = extractSize(type);
  return (size.match(/\]\[/g) || []).length + 1;
}
function encodeParamsV2ByABI(funABI, args) {
  const types = [];
  const buildFullTypeDefinition = (typeDef) => {
    if (typeDef && typeDef.type.indexOf("tuple") === 0 && typeDef.components) {
      const innerTypes = typeDef.components.map((innerType) => {
        return buildFullTypeDefinition(innerType);
      });
      return `tuple(${innerTypes.join(",")})${extractSize(typeDef.type)}`;
    }
    if (/trcToken/.test(typeDef.type))
      return typeDef.type.replace(/trcToken/, "uint256");
    return typeDef.type;
  };
  const convertTypes = (types2) => {
    for (let i = 0; i < types2.length; i++) {
      const type = types2[i];
      if (/trcToken/.test(type))
        types2[i] = type.replace(/trcToken/, "uint256");
    }
  };
  const convertAddresses = (addrArr) => {
    if (Array.isArray(addrArr)) {
      addrArr.forEach((addrs, i) => {
        addrArr[i] = convertAddresses(addrs);
      });
      return addrArr;
    } else {
      return _addressToHex(addrArr);
    }
  };
  const mapTuple = (components, args2, dimension) => {
    if (dimension > 1) {
      if (args2.length) {
        args2.forEach((arg) => {
          mapTuple(components, arg, dimension - 1);
        });
      }
    } else {
      if (args2.length && dimension) {
        args2.forEach((arg) => {
          encodeArgs(components, arg);
        });
      }
    }
  };
  const encodeArgs = (inputs = [], args2) => {
    if (inputs.length)
      inputs.forEach((input, i) => {
        const type = input.type;
        if (args2[i]) {
          if (type === "address")
            args2[i] = _addressToHex(args2[i]);
          else if (type.match(/^([^\x5b]*)(\x5b|$)/)[0] === "address[")
            convertAddresses(args2[i]);
          else if (type.indexOf("tuple") === 0)
            if (extractSize(type)) {
              const dimension = extractArrayDim(type);
              mapTuple(input.components, args2[i], dimension);
            } else
              encodeArgs(input.components, args2[i]);
        }
      });
  };
  if (funABI.inputs && funABI.inputs.length) {
    for (let i = 0; i < funABI.inputs.length; i++) {
      const type = funABI.inputs[i].type;
      if (type === "bool" && args[i] === "false") {
        args[i] = false;
      }
      types.push(type.indexOf("tuple") === 0 ? buildFullTypeDefinition(funABI.inputs[i]) : type);
      if (args.length < types.length) {
        args.push("");
      }
    }
  }
  encodeArgs(funABI.inputs, args);
  convertTypes(types);
  return abiCoder.encode(types, args);
}
function decodeParamsV2ByABI(funABI, data) {
  const convertTypeNames = (types) => {
    for (let i = 0; i < types.length; i++) {
      const type = types[i];
      if (/^trcToken/.test(type))
        types[i] = type.replace(/^trcToken/, "uint256");
    }
  };
  const convertAddresses = (addrArr) => {
    if (Array.isArray(addrArr)) {
      addrArr.forEach((addrs, i) => {
        addrArr[i] = convertAddresses(addrs);
      });
      return addrArr;
    } else {
      return TronWeb.address.toHex(addrArr);
    }
  };
  const mapTuple = (components, args, dimension) => {
    if (dimension > 1) {
      if (args.length) {
        args.forEach((arg) => {
          mapTuple(components, arg, dimension - 1);
        });
      }
    } else {
      if (args.length && dimension) {
        args.forEach((arg) => {
          decodeResult(components, arg);
        });
      }
    }
  };
  const buildFullTypeNameDefinition = (typeDef) => {
    const name = typeDef.name ? ` ${typeDef.name}` : "";
    if (typeDef && typeDef.type.indexOf("tuple") === 0 && typeDef.components) {
      const innerTypes = typeDef.components.map((innerType) => {
        return buildFullTypeNameDefinition(innerType);
      });
      return `tuple(${innerTypes.join(",")})${extractSize(typeDef.type)}${name}`;
    }
    if (/trcToken/.test(typeDef.type))
      return typeDef.type.replace(/trcToken/, "uint256") + name;
    return typeDef.type + name;
  };
  const decodeResult = (outputs, result) => {
    if (outputs.length)
      outputs.forEach((output3, i) => {
        const { type, name } = output3;
        if (result[i]) {
          if (type === "address") {
            result[i] = TronWeb.address.toHex(result[i]);
            if (name)
              result[name] = TronWeb.address.toHex(result[i]);
          } else if (type.match(/^([^\x5b]*)(\x5b|$)/)[0] === "address[") {
            convertAddresses(result[i]);
            if (name)
              result[name] = convertAddresses(result[i]);
          } else if (type.indexOf("tuple") === 0) {
            if (extractSize(type)) {
              const dimension = extractArrayDim(type);
              mapTuple(output3.components, result[i], dimension);
            } else
              decodeResult(output3.components, result[i]);
            if (name)
              result[name] = result[i];
          } else {
            if (name)
              result[name] = result[i];
          }
        } else {
          if (name)
            result[name] = result[i];
        }
      });
  };
  if ("outputs" in funABI && funABI.outputs && funABI.outputs.length > 0) {
    const outputTypes = [];
    for (let i = 0; i < funABI.outputs.length; i++) {
      const type = funABI.outputs[i].type;
      const name = funABI.outputs[i].name ? ` ${funABI.outputs[i].name}` : "";
      outputTypes.push(type.indexOf("tuple") === 0 ? buildFullTypeNameDefinition(funABI.outputs[i]) : type + name);
    }
    convertTypeNames(outputTypes);
    if (!data || !data.length)
      data = new Uint8Array(32 * funABI.outputs.length);
    const decodeRes = abiCoder.decode(outputTypes, data);
    const decodeResCopy = decodeRes.toArray(true);
    decodeResult(funABI.outputs, decodeResCopy);
    return decodeResCopy;
  }
  return [];
}

// node_modules/tronweb/lib/esm/paramValidator/index.js
var Validator = class {
  invalid(param) {
    return param.msg || `Invalid ${param.name}${param.type === "address" ? " address" : ""} provided`;
  }
  notPositive(param) {
    return `${param.name} must be a positive integer`;
  }
  notEqual(param) {
    var _a3, _b;
    return param.msg || `${(_a3 = param.names) == null ? void 0 : _a3[0]} can not be equal to ${(_b = param.names) == null ? void 0 : _b[1]}`;
  }
  notValid(params) {
    const normalized = {};
    let no = false;
    for (const param of params) {
      const { name, names, value, type, gt, lt, gte, lte, optional } = param;
      if (optional && (!isNotNullOrUndefined(value) || type !== "boolean" && value === false))
        continue;
      normalized[name] = param.value;
      switch (type) {
        case "address":
          if (!isAddress2(value)) {
            no = true;
          } else {
            normalized[name] = toHex(value);
          }
          break;
        case "integer":
          if (!isInteger(value) || typeof gt === "number" && value <= gt || typeof lt === "number" && value >= lt || typeof gte === "number" && value < gte || typeof lte === "number" && value > lte) {
            no = true;
          }
          break;
        case "positive-integer":
          if (!isInteger(value) || value <= 0) {
            throw new Error(this.notPositive(param));
          }
          break;
        case "tokenId":
          if (!isString(value) || !value.length) {
            no = true;
          }
          break;
        case "notEmptyObject":
          if (!isObject(value) || !Object.keys(value).length) {
            no = true;
          }
          break;
        case "notEqual":
          if (names && normalized[names[0]] === normalized[names[1]]) {
            throw new Error(this.notEqual(param));
          }
          break;
        case "resource":
          if (!["BANDWIDTH", "ENERGY"].includes(value)) {
            no = true;
          }
          break;
        case "url":
          if (!isValidURL(value)) {
            no = true;
          }
          break;
        case "hex":
          if (!isHex(value)) {
            no = true;
          }
          break;
        case "array":
          if (!Array.isArray(value)) {
            no = true;
          }
          break;
        case "not-empty-string":
          if (!isString(value) || !value.length) {
            no = true;
          }
          break;
        case "boolean":
          if (!isBoolean(value)) {
            no = true;
          }
          break;
        case "string":
          if (!isString(value) || typeof gt === "number" && value.length <= gt || typeof lt === "number" && value.length >= lt || typeof gte === "number" && value.length < gte || typeof lte === "number" && value.length > lte) {
            no = true;
          }
          break;
      }
      if (no) {
        throw new Error(this.invalid(param));
      }
    }
    return false;
  }
};

// node_modules/tronweb/lib/esm/types/Contract.js
var ContractType;
(function(ContractType2) {
  ContractType2["AccountCreateContract"] = "AccountCreateContract";
  ContractType2["TransferContract"] = "TransferContract";
  ContractType2["TransferAssetContract"] = "TransferAssetContract";
  ContractType2["VoteAssetContract"] = "VoteAssetContract";
  ContractType2["VoteWitnessContract"] = "VoteWitnessContract";
  ContractType2["WitnessCreateContract"] = "WitnessCreateContract";
  ContractType2["AssetIssueContract"] = "AssetIssueContract";
  ContractType2["WitnessUpdateContract"] = "WitnessUpdateContract";
  ContractType2["ParticipateAssetIssueContract"] = "ParticipateAssetIssueContract";
  ContractType2["AccountUpdateContract"] = "AccountUpdateContract";
  ContractType2["FreezeBalanceContract"] = "FreezeBalanceContract";
  ContractType2["UnfreezeBalanceContract"] = "UnfreezeBalanceContract";
  ContractType2["CancelAllUnfreezeV2Contract"] = "CancelAllUnfreezeV2Contract";
  ContractType2["WithdrawBalanceContract"] = "WithdrawBalanceContract";
  ContractType2["UnfreezeAssetContract"] = "UnfreezeAssetContract";
  ContractType2["UpdateAssetContract"] = "UpdateAssetContract";
  ContractType2["ProposalCreateContract"] = "ProposalCreateContract";
  ContractType2["ProposalApproveContract"] = "ProposalApproveContract";
  ContractType2["ProposalDeleteContract"] = "ProposalDeleteContract";
  ContractType2["SetAccountIdContract"] = "SetAccountIdContract";
  ContractType2["CustomContract"] = "CustomContract";
  ContractType2["CreateSmartContract"] = "CreateSmartContract";
  ContractType2["TriggerSmartContract"] = "TriggerSmartContract";
  ContractType2["GetContract"] = "GetContract";
  ContractType2["UpdateSettingContract"] = "UpdateSettingContract";
  ContractType2["ExchangeCreateContract"] = "ExchangeCreateContract";
  ContractType2["ExchangeInjectContract"] = "ExchangeInjectContract";
  ContractType2["ExchangeWithdrawContract"] = "ExchangeWithdrawContract";
  ContractType2["ExchangeTransactionContract"] = "ExchangeTransactionContract";
  ContractType2["UpdateEnergyLimitContract"] = "UpdateEnergyLimitContract";
  ContractType2["AccountPermissionUpdateContract"] = "AccountPermissionUpdateContract";
  ContractType2["ClearABIContract"] = "ClearABIContract";
  ContractType2["UpdateBrokerageContract"] = "UpdateBrokerageContract";
  ContractType2["ShieldedTransferContract"] = "ShieldedTransferContract";
  ContractType2["MarketSellAssetContract"] = "MarketSellAssetContract";
  ContractType2["MarketCancelOrderContract"] = "MarketCancelOrderContract";
  ContractType2["FreezeBalanceV2Contract"] = "FreezeBalanceV2Contract";
  ContractType2["UnfreezeBalanceV2Contract"] = "UnfreezeBalanceV2Contract";
  ContractType2["WithdrawExpireUnfreezeContract"] = "WithdrawExpireUnfreezeContract";
  ContractType2["DelegateResourceContract"] = "DelegateResourceContract";
  ContractType2["UnDelegateResourceContract"] = "UnDelegateResourceContract";
  ContractType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ContractType || (ContractType = {}));
var Permission_PermissionType;
(function(Permission_PermissionType2) {
  Permission_PermissionType2[Permission_PermissionType2["Owner"] = 0] = "Owner";
  Permission_PermissionType2[Permission_PermissionType2["Witness"] = 1] = "Witness";
  Permission_PermissionType2[Permission_PermissionType2["Active"] = 2] = "Active";
  Permission_PermissionType2[Permission_PermissionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Permission_PermissionType || (Permission_PermissionType = {}));
var AccountType;
(function(AccountType2) {
  AccountType2[AccountType2["Normal"] = 0] = "Normal";
  AccountType2[AccountType2["AssetIssue"] = 1] = "AssetIssue";
  AccountType2[AccountType2["Contract"] = 2] = "Contract";
  AccountType2[AccountType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AccountType || (AccountType = {}));

// node_modules/tronweb/lib/esm/utils/transaction.js
var transaction_exports = {};
__export(transaction_exports, {
  DeserializeTransaction: () => DeserializeTransaction,
  txCheck: () => txCheck,
  txCheckWithArgs: () => txCheckWithArgs,
  txJsonToPb: () => txJsonToPb,
  txJsonToPbWithArgs: () => txJsonToPbWithArgs,
  txPbToRawDataHex: () => txPbToRawDataHex,
  txPbToTxID: () => txPbToTxID
});
var import_any_pb = __toESM(require_any_pb(), 1);
var import_Tron_pb = __toESM(require_Tron_pb(), 1);
var import_balance_contract_pb = __toESM(require_balance_contract_pb(), 1);
var import_asset_issue_contract_pb = __toESM(require_asset_issue_contract_pb(), 1);
var import_smart_contract_pb = __toESM(require_smart_contract_pb(), 1);
var import_common_pb = __toESM(require_common_pb(), 1);
var import_witness_contract_pb = __toESM(require_witness_contract_pb(), 1);
var import_storage_contract_pb = __toESM(require_storage_contract_pb(), 1);
var import_account_contract_pb = __toESM(require_account_contract_pb(), 1);
var import_proposal_contract_pb = __toESM(require_proposal_contract_pb(), 1);
var import_exchange_contract_pb = __toESM(require_exchange_contract_pb(), 1);
var { Transaction: Transaction2, Permission, Key } = globalThis.TronWebProto;
var { TransferContract, FreezeBalanceContract, UnfreezeBalanceContract, WithdrawBalanceContract, FreezeBalanceV2Contract, UnfreezeBalanceV2Contract, CancelAllUnfreezeV2Contract, WithdrawExpireUnfreezeContract, DelegateResourceContract, UnDelegateResourceContract } = globalThis.TronWebProto;
var { TransferAssetContract, ParticipateAssetIssueContract, AssetIssueContract, UpdateAssetContract } = globalThis.TronWebProto;
var { TriggerSmartContract, ClearABIContract, UpdateEnergyLimitContract, UpdateSettingContract, CreateSmartContract, SmartContract } = globalThis.TronWebProto;
var { ResourceCode } = globalThis.TronWebProto;
var { WitnessCreateContract, VoteWitnessContract } = globalThis.TronWebProto;
var { UpdateBrokerageContract } = globalThis.TronWebProto;
var { AccountCreateContract, AccountUpdateContract, SetAccountIdContract, AccountPermissionUpdateContract } = globalThis.TronWebProto;
var { ProposalCreateContract, ProposalDeleteContract, ProposalApproveContract } = globalThis.TronWebProto;
var { ExchangeCreateContract, ExchangeInjectContract, ExchangeWithdrawContract, ExchangeTransactionContract } = globalThis.TronWebProto;
var fromHexString = (hexString) => {
  if (!hexString || hexString.length === 0)
    return new Uint8Array([]);
  return new Uint8Array(tronweb_default.address.toHex(hexString).match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
};
var stringToUint8Array = (hexString) => {
  if (!hexString || hexString.length === 0)
    return new Uint8Array([]);
  return new Uint8Array((isHex(hexString) ? hexString : tronweb_default.toHex(hexString)).replace(/^0x/, "").match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
};
var flexToUint8Array = (str, visible) => {
  if (!visible)
    return stringToUint8Array(str.replace(/^0x/, ""));
  return stringToUint8Array(tronweb_default.fromUtf8(str).replace(/^0x/, ""));
};
var sha3 = (string, prefix = true) => {
  return (prefix ? "0x" : "") + keccak256(Buffer.from(string, "utf-8")).toString().substring(2);
};
var buildCommonTransaction = (message, contractType, typeName, permissionId) => {
  const anyValue = new import_any_pb.default.Any();
  anyValue.pack(message.serializeBinary(), "protocol." + typeName);
  const contract = new Transaction2.Contract();
  contract.setType(contractType);
  contract.setParameter(anyValue);
  if (permissionId) {
    contract.setPermissionId(permissionId);
  }
  const raw = new Transaction2.raw();
  raw.addContract(contract);
  const transaction = new Transaction2();
  transaction.setRawData(raw);
  return transaction;
};
var buildTransferContract = (value, options) => {
  const { to_address, owner_address, amount } = value;
  const transferContract = new TransferContract();
  transferContract.setToAddress(fromHexString(to_address));
  transferContract.setOwnerAddress(fromHexString(owner_address));
  transferContract.setAmount(amount);
  return buildCommonTransaction(transferContract, Transaction2.Contract.ContractType.TRANSFERCONTRACT, "TransferContract", options.Permission_id);
};
var buildTransferAssetContract = (value, options) => {
  const { to_address, owner_address, amount, asset_name } = value;
  const transferContract = new TransferAssetContract();
  transferContract.setToAddress(fromHexString(to_address));
  transferContract.setOwnerAddress(fromHexString(owner_address));
  transferContract.setAssetName(flexToUint8Array(asset_name, options.visible));
  transferContract.setAmount(amount);
  return buildCommonTransaction(transferContract, Transaction2.Contract.ContractType.TRANSFERASSETCONTRACT, "TransferAssetContract", options.Permission_id);
};
var buildParticipateAssetIssueContract = (value, options) => {
  const pbObj = new ParticipateAssetIssueContract();
  pbObj.setToAddress(fromHexString(value.to_address));
  pbObj.setOwnerAddress(fromHexString(value.owner_address));
  pbObj.setAssetName(flexToUint8Array(value.asset_name, options.visible));
  pbObj.setAmount(value.amount);
  return buildCommonTransaction(pbObj, Transaction2.Contract.ContractType.PARTICIPATEASSETISSUECONTRACT, "ParticipateAssetIssueContract", options.Permission_id);
};
var buildTriggerSmartContract = (value, options) => {
  const triggerSmartContract = new TriggerSmartContract();
  const { owner_address, contract_address, parameter = "", function_selector, call_value, call_token_value, token_id, data } = value;
  triggerSmartContract.setOwnerAddress(fromHexString(owner_address));
  triggerSmartContract.setContractAddress(fromHexString(contract_address));
  triggerSmartContract.setCallValue(call_value);
  if (data) {
    triggerSmartContract.setData(stringToUint8Array(data));
  } else if (function_selector) {
    const contractData = sha3(function_selector).substring(2, 10) + parameter;
    triggerSmartContract.setData(stringToUint8Array(contractData));
  }
  if (token_id) {
    triggerSmartContract.setTokenId(token_id);
  }
  if (call_token_value) {
    triggerSmartContract.setCallTokenValue(call_token_value);
  }
  return buildCommonTransaction(triggerSmartContract, Transaction2.Contract.ContractType.TRIGGERSMARTCONTRACT, "TriggerSmartContract", options.Permission_id);
};
var buildFreezeBalanceContract = (value, options) => {
  const freezeBalanceContract = new FreezeBalanceContract();
  const { owner_address, frozen_balance, frozen_duration, resource, receiver_address } = value;
  freezeBalanceContract.setOwnerAddress(fromHexString(owner_address));
  freezeBalanceContract.setFrozenBalance(frozen_balance);
  freezeBalanceContract.setFrozenDuration(frozen_duration);
  if (resource) {
    freezeBalanceContract.setResource(ResourceCode[resource]);
  }
  if (receiver_address) {
    freezeBalanceContract.setReceiverAddress(fromHexString(receiver_address));
  }
  return buildCommonTransaction(freezeBalanceContract, Transaction2.Contract.ContractType.FREEZEBALANCECONTRACT, "FreezeBalanceContract", options.Permission_id);
};
var buildUnfreezeBalanceContract = (value, options) => {
  const unfreezeBalanceContract = new UnfreezeBalanceContract();
  const { owner_address, resource, receiver_address } = value;
  unfreezeBalanceContract.setOwnerAddress(fromHexString(owner_address));
  if (resource) {
    unfreezeBalanceContract.setResource(ResourceCode[resource]);
  }
  if (receiver_address) {
    unfreezeBalanceContract.setReceiverAddress(fromHexString(receiver_address));
  }
  return buildCommonTransaction(unfreezeBalanceContract, Transaction2.Contract.ContractType.UNFREEZEBALANCECONTRACT, "UnfreezeBalanceContract", options.Permission_id);
};
var buildWithdrawBalanceContract = (value, options) => {
  const withdrawbalanceContract = new WithdrawBalanceContract();
  const { owner_address } = value;
  withdrawbalanceContract.setOwnerAddress(fromHexString(owner_address));
  return buildCommonTransaction(withdrawbalanceContract, Transaction2.Contract.ContractType.WITHDRAWBALANCECONTRACT, "WithdrawBalanceContract", options.Permission_id);
};
var buildFreezeBalanceV2Contract = (value, options) => {
  const freezeBalanceV2Contract = new FreezeBalanceV2Contract();
  const { owner_address, frozen_balance, resource } = value;
  freezeBalanceV2Contract.setOwnerAddress(fromHexString(owner_address));
  freezeBalanceV2Contract.setFrozenBalance(frozen_balance);
  freezeBalanceV2Contract.setResource(ResourceCode[resource]);
  return buildCommonTransaction(freezeBalanceV2Contract, Transaction2.Contract.ContractType.FREEZEBALANCEV2CONTRACT, "FreezeBalanceV2Contract", options.Permission_id);
};
var buildCancelFreezeBalanceV2Contract = (value, options) => {
  const cancelAllUnfreezeV2Contract = new CancelAllUnfreezeV2Contract();
  const { owner_address } = value;
  cancelAllUnfreezeV2Contract.setOwnerAddress(fromHexString(owner_address));
  return buildCommonTransaction(cancelAllUnfreezeV2Contract, Transaction2.Contract.ContractType.CANCELALLUNFREEZEV2CONTRACT, "CancelAllUnfreezeV2Contract", options.Permission_id);
};
var buildUnfreezeBalanceV2Contract = (value, options) => {
  const unfreezeBalanceV2Contract = new UnfreezeBalanceV2Contract();
  const { owner_address, unfreeze_balance, resource } = value;
  unfreezeBalanceV2Contract.setOwnerAddress(fromHexString(owner_address));
  unfreezeBalanceV2Contract.setUnfreezeBalance(unfreeze_balance);
  unfreezeBalanceV2Contract.setResource(ResourceCode[resource]);
  return buildCommonTransaction(unfreezeBalanceV2Contract, Transaction2.Contract.ContractType.UNFREEZEBALANCEV2CONTRACT, "UnfreezeBalanceV2Contract", options.Permission_id);
};
var buildDelegateResourceContract = (value, options) => {
  const delegateResourceContract = new DelegateResourceContract();
  const { owner_address, receiver_address, balance, resource, lock: lock2 = false, lock_period } = value;
  delegateResourceContract.setOwnerAddress(fromHexString(owner_address));
  delegateResourceContract.setBalance(balance);
  delegateResourceContract.setResource(ResourceCode[resource]);
  delegateResourceContract.setLock(lock2);
  delegateResourceContract.setLockPeriod(lock_period);
  delegateResourceContract.setReceiverAddress(fromHexString(receiver_address));
  return buildCommonTransaction(delegateResourceContract, Transaction2.Contract.ContractType.DELEGATERESOURCECONTRACT, "DelegateResourceContract", options.Permission_id);
};
var buildUnDelegateResourceContract = (value, options) => {
  const unDelegateResourceContract = new UnDelegateResourceContract();
  const { owner_address, receiver_address, balance, resource } = value;
  unDelegateResourceContract.setOwnerAddress(fromHexString(owner_address));
  unDelegateResourceContract.setBalance(balance);
  unDelegateResourceContract.setResource(ResourceCode[resource]);
  unDelegateResourceContract.setReceiverAddress(fromHexString(receiver_address));
  return buildCommonTransaction(unDelegateResourceContract, Transaction2.Contract.ContractType.UNDELEGATERESOURCECONTRACT, "UnDelegateResourceContract", options.Permission_id);
};
var buildWithdrawExpireUnfreezeContract = (value, options) => {
  const withdrawExpireUnfreeze = new WithdrawExpireUnfreezeContract();
  const { owner_address } = value;
  withdrawExpireUnfreeze.setOwnerAddress(fromHexString(owner_address));
  return buildCommonTransaction(withdrawExpireUnfreeze, Transaction2.Contract.ContractType.WITHDRAWEXPIREUNFREEZECONTRACT, "WithdrawExpireUnfreezeContract", options.Permission_id);
};
var buildCreateWitness = (value, options) => {
  const createWitnessContract = new WitnessCreateContract();
  const { owner_address, url } = value;
  createWitnessContract.setOwnerAddress(fromHexString(owner_address));
  createWitnessContract.setUrl(stringToUint8Array(url.replace(/^0x/, "")));
  return buildCommonTransaction(createWitnessContract, Transaction2.Contract.ContractType.WITNESSCREATECONTRACT, "WitnessCreateContract", options.Permission_id);
};
var buildVoteWitnessAccount = (value, options) => {
  const voteWitnessContract = new VoteWitnessContract();
  const { owner_address, votes } = value;
  voteWitnessContract.setOwnerAddress(fromHexString(owner_address));
  votes.forEach((voteItem) => {
    const vote = new VoteWitnessContract.Vote();
    const { vote_address, vote_count } = voteItem;
    vote.setVoteAddress(fromHexString(vote_address));
    const numberOfVotes = parseInt(vote_count);
    vote.setVoteCount(numberOfVotes);
    voteWitnessContract.addVotes(vote);
  });
  return buildCommonTransaction(voteWitnessContract, Transaction2.Contract.ContractType.VOTEWITNESSCONTRACT, "VoteWitnessContract", options.Permission_id);
};
var buildCreateSmartContract = (value, options) => {
  const params = (value == null ? void 0 : value.new_contract) ? {
    ...{
      owner_address: value.owner_address,
      call_token_value: value.call_token_value,
      token_id: value.token_id
    },
    ...value.new_contract
  } : value;
  const { owner_address, consume_user_resource_percent, origin_energy_limit, abi, bytecode = "", parameter = "", call_value, call_token_value, token_id, name: contracName } = params;
  let { origin_address } = params;
  const createSmartContract = new CreateSmartContract();
  createSmartContract.setOwnerAddress(fromHexString(owner_address));
  if (token_id) {
    createSmartContract.setTokenId(token_id);
  }
  if (call_token_value) {
    createSmartContract.setCallTokenValue(call_token_value);
  }
  const smartContractBuilder = new SmartContract();
  if (abi) {
    let abiJson;
    if (typeof abi === "string") {
      abiJson = JSON.parse(abi);
    } else {
      abiJson = (abi == null ? void 0 : abi.entrys) || [];
    }
    const abiBuilder = new SmartContract.ABI();
    const buildEntryParam = (data) => {
      const param = new SmartContract.ABI.Entry.Param();
      const { indexed, name, type } = data;
      if (indexed === true) {
        param.setIndexed(true);
      }
      param.setName(name);
      param.setType(type);
      return param;
    };
    const entryBuilders = abiJson.map((entry) => {
      const { anonymous, constant, name, inputs, outputs, type, payable, stateMutability } = entry;
      const entryBuilder = new SmartContract.ABI.Entry();
      entryBuilder.setAnonymous(anonymous);
      entryBuilder.setConstant(constant);
      entryBuilder.setName(name);
      if (inputs) {
        entryBuilder.setInputsList(inputs.map((input) => buildEntryParam(input)));
      }
      if (outputs) {
        entryBuilder.setOutputsList(outputs.map((output3) => buildEntryParam(output3)));
      }
      if (type) {
        entryBuilder.setType(SmartContract.ABI.Entry.EntryType[type.toUpperCase()]);
      }
      entryBuilder.setPayable(payable);
      if (stateMutability) {
        entryBuilder.setStatemutability(SmartContract.ABI.Entry.StateMutabilityType[stateMutability.toUpperCase()]);
      }
      return entryBuilder;
    });
    abiBuilder.setEntrysList(entryBuilders);
    smartContractBuilder.setAbi(abiBuilder);
  }
  if (call_value) {
    smartContractBuilder.setCallValue(call_value);
  }
  smartContractBuilder.setConsumeUserResourcePercent(consume_user_resource_percent);
  smartContractBuilder.setOriginEnergyLimit(origin_energy_limit);
  if (!origin_address) {
    origin_address = owner_address;
  }
  smartContractBuilder.setOriginAddress(fromHexString(origin_address));
  if (bytecode) {
    const bytecodeParameter = bytecode.replace(/^0x/, "") + parameter.replace(/^0x/, "");
    smartContractBuilder.setBytecode(stringToUint8Array(bytecodeParameter));
  }
  smartContractBuilder.setName(contracName);
  createSmartContract.setNewContract(smartContractBuilder);
  return buildCommonTransaction(createSmartContract, Transaction2.Contract.ContractType.CREATESMARTCONTRACT, "CreateSmartContract", options.Permission_id);
};
var buildClearABIContract = (value, options) => {
  const { contract_address, owner_address } = value;
  const clearABIContract = new ClearABIContract();
  clearABIContract.setOwnerAddress(fromHexString(owner_address));
  clearABIContract.setContractAddress(fromHexString(contract_address));
  return buildCommonTransaction(clearABIContract, Transaction2.Contract.ContractType.CLEARABICONTRACT, "ClearABIContract", options.Permission_id);
};
var buildUpdateBrokerageContract = (value, options) => {
  const { brokerage, owner_address } = value;
  const updateBrokerageContract = new UpdateBrokerageContract();
  updateBrokerageContract.setOwnerAddress(fromHexString(owner_address));
  updateBrokerageContract.setBrokerage(brokerage);
  return buildCommonTransaction(updateBrokerageContract, Transaction2.Contract.ContractType.UPDATEBROKERAGECONTRACT, "UpdateBrokerageContract", options.Permission_id);
};
var buildAssetIssueContract = (value, options) => {
  const { owner_address, name, abbr, description, url, total_supply, trx_num, num, start_time, end_time, precision, free_asset_net_limit, public_free_asset_net_limit, public_free_asset_net_usage = 0, public_latest_free_net_time = 0, vote_score = 0, frozen_supply } = value;
  const assetIssueContract = new AssetIssueContract();
  assetIssueContract.setOwnerAddress(fromHexString(owner_address));
  if (name) {
    assetIssueContract.setName(stringToUint8Array(name.replace(/^0x/, "")));
  }
  if (abbr) {
    assetIssueContract.setAbbr(stringToUint8Array(abbr.replace(/^0x/, "")));
  }
  assetIssueContract.setTotalSupply(total_supply);
  assetIssueContract.setNum(num);
  assetIssueContract.setEndTime(end_time);
  assetIssueContract.setStartTime(start_time);
  assetIssueContract.setTrxNum(trx_num);
  assetIssueContract.setVoteScore(vote_score);
  if (precision) {
    assetIssueContract.setPrecision(precision);
  }
  if (public_latest_free_net_time) {
    assetIssueContract.setPublicLatestFreeNetTime(public_latest_free_net_time);
  }
  if (description) {
    assetIssueContract.setDescription(stringToUint8Array(description.replace(/^0x/, "")));
  }
  if (url) {
    assetIssueContract.setUrl(stringToUint8Array(url.replace(/^0x/, "")));
  }
  assetIssueContract.setPublicFreeAssetNetUsage(public_free_asset_net_usage);
  assetIssueContract.setFreeAssetNetLimit(free_asset_net_limit);
  assetIssueContract.setPublicFreeAssetNetLimit(public_free_asset_net_limit);
  if (frozen_supply) {
    const frozenSupplyContract = new AssetIssueContract.FrozenSupply();
    frozenSupplyContract.setFrozenAmount(frozen_supply.length ? frozen_supply[0].frozen_amount : frozen_supply.frozen_amount);
    frozenSupplyContract.setFrozenDays(frozen_supply.length ? frozen_supply[0].frozen_days : frozen_supply.frozen_days);
    assetIssueContract.addFrozenSupply(frozenSupplyContract);
  }
  return buildCommonTransaction(assetIssueContract, Transaction2.Contract.ContractType.ASSETISSUECONTRACT, "AssetIssueContract", options.Permission_id);
};
var buildAccountCreateContract = (value, options) => {
  const accountCreateContract = new AccountCreateContract();
  const { account_address, owner_address } = value;
  accountCreateContract.setOwnerAddress(fromHexString(owner_address));
  accountCreateContract.setAccountAddress(fromHexString(account_address.replace(/^0x/, "")));
  return buildCommonTransaction(accountCreateContract, Transaction2.Contract.ContractType.ACCOUNTCREATECONTRACT, "AccountCreateContract", options.Permission_id);
};
var buildAccountUpdateContract = (value, options) => {
  const accountUpdateContract = new AccountUpdateContract();
  const { account_name, owner_address } = value;
  accountUpdateContract.setOwnerAddress(fromHexString(owner_address));
  accountUpdateContract.setAccountName(stringToUint8Array(account_name.replace(/^0x/, "")));
  return buildCommonTransaction(accountUpdateContract, Transaction2.Contract.ContractType.ACCOUNTUPDATECONTRACT, "AccountUpdateContract", options.Permission_id);
};
var buildSetAccountIdContract = (value, options) => {
  const setAccountIdContract = new SetAccountIdContract();
  const { account_id, owner_address } = value;
  setAccountIdContract.setOwnerAddress(fromHexString(owner_address));
  setAccountIdContract.setAccountId(stringToUint8Array(account_id.replace(/^0x/, "")));
  return buildCommonTransaction(setAccountIdContract, Transaction2.Contract.ContractType.SETACCOUNTIDCONTRACT, "SetAccountIdContract", options.Permission_id);
};
var buildProposalCreateContract = (value, options) => {
  const proposalCreateContract = new ProposalCreateContract();
  const { owner_address, parameters } = value;
  proposalCreateContract.setOwnerAddress(fromHexString(owner_address));
  parameters.forEach((parameter) => {
    proposalCreateContract.getParametersMap().set(parameter.key, parameter.value);
  });
  return buildCommonTransaction(proposalCreateContract, Transaction2.Contract.ContractType.PROPOSALCREATECONTRACT, "ProposalCreateContract", options.Permission_id);
};
var buildProposalDeleteContract = (value, options) => {
  const proposalDeleteContract = new ProposalDeleteContract();
  const { owner_address, proposal_id } = value;
  proposalDeleteContract.setOwnerAddress(fromHexString(owner_address));
  proposalDeleteContract.setProposalId(proposal_id);
  return buildCommonTransaction(proposalDeleteContract, Transaction2.Contract.ContractType.PROPOSALDELETECONTRACT, "ProposalDeleteContract", options.Permission_id);
};
var buildVoteProposalContract = (value, options) => {
  const proposalVoteContract = new ProposalApproveContract();
  const { owner_address, proposal_id, is_add_approval } = value;
  proposalVoteContract.setOwnerAddress(fromHexString(owner_address));
  proposalVoteContract.setProposalId(proposal_id);
  proposalVoteContract.setIsAddApproval(is_add_approval);
  return buildCommonTransaction(proposalVoteContract, Transaction2.Contract.ContractType.PROPOSALAPPROVECONTRACT, "ProposalApproveContract", options.Permission_id);
};
var buildExchangeCreateContract = (value, options) => {
  const exchangeCreateContract = new ExchangeCreateContract();
  const { owner_address, first_token_id, first_token_balance, second_token_id, second_token_balance } = value;
  exchangeCreateContract.setOwnerAddress(fromHexString(owner_address));
  exchangeCreateContract.setFirstTokenId(flexToUint8Array(first_token_id, options.visible));
  exchangeCreateContract.setFirstTokenBalance(first_token_balance);
  exchangeCreateContract.setSecondTokenId(flexToUint8Array(second_token_id, options.visible));
  exchangeCreateContract.setSecondTokenBalance(second_token_balance);
  return buildCommonTransaction(exchangeCreateContract, Transaction2.Contract.ContractType.EXCHANGECREATECONTRACT, "ExchangeCreateContract", options.Permission_id);
};
var buildExchangeInjectContract = (value, options) => {
  const exchangeInjectContract = new ExchangeInjectContract();
  const { owner_address, exchange_id, token_id, quant } = value;
  exchangeInjectContract.setOwnerAddress(fromHexString(owner_address));
  exchangeInjectContract.setExchangeId(exchange_id);
  exchangeInjectContract.setTokenId(flexToUint8Array(token_id, options.visible));
  exchangeInjectContract.setQuant(quant);
  return buildCommonTransaction(exchangeInjectContract, Transaction2.Contract.ContractType.EXCHANGEINJECTCONTRACT, "ExchangeInjectContract", options.Permission_id);
};
var buildExchangeWithdrawContract = (value, options) => {
  const exchangeWithdrawContract = new ExchangeWithdrawContract();
  const { owner_address, exchange_id, token_id, quant } = value;
  exchangeWithdrawContract.setOwnerAddress(fromHexString(owner_address));
  exchangeWithdrawContract.setExchangeId(exchange_id);
  exchangeWithdrawContract.setTokenId(flexToUint8Array(token_id, options.visible));
  exchangeWithdrawContract.setQuant(quant);
  return buildCommonTransaction(exchangeWithdrawContract, Transaction2.Contract.ContractType.EXCHANGEWITHDRAWCONTRACT, "ExchangeWithdrawContract", options.Permission_id);
};
var buildExchangeTransactionContract = (value, options) => {
  const exchangeTransactionContract = new ExchangeTransactionContract();
  const { owner_address, exchange_id, token_id, quant, expected } = value;
  exchangeTransactionContract.setOwnerAddress(fromHexString(owner_address));
  exchangeTransactionContract.setExchangeId(exchange_id);
  exchangeTransactionContract.setTokenId(flexToUint8Array(token_id, options.visible));
  exchangeTransactionContract.setQuant(quant);
  exchangeTransactionContract.setExpected(expected);
  return buildCommonTransaction(exchangeTransactionContract, Transaction2.Contract.ContractType.EXCHANGETRANSACTIONCONTRACT, "ExchangeTransactionContract", options.Permission_id);
};
var buildUpdateSettingContract = (value, options) => {
  const updateSettingContract = new UpdateSettingContract();
  const { owner_address, contract_address, consume_user_resource_percent } = value;
  updateSettingContract.setOwnerAddress(fromHexString(owner_address));
  updateSettingContract.setContractAddress(fromHexString(contract_address));
  updateSettingContract.setConsumeUserResourcePercent(consume_user_resource_percent);
  return buildCommonTransaction(updateSettingContract, Transaction2.Contract.ContractType.UPDATESETTINGCONTRACT, "UpdateSettingContract", options.Permission_id);
};
var buildUpdateEnergyLimitContract = (value, options) => {
  const updateEnergyLimitContract = new UpdateEnergyLimitContract();
  const { owner_address, contract_address, origin_energy_limit } = value;
  updateEnergyLimitContract.setOwnerAddress(fromHexString(owner_address));
  updateEnergyLimitContract.setContractAddress(fromHexString(contract_address));
  updateEnergyLimitContract.setOriginEnergyLimit(origin_energy_limit);
  return buildCommonTransaction(updateEnergyLimitContract, Transaction2.Contract.ContractType.UPDATEENERGYLIMITCONTRACT, "UpdateEnergyLimitContract", options.Permission_id);
};
var buildAccountPermissionUpdateContract = (value, options) => {
  const accountPermissionUpdateContract = new AccountPermissionUpdateContract();
  const { owner_address, owner, witness, actives } = value;
  accountPermissionUpdateContract.setOwnerAddress(fromHexString(owner_address));
  const getType = (type) => {
    if (isNaN(type))
      return type === "Active" ? 2 : type === "Witness" ? 1 : 0;
    return type;
  };
  const buildPermission = (data) => {
    const permission = new Permission();
    const { type, id: id2, permission_name, threshold, parentId, operations, keys } = data;
    permission.setType(getType(type));
    permission.setId(id2);
    permission.setPermissionName(permission_name);
    permission.setThreshold(threshold);
    if (parentId) {
      permission.setParentId(parentId);
    }
    if (operations) {
      permission.setOperations(stringToUint8Array(operations));
    }
    if (keys) {
      permission.setKeysList(keys.map((key) => {
        const keyBuilder = new Key();
        keyBuilder.setAddress(fromHexString(key.address));
        keyBuilder.setWeight(key.weight);
        return keyBuilder;
      }));
    }
    return permission;
  };
  if (owner) {
    accountPermissionUpdateContract.setOwner(buildPermission(owner));
  }
  if (witness) {
    accountPermissionUpdateContract.setWitness(buildPermission(witness));
  }
  if (actives) {
    if (Array.isArray(actives)) {
      accountPermissionUpdateContract.setActivesList(actives.map((active) => buildPermission(active)));
    } else {
      accountPermissionUpdateContract.setActivesList([buildPermission(actives)]);
    }
  }
  return buildCommonTransaction(accountPermissionUpdateContract, Transaction2.Contract.ContractType.ACCOUNTPERMISSIONUPDATECONTRACT, "AccountPermissionUpdateContract", options.Permission_id);
};
var buildUpdateAssetContract = (value, options) => {
  const updateAssetContract = new UpdateAssetContract();
  const { owner_address, description, url, new_limit, new_public_limit } = value;
  updateAssetContract.setOwnerAddress(fromHexString(owner_address));
  if (description) {
    updateAssetContract.setDescription(stringToUint8Array(description.replace(/^0x/, "")));
  }
  if (url) {
    updateAssetContract.setUrl(stringToUint8Array(url.replace(/^0x/, "")));
  }
  if (new_limit) {
    updateAssetContract.setNewLimit(new_limit);
  }
  if (new_public_limit) {
    updateAssetContract.setNewPublicLimit(new_public_limit);
  }
  return buildCommonTransaction(updateAssetContract, Transaction2.Contract.ContractType.UPDATEASSETCONTRACT, "UpdateAssetContract", options.Permission_id);
};
var contractJsonToProtobuf = (contract, value, options) => {
  switch (contract.type) {
    case "TransferContract":
      return buildTransferContract(value, options);
    case "TransferAssetContract":
      return buildTransferAssetContract(value, options);
    case "ParticipateAssetIssueContract":
      return buildParticipateAssetIssueContract(value, options);
    case "TriggerSmartContract":
      return buildTriggerSmartContract(value, options);
    case "FreezeBalanceContract":
      return buildFreezeBalanceContract(value, options);
    case "UnfreezeBalanceContract":
      return buildUnfreezeBalanceContract(value, options);
    case "WithdrawBalanceContract":
      return buildWithdrawBalanceContract(value, options);
    case "FreezeBalanceV2Contract":
      return buildFreezeBalanceV2Contract(value, options);
    case "CancelAllUnfreezeV2Contract":
      return buildCancelFreezeBalanceV2Contract(value, options);
    case "UnfreezeBalanceV2Contract":
      return buildUnfreezeBalanceV2Contract(value, options);
    case "DelegateResourceContract":
      return buildDelegateResourceContract(value, options);
    case "UnDelegateResourceContract":
      return buildUnDelegateResourceContract(value, options);
    case "WithdrawExpireUnfreezeContract":
      return buildWithdrawExpireUnfreezeContract(value, options);
    case "WitnessCreateContract":
      return buildCreateWitness(value, options);
    case "VoteWitnessContract":
      return buildVoteWitnessAccount(value, options);
    case "CreateSmartContract":
      return buildCreateSmartContract(value, options);
    case "ClearABIContract":
      return buildClearABIContract(value, options);
    case "UpdateBrokerageContract":
      return buildUpdateBrokerageContract(value, options);
    case "AssetIssueContract":
      return buildAssetIssueContract(value, options);
    case "AccountCreateContract":
      return buildAccountCreateContract(value, options);
    case "AccountUpdateContract":
      return buildAccountUpdateContract(value, options);
    case "SetAccountIdContract":
      return buildSetAccountIdContract(value, options);
    case "ProposalCreateContract":
      return buildProposalCreateContract(value, options);
    case "ProposalDeleteContract":
      return buildProposalDeleteContract(value, options);
    case "ProposalApproveContract":
      return buildVoteProposalContract(value, options);
    case "ExchangeCreateContract":
      return buildExchangeCreateContract(value, options);
    case "ExchangeInjectContract":
      return buildExchangeInjectContract(value, options);
    case "ExchangeWithdrawContract":
      return buildExchangeWithdrawContract(value, options);
    case "ExchangeTransactionContract":
      return buildExchangeTransactionContract(value, options);
    case "UpdateSettingContract":
      return buildUpdateSettingContract(value, options);
    case "UpdateEnergyLimitContract":
      return buildUpdateEnergyLimitContract(value, options);
    case "AccountPermissionUpdateContract":
      return buildAccountPermissionUpdateContract(value, options);
    case "UpdateAssetContract":
      return buildUpdateAssetContract(value, options);
  }
};
var txJsonToPb = (transaction) => {
  const rawData = transaction["raw_data"];
  const contractJson = rawData.contract[0];
  const data = contractJson.parameter.value;
  const options = { Permission_id: contractJson.Permission_id, visible: transaction.visible };
  const transactionObj = contractJsonToProtobuf(contractJson, data, options);
  const rawDataObj = transactionObj.getRawData();
  rawDataObj.setRefBlockBytes(stringToUint8Array(rawData.ref_block_bytes));
  rawDataObj.setRefBlockHash(stringToUint8Array(rawData.ref_block_hash));
  if (rawData.data) {
    rawDataObj.setData(stringToUint8Array(rawData.data));
  }
  if (rawData.fee_limit) {
    rawDataObj.setFeeLimit(rawData.fee_limit);
  }
  if (rawData.expiration) {
    rawDataObj.setExpiration(rawData.expiration);
  }
  if (rawData.timestamp) {
    rawDataObj.setTimestamp(rawData.timestamp);
  }
  transactionObj.setRawData(rawDataObj);
  return transactionObj;
};
var txJsonToPbWithArgs = (transaction, args = {}, options = {}) => {
  const rawData = transaction["raw_data"];
  const contractJson = rawData.contract[0];
  const transactionObj = contractJsonToProtobuf(contractJson, args, {
    Permission_id: args == null ? void 0 : args.Permission_id
  });
  const rawDataObj = transactionObj.getRawData();
  rawDataObj.setRefBlockBytes(stringToUint8Array(rawData.ref_block_bytes));
  rawDataObj.setRefBlockHash(stringToUint8Array(rawData.ref_block_hash));
  if (options.data) {
    rawDataObj.setData(stringToUint8Array(options.data.replace(/^0x/, "")));
  }
  if (options.fee_limit || args.fee_limit) {
    rawDataObj.setFeeLimit(options.fee_limit || args.fee_limit);
  }
  if (rawData.expiration) {
    rawDataObj.setExpiration(rawData.expiration);
  }
  if (rawData.timestamp) {
    rawDataObj.setTimestamp(rawData.timestamp);
  }
  transactionObj.setRawData(rawDataObj);
  return transactionObj;
};
var compareTransaction = (transaction, transactionPb) => {
  const rawDataBytes = transactionPb.getRawData().serializeBinary();
  const rawDataHex = byteArray2hexStr(rawDataBytes);
  const txID = sha2562(rawDataBytes);
  return rawDataHex.toLowerCase() === transaction.raw_data_hex.toLowerCase() && txID.replace(/^0x/, "").toLowerCase() === transaction.txID.replace(/^0x/, "").toLowerCase();
};
var txPbToRawDataHex = (pb) => {
  return byteArray2hexStr(pb.getRawData().serializeBinary());
};
var txCheck = (transaction) => {
  const transactionPb = txJsonToPb(transaction);
  return compareTransaction(transaction, transactionPb);
};
var txCheckWithArgs = (transaction, args, options) => {
  const transactionPb = txJsonToPbWithArgs(transaction, args, options);
  return compareTransaction(transaction, transactionPb);
};
var txPbToTxID = (transactionPb) => {
  const rawDataBytes = transactionPb.getRawData().serializeBinary();
  const txID = sha2562(rawDataBytes);
  return txID;
};
var ContractTypeMap = {
  "0": "AccountCreateContract",
  "1": "TransferContract",
  "2": "TransferAssetContract",
  "4": "VoteWitnessContract",
  "5": "WitnessCreateContract",
  "6": "AssetIssueContract",
  "9": "ParticipateAssetIssueContract",
  "10": "AccountUpdateContract",
  "11": "FreezeBalanceContract",
  "12": "UnfreezeBalanceContract",
  "13": "WithdrawBalanceContract",
  "15": "UpdateAssetContract",
  "16": "ProposalCreateContract",
  "17": "ProposalApproveContract",
  "18": "ProposalDeleteContract",
  "19": "SetAccountIdContract",
  "30": "CreateSmartContract",
  "31": "TriggerSmartContract",
  "33": "UpdateSettingContract",
  "41": "ExchangeCreateContract",
  "42": "ExchangeInjectContract",
  "43": "ExchangeWithdrawContract",
  "44": "ExchangeTransactionContract",
  "45": "UpdateEnergyLimitContract",
  "46": "AccountPermissionUpdateContract",
  "48": "ClearABIContract",
  "49": "UpdateBrokerageContract",
  "54": "FreezeBalanceV2Contract",
  "55": "UnfreezeBalanceV2Contract",
  "56": "WithdrawExpireUnfreezeContract",
  "57": "DelegateResourceContract",
  "58": "UnDelegateResourceContract",
  "59": "CancelAllUnfreezeV2Contract"
};
var getAuthsList = (pb) => {
  const authsList = pb.getAuthsList();
  return authsList.map((authPb) => {
    const permission_name = byteArray2hexStr(authPb.getPermissionName_asU8());
    const accountPb = authPb.getAccount();
    const account = {
      name: byteArray2hexStr(accountPb.getName_asU8()),
      address: byteArray2hexStr(accountPb.getAddress_asU8())
    };
    return {
      permission_name,
      account
    };
  });
};
var DCommonData = (type, rawDataHex) => {
  const pb = Transaction2.raw.deserializeBinary(hexStr2byteArray(rawDataHex));
  const contract = pb.getContractList()[0];
  const valuePb = contract.getParameter().getValue();
  const contractType = ContractTypeMap[contract.getType()];
  if (type !== contractType) {
    throw new Error(`type ${type} dismatches with rawDataHex type ${contractType}`);
  }
  return [
    {
      contract: [
        {
          parameter: {
            value: {},
            type_url: contract.getParameter().getTypeUrl()
          },
          type,
          Permission_id: contract.getPermissionId()
        }
      ],
      data: byteArray2hexStr(pb.getData()),
      fee_limit: pb.getFeeLimit(),
      ref_block_bytes: byteArray2hexStr(pb.getRefBlockBytes_asU8()),
      ref_block_hash: byteArray2hexStr(pb.getRefBlockHash_asU8()),
      expiration: pb.getExpiration(),
      timestamp: pb.getTimestamp(),
      scripts: byteArray2hexStr(pb.getScripts_asU8()),
      auths: getAuthsList(pb)
    },
    valuePb
  ];
};
var DTriggerSmartContract = (type, rawDataHex) => {
  const [commonData, valuePb] = DCommonData(type, rawDataHex);
  const triggerSmartContract = TriggerSmartContract.deserializeBinary(valuePb);
  commonData.contract[0].parameter.value = {
    owner_address: byteArray2hexStr(triggerSmartContract.getOwnerAddress_asU8()),
    contract_address: byteArray2hexStr(triggerSmartContract.getContractAddress_asU8()),
    call_value: triggerSmartContract.getCallValue(),
    data: byteArray2hexStr(triggerSmartContract.getData_asU8()),
    call_token_value: triggerSmartContract.getCallTokenValue(),
    token_id: triggerSmartContract.getTokenId()
  };
  return commonData;
};
var getResourceName = (type) => {
  switch (type) {
    case 0:
      return "BANDWIDTH";
    case 1:
      return "ENERGY";
    default:
      return "BANDWIDTH";
  }
};
var DFreezeBalanceV2Contract = (type, rawDataHex) => {
  const [commonData, valuePb] = DCommonData(type, rawDataHex);
  const freezeBalanceV2Contract = FreezeBalanceV2Contract.deserializeBinary(valuePb);
  commonData.contract[0].parameter.value = {
    owner_address: byteArray2hexStr(freezeBalanceV2Contract.getOwnerAddress_asU8()),
    frozen_balance: freezeBalanceV2Contract.getFrozenBalance(),
    resource: getResourceName(freezeBalanceV2Contract.getResource())
  };
  return commonData;
};
var DUnfreezeBalanceV2Contract = (type, rawDataHex) => {
  const [commonData, valuePb] = DCommonData(type, rawDataHex);
  const unfreezeBalanceV2Contract = UnfreezeBalanceV2Contract.deserializeBinary(valuePb);
  commonData.contract[0].parameter.value = {
    owner_address: byteArray2hexStr(unfreezeBalanceV2Contract.getOwnerAddress_asU8()),
    unfreeze_balance: unfreezeBalanceV2Contract.getUnfreezeBalance(),
    resource: getResourceName(unfreezeBalanceV2Contract.getResource())
  };
  return commonData;
};
var DCancelAllUnfreezeV2Contract = (type, rawDataHex) => {
  const [commonData, valuePb] = DCommonData(type, rawDataHex);
  const cancelAllUnfreezeV2Contract = CancelAllUnfreezeV2Contract.deserializeBinary(valuePb);
  commonData.contract[0].parameter.value = {
    owner_address: byteArray2hexStr(cancelAllUnfreezeV2Contract.getOwnerAddress_asU8())
  };
  return commonData;
};
var DDelegateResourceContract = (type, rawDataHex) => {
  const [commonData, valuePb] = DCommonData(type, rawDataHex);
  const delegateResourceContract = DelegateResourceContract.deserializeBinary(valuePb);
  commonData.contract[0].parameter.value = {
    owner_address: byteArray2hexStr(delegateResourceContract.getOwnerAddress_asU8()),
    balance: delegateResourceContract.getBalance(),
    lock: delegateResourceContract.getLock(),
    lock_period: delegateResourceContract.getLockPeriod(),
    receiver_address: byteArray2hexStr(delegateResourceContract.getReceiverAddress_asU8()),
    resource: getResourceName(delegateResourceContract.getResource())
  };
  return commonData;
};
var DUnDelegateResourceContract = (type, rawDataHex) => {
  const [commonData, valuePb] = DCommonData(type, rawDataHex);
  const undelegateResourceContract = UnDelegateResourceContract.deserializeBinary(valuePb);
  commonData.contract[0].parameter.value = {
    owner_address: byteArray2hexStr(undelegateResourceContract.getOwnerAddress_asU8()),
    balance: undelegateResourceContract.getBalance(),
    receiver_address: byteArray2hexStr(undelegateResourceContract.getReceiverAddress_asU8()),
    resource: getResourceName(undelegateResourceContract.getResource())
  };
  return commonData;
};
var DWithdrawExpireUnfreezeContract = (type, rawDataHex) => {
  const [commonData, valuePb] = DCommonData(type, rawDataHex);
  const withdrawExpireUnfreezeContract = WithdrawExpireUnfreezeContract.deserializeBinary(valuePb);
  commonData.contract[0].parameter.value = {
    owner_address: byteArray2hexStr(withdrawExpireUnfreezeContract.getOwnerAddress_asU8())
  };
  return commonData;
};
var DeserializeTransaction = (type, rawDataHex) => {
  if (!rawDataHex) {
    throw new Error("rawDataHex cannot be empty");
  }
  if (!isHex(rawDataHex)) {
    throw new Error("rawDataHex is not a valid hex string");
  }
  switch (type) {
    case "TriggerSmartContract":
      return DTriggerSmartContract(type, rawDataHex);
    case "FreezeBalanceV2Contract":
      return DFreezeBalanceV2Contract(type, rawDataHex);
    case "UnfreezeBalanceV2Contract":
      return DUnfreezeBalanceV2Contract(type, rawDataHex);
    case "CancelAllUnfreezeV2Contract":
      return DCancelAllUnfreezeV2Contract(type, rawDataHex);
    case "DelegateResourceContract":
      return DDelegateResourceContract(type, rawDataHex);
    case "UnDelegateResourceContract":
      return DUnDelegateResourceContract(type, rawDataHex);
    case "WithdrawExpireUnfreezeContract":
      return DWithdrawExpireUnfreezeContract(type, rawDataHex);
    default:
      throw new Error(`trasaction ${type} not supported`);
  }
};

// node_modules/tronweb/lib/esm/lib/TransactionBuilder/helper.js
function fromUtf8(value) {
  return TronWeb.fromUtf8(value).replace(/^0x/, "");
}
function deepCopyJson(json) {
  return JSON.parse(JSON.stringify(json));
}
function resultManager(transaction, data, options) {
  if (transaction.Error)
    throw new Error(transaction.Error);
  if (transaction.result && transaction.result.message) {
    throw new Error(TronWeb.toUtf8(transaction.result.message));
  }
  const authResult = txCheckWithArgs(transaction, data, options);
  if (authResult) {
    return transaction;
  }
  throw new Error("Invalid transaction");
}
function resultManagerTriggerSmartContract(transaction, data, options) {
  if (transaction.Error)
    throw new Error(transaction.Error);
  if (transaction.result && transaction.result.message) {
    throw new Error(TronWeb.toUtf8(transaction.result.message));
  }
  if (!(options._isConstant || options.estimateEnergy)) {
    const authResult = txCheckWithArgs(transaction.transaction, data, options);
    if (authResult) {
      return transaction;
    }
    throw new Error("Invalid transaction");
  }
  return transaction;
}
function genContractAddress(ownerAddress, txID) {
  return "41" + keccak256(Buffer.from(txID + ownerAddress, "hex")).toString().substring(2).slice(24);
}
function getHeaderInfo(node) {
  return node.request("wallet/getblock", { detail: false }, "post").then((data) => {
    return {
      ref_block_bytes: data.block_header.raw_data.number.toString(16).slice(-4).padStart(4, "0"),
      ref_block_hash: data.blockID.slice(16, 32),
      expiration: data.block_header.raw_data.timestamp + 60 * 1e3,
      timestamp: data.block_header.raw_data.timestamp
    };
  });
}
function checkBlockHeader(options = {}) {
  if (typeof options["ref_block_bytes"] === "undefined" && typeof options["ref_block_hash"] === "undefined" && typeof options["expiration"] === "undefined" && typeof options["timestamp"] === "undefined") {
    return false;
  }
  if (typeof options["ref_block_bytes"] !== "string") {
    throw new Error("Invalid ref_block_bytes provided.");
  }
  if (typeof options["ref_block_hash"] !== "string") {
    throw new Error("Invalid ref_block_hash provided.");
  }
  if (typeof options["expiration"] !== "number") {
    throw new Error("Invalid expiration provided.");
  }
  if (typeof options["timestamp"] !== "number") {
    throw new Error("Invalid timestamp provided.");
  }
  return true;
}
async function createTransaction(tronWeb, type, value, Permission_id, options = {}) {
  const tx = {
    visible: false,
    txID: "",
    raw_data_hex: "",
    raw_data: {
      contract: [
        {
          parameter: {
            value,
            type_url: `type.googleapis.com/protocol.${type}`
          },
          type
        }
      ],
      ...checkBlockHeader(options) ? {} : await getHeaderInfo(tronWeb.fullNode),
      ...options
    }
  };
  if (Permission_id) {
    tx.raw_data.contract[0].Permission_id = Permission_id;
  }
  const pb = txJsonToPb(tx);
  tx.txID = txPbToTxID(pb).replace(/^0x/, "");
  tx.raw_data_hex = txPbToRawDataHex(pb).toLowerCase();
  return tx;
}
function getTransactionOptions(options = {}) {
  const ret = {};
  if (checkBlockHeader(options.blockHeader)) {
    ret["ref_block_bytes"] = options.blockHeader["ref_block_bytes"];
    ret["ref_block_hash"] = options.blockHeader["ref_block_hash"];
    ret["expiration"] = options.blockHeader["expiration"];
    ret["timestamp"] = options.blockHeader["timestamp"];
  }
  return ret;
}

// node_modules/tronweb/lib/esm/lib/TransactionBuilder/TransactionBuilder.js
var TransactionBuilder = class {
  constructor(tronWeb) {
    __publicField(this, "tronWeb");
    __publicField(this, "validator");
    if (!tronWeb || !(tronWeb instanceof TronWeb)) {
      throw new Error("Expected instance of TronWeb");
    }
    this.tronWeb = tronWeb;
    this.validator = new Validator();
  }
  async sendTrx(to, amount = 0, from = this.tronWeb.defaultAddress.hex, options = {}) {
    amount = parseInt(amount);
    this.validator.notValid([
      {
        name: "recipient",
        type: "address",
        value: to
      },
      {
        name: "origin",
        type: "address",
        value: from
      },
      {
        names: ["recipient", "origin"],
        type: "notEqual",
        msg: "Cannot transfer TRX to the same account"
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      }
    ]);
    const data = {
      to_address: toHex(to),
      owner_address: toHex(from),
      amount
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.TransferContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async sendToken(to, amount = 0, tokenId, from = this.tronWeb.defaultAddress.hex, options = {}) {
    amount = parseInt(amount);
    this.validator.notValid([
      {
        name: "recipient",
        type: "address",
        value: to
      },
      {
        name: "origin",
        type: "address",
        value: from
      },
      {
        names: ["recipient", "origin"],
        type: "notEqual",
        msg: "Cannot transfer tokens to the same account"
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "token ID",
        type: "tokenId",
        value: tokenId
      }
    ]);
    const data = {
      to_address: toHex(to),
      owner_address: toHex(from),
      asset_name: fromUtf8(tokenId),
      amount
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.TransferAssetContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async purchaseToken(issuerAddress, tokenId, amount = 0, buyer = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "buyer",
        type: "address",
        value: buyer
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      },
      {
        names: ["buyer", "issuer"],
        type: "notEqual",
        msg: "Cannot purchase tokens from same account"
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "token ID",
        type: "tokenId",
        value: tokenId
      }
    ]);
    const data = {
      to_address: toHex(issuerAddress),
      owner_address: toHex(buyer),
      asset_name: fromUtf8(tokenId),
      amount: parseInt(amount)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ParticipateAssetIssueContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async freezeBalance(amount = 0, duration = 3, resource = "BANDWIDTH", ownerAddress = this.tronWeb.defaultAddress.hex, receiverAddress, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: ownerAddress
      },
      {
        name: "receiver",
        type: "address",
        value: receiverAddress,
        optional: true
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "duration",
        type: "integer",
        gte: 3,
        value: duration
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    const data = {
      owner_address: toHex(ownerAddress),
      frozen_balance: parseInt(amount),
      frozen_duration: parseInt(String(duration))
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    if (isNotNullOrUndefined(receiverAddress) && toHex(receiverAddress) !== toHex(ownerAddress)) {
      data.receiver_address = toHex(receiverAddress);
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.FreezeBalanceContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async unfreezeBalance(resource = "BANDWIDTH", address = this.tronWeb.defaultAddress.hex, receiverAddress, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address
      },
      {
        name: "receiver",
        type: "address",
        value: receiverAddress,
        optional: true
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    const data = {
      owner_address: toHex(address)
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    if (isNotNullOrUndefined(receiverAddress) && toHex(receiverAddress) !== toHex(address)) {
      data.receiver_address = toHex(receiverAddress);
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UnfreezeBalanceContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async freezeBalanceV2(amount = 0, resource = "BANDWIDTH", address = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    const data = {
      owner_address: toHex(address),
      frozen_balance: parseInt(amount)
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.FreezeBalanceV2Contract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async unfreezeBalanceV2(amount = 0, resource = "BANDWIDTH", address = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    const data = {
      owner_address: toHex(address),
      unfreeze_balance: parseInt(amount)
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UnfreezeBalanceV2Contract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async cancelUnfreezeBalanceV2(address = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address
      }
    ]);
    const data = {
      owner_address: toHex(address)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.CancelAllUnfreezeV2Contract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async delegateResource(amount = 0, receiverAddress, resource = "BANDWIDTH", address = this.tronWeb.defaultAddress.hex, lock2 = false, lockPeriod, options = {}) {
    this.validator.notValid([
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      },
      {
        name: "receiver",
        type: "address",
        value: receiverAddress
      },
      {
        name: "origin",
        type: "address",
        value: address
      },
      {
        name: "lock",
        type: "boolean",
        value: lock2
      },
      {
        name: "lock period",
        type: "integer",
        gte: 0,
        value: lockPeriod,
        optional: true
      }
    ]);
    if (toHex(receiverAddress) === toHex(address)) {
      throw new Error("Receiver address must not be the same as owner address");
    }
    const data = {
      owner_address: toHex(address),
      receiver_address: toHex(receiverAddress),
      balance: parseInt(amount)
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    if (lock2) {
      data.lock = lock2;
      if (isNotNullOrUndefined(lockPeriod)) {
        data.lock_period = lockPeriod;
      }
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.DelegateResourceContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async undelegateResource(amount = 0, receiverAddress, resource = "BANDWIDTH", address = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address
      },
      {
        name: "receiver",
        type: "address",
        value: receiverAddress
      },
      {
        name: "amount",
        type: "integer",
        gt: 0,
        value: amount
      },
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    if (toHex(receiverAddress) === toHex(address)) {
      throw new Error("Receiver address must not be the same as owner address");
    }
    const data = {
      owner_address: toHex(address),
      receiver_address: toHex(receiverAddress),
      balance: parseInt(amount)
    };
    if (resource !== "BANDWIDTH") {
      data.resource = resource;
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UnDelegateResourceContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async withdrawExpireUnfreeze(address = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address
      }
    ]);
    const data = {
      owner_address: toHex(address)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.WithdrawExpireUnfreezeContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async withdrawBlockRewards(address = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address
      }
    ]);
    const data = {
      owner_address: toHex(address)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.WithdrawBalanceContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async applyForSR(address = this.tronWeb.defaultAddress.hex, url = "", options = {}) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address
      },
      {
        name: "url",
        type: "url",
        value: url,
        msg: "Invalid url provided"
      },
      {
        name: "url",
        type: "string",
        value: url,
        lte: 256,
        msg: "Invalid url provided"
      }
    ]);
    const data = {
      owner_address: toHex(address),
      url: fromUtf8(url)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.WitnessCreateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async vote(votes = {}, voterAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "voter",
        type: "address",
        value: voterAddress
      },
      {
        name: "votes",
        type: "notEmptyObject",
        value: votes
      }
    ]);
    const entries = Object.entries(votes);
    for (const [srAddress, voteCount] of entries) {
      this.validator.notValid([
        {
          name: "SR",
          type: "address",
          value: srAddress
        },
        {
          name: "vote count",
          type: "integer",
          gt: 0,
          value: voteCount,
          msg: "Invalid vote count provided for SR: " + srAddress
        }
      ]);
    }
    const voteList = entries.map(([srAddress, voteCount]) => {
      return {
        vote_address: toHex(srAddress),
        vote_count: parseInt(voteCount)
      };
    });
    const data = {
      owner_address: toHex(voterAddress),
      votes: voteList
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.VoteWitnessContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async createSmartContract(options = {}, issuerAddress = this.tronWeb.defaultAddress.hex) {
    var _a3;
    const feeLimit = options.feeLimit || this.tronWeb.feeLimit;
    let userFeePercentage = options.userFeePercentage;
    if (typeof userFeePercentage !== "number" && !userFeePercentage) {
      userFeePercentage = 100;
    }
    const originEnergyLimit = options.originEnergyLimit || 1e7;
    const callValue = options.callValue || 0;
    const tokenValue = options.tokenValue;
    const tokenId = options.tokenId || options.token_id;
    let { abi } = options;
    const { parameters = [] } = options;
    let parameter = "";
    const { bytecode = false, name = "" } = options;
    if (abi && isString(abi)) {
      try {
        abi = JSON.parse(abi);
      } catch {
        throw new Error("Invalid options.abi provided");
      }
    }
    const newAbi = abi;
    let entries = newAbi;
    if (newAbi.entrys) {
      entries = newAbi.entrys;
    }
    if (!isArray(entries))
      throw new Error("Invalid options.abi provided");
    const payable = entries.some((func) => {
      return func.type === "constructor" && "payable" === func.stateMutability.toLowerCase();
    });
    this.validator.notValid([
      {
        name: "bytecode",
        type: "hex",
        value: bytecode
      },
      {
        name: "feeLimit",
        type: "integer",
        value: feeLimit,
        gt: 0
      },
      {
        name: "callValue",
        type: "integer",
        value: callValue,
        gte: 0
      },
      {
        name: "userFeePercentage",
        type: "integer",
        value: userFeePercentage,
        gte: 0,
        lte: 100
      },
      {
        name: "originEnergyLimit",
        type: "integer",
        value: originEnergyLimit,
        gte: 0,
        lte: 1e7
      },
      {
        name: "parameters",
        type: "array",
        value: parameters
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      },
      {
        name: "tokenValue",
        type: "integer",
        value: tokenValue,
        gte: 0,
        optional: true
      },
      {
        name: "tokenId",
        type: "integer",
        value: tokenId,
        gte: 0,
        optional: true
      }
    ]);
    if (!payable && (callValue > 0 || tokenValue > 0))
      throw new Error("When contract is not payable, options.callValue and options.tokenValue must be 0");
    const { rawParameter, funcABIV2, parametersV2 } = options;
    if (rawParameter && isString(rawParameter)) {
      parameter = rawParameter.replace(/^(0x)/, "");
    } else if (funcABIV2) {
      parameter = encodeParamsV2ByABI(funcABIV2, parametersV2).replace(/^(0x)/, "");
    } else {
      let constructorParams = entries.find((it) => {
        return it.type === "constructor";
      });
      if (typeof constructorParams !== "undefined" && constructorParams) {
        const abiCoder2 = new AbiCoder();
        const types = [];
        const values = [];
        constructorParams = constructorParams.inputs;
        if (parameters.length != constructorParams.length)
          throw new Error(`constructor needs ${constructorParams.length} but ${parameters.length} provided`);
        for (let i = 0; i < parameters.length; i++) {
          let type = constructorParams[i].type;
          let value = parameters[i];
          if (!type || !isString(type) || !type.length)
            throw new Error("Invalid parameter type provided: " + type);
          const replaceAddressPrefix = (value2) => {
            if (isArray(value2)) {
              return value2.map((v) => replaceAddressPrefix(v));
            }
            return toHex(value2).replace(ADDRESS_PREFIX_REGEX, "0x");
          };
          if (type === "address")
            value = replaceAddressPrefix(value);
          else if (((_a3 = type.match(/^([^\x5b]*)(\x5b|$)/)) == null ? void 0 : _a3[0]) === "address[")
            value = replaceAddressPrefix(value);
          else if (/trcToken/.test(type)) {
            type = type.replace(/trcToken/, "uint256");
          }
          types.push(type);
          values.push(value);
        }
        try {
          parameter = abiCoder2.encode(types, values).replace(/^(0x)/, "");
        } catch (ex) {
          throw new Error(ex);
        }
      } else {
        parameter = "";
      }
    }
    const args = {
      owner_address: toHex(issuerAddress),
      fee_limit: parseInt(feeLimit),
      call_value: parseInt(callValue),
      consume_user_resource_percent: userFeePercentage,
      origin_energy_limit: originEnergyLimit,
      abi: JSON.stringify(entries),
      bytecode,
      parameter,
      name
    };
    if (isNotNullOrUndefined(tokenValue)) {
      args.call_token_value = parseInt(tokenValue);
    }
    if (isNotNullOrUndefined(tokenId)) {
      args.token_id = parseInt(tokenId);
    }
    const contract = {};
    contract.owner_address = args.owner_address;
    if (isNotNullOrUndefined(args.call_token_value)) {
      contract.call_token_value = args.call_token_value;
    }
    if (isNotNullOrUndefined(args.token_id)) {
      contract.token_id = args.token_id;
    }
    const new_contract = contract.new_contract = {};
    if (args.abi) {
      new_contract.abi = {
        entrys: JSON.parse(args.abi)
      };
    } else {
      new_contract.abi = {};
    }
    if (args.call_value) {
      new_contract.call_value = args.call_value;
    }
    new_contract.consume_user_resource_percent = args.consume_user_resource_percent;
    new_contract.origin_energy_limit = args.origin_energy_limit;
    new_contract.origin_address = args.origin_address ?? args.owner_address;
    if (args.bytecode + args.parameter) {
      new_contract.bytecode = (args.bytecode + args.parameter).replace(/^0x/, "");
    }
    if (isNotNullOrUndefined(args.name)) {
      new_contract.name = args.name;
    }
    const transactionOptions = getTransactionOptions(options);
    const tx = await createTransaction(this.tronWeb, ContractType.CreateSmartContract, contract, options == null ? void 0 : options.permissionId, {
      ...transactionOptions,
      fee_limit: args.fee_limit
    });
    tx.contract_address = genContractAddress(args.owner_address, tx.txID);
    return tx;
  }
  async triggerSmartContract(contractAddress, functionSelector, options, parameters, issuerAddress) {
    var _a3;
    const params = [
      contractAddress,
      functionSelector,
      options,
      parameters,
      issuerAddress
    ];
    if (typeof params[2] !== "object") {
      params[2] = {
        feeLimit: params[2],
        callValue: params[3]
      };
      params.splice(3, 1);
    }
    if ((_a3 = params[2]) == null ? void 0 : _a3.txLocal) {
      return this._triggerSmartContractLocal(...params);
    }
    return this._triggerSmartContract(...params);
  }
  async triggerConstantContract(contractAddress, functionSelector, options = {}, parameters = [], issuerAddress = this.tronWeb.defaultAddress.hex) {
    options._isConstant = true;
    return this._triggerSmartContract(contractAddress, functionSelector, options, parameters, issuerAddress);
  }
  async triggerConfirmedConstantContract(contractAddress, functionSelector, options = {}, parameters = [], issuerAddress = this.tronWeb.defaultAddress.hex) {
    options._isConstant = true;
    options.confirmed = true;
    return this._triggerSmartContract(contractAddress, functionSelector, options, parameters, issuerAddress);
  }
  async estimateEnergy(contractAddress, functionSelector, options = {}, parameters = [], issuerAddress = this.tronWeb.defaultAddress.hex) {
    options.estimateEnergy = true;
    const result = await this._triggerSmartContract(contractAddress, functionSelector, options, parameters, issuerAddress);
    return result;
  }
  async deployConstantContract(options = { input: "", ownerAddress: "" }) {
    const { input, ownerAddress, tokenId, tokenValue, callValue = 0 } = options;
    this.validator.notValid([
      {
        name: "input",
        type: "not-empty-string",
        value: input
      },
      {
        name: "callValue",
        type: "integer",
        value: callValue,
        gte: 0
      },
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "tokenValue",
        type: "integer",
        value: tokenValue,
        gte: 0,
        optional: true
      },
      {
        name: "tokenId",
        type: "integer",
        value: tokenId,
        gte: 0,
        optional: true
      }
    ]);
    const args = {
      data: input,
      owner_address: toHex(ownerAddress),
      call_value: callValue
    };
    if (tokenId) {
      args.token_id = tokenId;
    }
    if (tokenValue) {
      args.call_token_value = tokenValue;
    }
    const pathInfo = `wallet${options.confirmed ? "solidity" : ""}/estimateenergy`;
    const transaction = await this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(pathInfo, args, "post");
    if (transaction.Error)
      throw new Error(transaction.Error);
    if (transaction.result && transaction.result.message) {
      throw new Error(this.tronWeb.toUtf8(transaction.result.message));
    }
    return transaction;
  }
  _getTriggerSmartContractArgs(contractAddress, functionSelector, options, parameters, issuerAddress, tokenValue, tokenId, callValue, feeLimit) {
    var _a3;
    const args = {
      contract_address: toHex(contractAddress),
      owner_address: toHex(issuerAddress)
    };
    if (functionSelector && isString(functionSelector)) {
      functionSelector = functionSelector.replace(/\s*/g, "");
      let parameterStr;
      if (parameters.length) {
        const abiCoder2 = new AbiCoder();
        let types = [];
        const values = [];
        for (let i = 0; i < parameters.length; i++) {
          let { value } = parameters[i];
          const { type } = parameters[i];
          if (!type || !isString(type) || !type.length)
            throw new Error("Invalid parameter type provided: " + type);
          const replaceAddressPrefix = (value2) => {
            if (isArray(value2)) {
              return value2.map((v) => replaceAddressPrefix(v));
            }
            return toHex(value2).replace(ADDRESS_PREFIX_REGEX, "0x");
          };
          if (type === "address")
            value = replaceAddressPrefix(value);
          else if (((_a3 = type.match(/^([^\x5b]*)(\x5b|$)/)) == null ? void 0 : _a3[0]) === "address[")
            value = replaceAddressPrefix(value);
          types.push(type);
          values.push(value);
        }
        try {
          types = types.map((type) => {
            if (/trcToken/.test(type)) {
              type = type.replace(/trcToken/, "uint256");
            }
            return type;
          });
          parameterStr = abiCoder2.encode(types, values).replace(/^(0x)/, "");
        } catch (ex) {
          throw new Error(ex);
        }
      } else
        parameterStr = "";
      if (options.funcABIV2) {
        parameterStr = encodeParamsV2ByABI(options.funcABIV2, options.parametersV2).replace(/^(0x)/, "");
      }
      if (options.shieldedParameter && isString(options.shieldedParameter)) {
        parameterStr = options.shieldedParameter.replace(/^(0x)/, "");
      }
      if (options.rawParameter && isString(options.rawParameter)) {
        parameterStr = options.rawParameter.replace(/^(0x)/, "");
      }
      args.function_selector = functionSelector;
      args.parameter = parameterStr;
    } else if (options.input) {
      args.data = options.input;
    }
    args.call_value = parseInt(callValue);
    if (isNotNullOrUndefined(tokenValue))
      args.call_token_value = parseInt(tokenValue);
    if (isNotNullOrUndefined(tokenId))
      args.token_id = parseInt(tokenId);
    if (!(options._isConstant || options.estimateEnergy)) {
      args.fee_limit = parseInt(feeLimit);
    }
    if (options.permissionId) {
      args.Permission_id = options.permissionId;
    }
    return args;
  }
  async _triggerSmartContractLocal(contractAddress, functionSelector, options = {}, parameters = [], issuerAddress = this.tronWeb.defaultAddress.hex) {
    const { tokenValue, tokenId, callValue, feeLimit } = Object.assign({
      callValue: 0,
      feeLimit: this.tronWeb.feeLimit
    }, options);
    this.validator.notValid([
      {
        name: "feeLimit",
        type: "integer",
        value: feeLimit,
        gt: 0
      },
      {
        name: "callValue",
        type: "integer",
        value: callValue,
        gte: 0
      },
      {
        name: "parameters",
        type: "array",
        value: parameters
      },
      {
        name: "contract",
        type: "address",
        value: contractAddress
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress,
        optional: true
      },
      {
        name: "tokenValue",
        type: "integer",
        value: tokenValue,
        gte: 0,
        optional: true
      },
      {
        name: "tokenId",
        type: "integer",
        value: tokenId,
        gte: 0,
        optional: true
      }
    ]);
    const args = this._getTriggerSmartContractArgs(contractAddress, functionSelector, options, parameters, issuerAddress, tokenValue, tokenId, callValue, feeLimit);
    if (args.function_selector) {
      args.data = keccak256(Buffer.from(args.function_selector, "utf-8")).toString().substring(2, 10) + args.parameter;
    }
    const value = {
      data: args.data,
      owner_address: args.owner_address,
      contract_address: args.contract_address
    };
    if (args.call_value) {
      value.call_value = args.call_value;
    }
    if (args.call_token_value) {
      value.call_token_value = args.call_token_value;
    }
    if (args.token_id) {
      value.token_id = args.token_id;
    }
    const transactionOptions = getTransactionOptions(options);
    const transaction = await createTransaction(this.tronWeb, ContractType.TriggerSmartContract, value, options.permissionId, {
      ...transactionOptions,
      fee_limit: args.fee_limit
    });
    return {
      result: {
        result: true
      },
      transaction
    };
  }
  async _triggerSmartContract(contractAddress, functionSelector, options = {}, parameters = [], issuerAddress = this.tronWeb.defaultAddress.hex) {
    const { tokenValue, tokenId, callValue, feeLimit } = Object.assign({
      callValue: 0,
      feeLimit: this.tronWeb.feeLimit
    }, options);
    this.validator.notValid([
      {
        name: "feeLimit",
        type: "integer",
        value: feeLimit,
        gt: 0
      },
      {
        name: "callValue",
        type: "integer",
        value: callValue,
        gte: 0
      },
      {
        name: "parameters",
        type: "array",
        value: parameters
      },
      {
        name: "contract",
        type: "address",
        value: contractAddress
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress,
        optional: true
      },
      {
        name: "tokenValue",
        type: "integer",
        value: tokenValue,
        gte: 0,
        optional: true
      },
      {
        name: "tokenId",
        type: "integer",
        value: tokenId,
        gte: 0,
        optional: true
      }
    ]);
    const args = this._getTriggerSmartContractArgs(contractAddress, functionSelector, options, parameters, issuerAddress, tokenValue, tokenId, callValue, feeLimit);
    let pathInfo = "triggersmartcontract";
    if (options._isConstant) {
      pathInfo = "triggerconstantcontract";
    } else if (options.estimateEnergy) {
      pathInfo = "estimateenergy";
    }
    pathInfo = `wallet${options.confirmed ? "solidity" : ""}/${pathInfo}`;
    const transaction = await this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(pathInfo, args, "post");
    return resultManagerTriggerSmartContract(transaction, args, options);
  }
  async clearABI(contractAddress, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    if (!TronWeb.isAddress(contractAddress))
      throw new Error("Invalid contract address provided");
    if (!TronWeb.isAddress(ownerAddress))
      throw new Error("Invalid owner address provided");
    const data = {
      contract_address: toHex(contractAddress),
      owner_address: toHex(ownerAddress)
    };
    if (this.tronWeb.trx.cache.contracts[contractAddress]) {
      delete this.tronWeb.trx.cache.contracts[contractAddress];
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ClearABIContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async updateBrokerage(brokerage, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    if (!isNotNullOrUndefined(brokerage))
      throw new Error("Invalid brokerage provided");
    if (!isInteger(brokerage) || brokerage < 0 || brokerage > 100)
      throw new Error("Brokerage must be an integer between 0 and 100");
    if (!TronWeb.isAddress(ownerAddress))
      throw new Error("Invalid owner address provided");
    const data = {
      brokerage: parseInt(brokerage),
      owner_address: toHex(ownerAddress)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UpdateBrokerageContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async createToken(options = {}, issuerAddress = this.tronWeb.defaultAddress.hex) {
    const {
      name = false,
      abbreviation = false,
      description = "",
      url = false,
      totalSupply = 0,
      trxRatio = 1,
      // How much TRX will `tokenRatio` cost
      tokenRatio = 1,
      // How many tokens will `trxRatio` afford
      saleStart = Date.now(),
      saleEnd = false,
      freeBandwidth = 0,
      // The creator's "donated" bandwidth for use by token holders
      freeBandwidthLimit = 0,
      // Out of `totalFreeBandwidth`, the amount each token holder get
      frozenAmount = 0,
      frozenDuration = 0,
      // for now there is no default for the following values
      voteScore,
      precision
    } = options;
    this.validator.notValid([
      {
        name: "Supply amount",
        type: "positive-integer",
        value: totalSupply
      },
      {
        name: "TRX ratio",
        type: "positive-integer",
        value: trxRatio
      },
      {
        name: "Token ratio",
        type: "positive-integer",
        value: tokenRatio
      },
      {
        name: "token abbreviation",
        type: "string",
        value: abbreviation,
        lte: 32,
        gt: 0
      },
      {
        name: "token name",
        type: "not-empty-string",
        value: name
      },
      {
        name: "token description",
        type: "string",
        value: description,
        lte: 200
      },
      {
        name: "token url",
        type: "url",
        value: url
      },
      {
        name: "token url",
        type: "string",
        value: url,
        lte: 256
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      },
      {
        name: "sale start timestamp",
        type: "integer",
        value: saleStart,
        gte: Date.now()
      },
      {
        name: "sale end timestamp",
        type: "integer",
        value: saleEnd,
        gt: saleStart
      },
      {
        name: "Frozen supply",
        type: "integer",
        value: frozenAmount,
        gte: 0
      },
      {
        name: "Frozen duration",
        type: "integer",
        value: frozenDuration,
        gte: 0
      }
    ]);
    if (isNotNullOrUndefined(voteScore) && (!isInteger(voteScore) || voteScore <= 0))
      throw new Error("voteScore must be a positive integer greater than 0");
    if (isNotNullOrUndefined(precision) && (!isInteger(precision) || precision < 0 || precision > 6))
      throw new Error("precision must be a positive integer >= 0 and <= 6");
    const data = {
      owner_address: toHex(issuerAddress),
      name: fromUtf8(name),
      abbr: fromUtf8(abbreviation),
      description: fromUtf8(description),
      url: fromUtf8(url),
      total_supply: parseInt(totalSupply),
      trx_num: parseInt(trxRatio),
      num: parseInt(tokenRatio),
      start_time: parseInt(saleStart),
      end_time: parseInt(saleEnd),
      frozen_supply: [
        {
          frozen_amount: parseInt(frozenAmount),
          frozen_days: parseInt(frozenDuration)
        }
      ]
    };
    ["name", "abbr", "description", "url"].forEach((key) => {
      if (!data[key]) {
        delete data[key];
      }
    });
    if (!(parseInt(frozenAmount) > 0)) {
      delete data.frozen_supply;
    }
    if (freeBandwidth && !isNaN(parseInt(freeBandwidth)) && parseInt(freeBandwidth) >= 0) {
      data.free_asset_net_limit = parseInt(freeBandwidth);
    }
    if (freeBandwidthLimit && !isNaN(parseInt(freeBandwidthLimit)) && parseInt(freeBandwidthLimit) >= 0) {
      data.public_free_asset_net_limit = parseInt(freeBandwidthLimit);
    }
    if (precision && !isNaN(parseInt(precision))) {
      data.precision = parseInt(precision);
    }
    if (voteScore && !isNaN(parseInt(voteScore))) {
      data.vote_score = parseInt(voteScore);
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.AssetIssueContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async createAccount(accountAddress, address = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "account",
        type: "address",
        value: accountAddress
      },
      {
        name: "origin",
        type: "address",
        value: address
      }
    ]);
    const data = {
      owner_address: toHex(address),
      account_address: toHex(accountAddress)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.AccountCreateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async updateAccount(accountName, address = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "Name",
        type: "string",
        lte: 200,
        gt: 0,
        value: accountName,
        msg: "Invalid accountName"
      },
      {
        name: "origin",
        type: "address",
        value: address
      }
    ]);
    const data = {
      account_name: fromUtf8(accountName),
      owner_address: toHex(address)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.AccountUpdateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async setAccountId(accountId, address = this.tronWeb.defaultAddress.hex, options = {}) {
    if (accountId && isString(accountId) && accountId.startsWith("0x")) {
      accountId = accountId.slice(2);
    }
    this.validator.notValid([
      {
        name: "accountId",
        type: "hex",
        value: accountId
      },
      {
        name: "accountId",
        type: "string",
        lte: 32,
        gte: 8,
        value: accountId
      },
      {
        name: "origin",
        type: "address",
        value: address
      }
    ]);
    const data = {
      account_id: accountId,
      owner_address: toHex(address)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.SetAccountIdContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async updateToken(options = {}, issuerAddress = this.tronWeb.defaultAddress.hex) {
    const {
      description = "",
      url = false,
      freeBandwidth = 0,
      // The creator's "donated" bandwidth for use by token holders
      freeBandwidthLimit = 0
      // Out of `totalFreeBandwidth`, the amount each token holder get
    } = options;
    this.validator.notValid([
      {
        name: "token description",
        type: "string",
        value: description,
        lte: 200
      },
      {
        name: "token url",
        type: "url",
        value: url
      },
      {
        name: "token url",
        type: "string",
        value: url,
        lte: 256
      },
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      }
    ]);
    const data = {
      owner_address: toHex(issuerAddress),
      description: fromUtf8(description),
      url: fromUtf8(url)
    };
    if (freeBandwidth && !isNaN(parseInt(freeBandwidth)) && parseInt(freeBandwidth) >= 0) {
      data.new_limit = parseInt(freeBandwidth);
    }
    if (freeBandwidthLimit && !isNaN(parseInt(freeBandwidthLimit)) && parseInt(freeBandwidthLimit) >= 0) {
      data.new_public_limit = parseInt(freeBandwidthLimit);
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UpdateAssetContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async sendAsset(to, amount = 0, tokenId, from = this.tronWeb.defaultAddress.hex, options = {}) {
    return this.sendToken(to, amount, tokenId, from, options);
  }
  async purchaseAsset(issuerAddress, tokenId, amount = 0, buyer = this.tronWeb.defaultAddress.hex, options = {}) {
    return this.purchaseToken(issuerAddress, tokenId, amount, buyer, options);
  }
  async createAsset(options, issuerAddress) {
    return this.createToken(options, issuerAddress);
  }
  async updateAsset(options = {}, issuerAddress = this.tronWeb.defaultAddress.hex) {
    return this.updateToken(options, issuerAddress);
  }
  /**
   * Creates a proposal to modify the network.
   * Can only be created by a current Super Representative.
   */
  async createProposal(parameters, issuerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      }
    ]);
    const invalid = "Invalid proposal parameters provided";
    if (!parameters)
      throw new Error(invalid);
    const newParams = isArray(parameters) ? parameters : [parameters];
    for (const parameter of newParams) {
      if (!isObject(parameter))
        throw new Error(invalid);
    }
    const data = {
      owner_address: toHex(issuerAddress),
      parameters: newParams
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ProposalCreateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Deletes a network modification proposal that the owner issued.
   * Only current Super Representative can vote on a proposal.
   */
  async deleteProposal(proposalID, issuerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "issuer",
        type: "address",
        value: issuerAddress
      },
      {
        name: "proposalID",
        type: "integer",
        value: proposalID,
        gte: 0
      }
    ]);
    const data = {
      owner_address: toHex(issuerAddress),
      proposal_id: parseInt(proposalID)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ProposalDeleteContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Adds a vote to an issued network modification proposal.
   * Only current Super Representative can vote on a proposal.
   */
  async voteProposal(proposalID, isApproval = false, voterAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "voter",
        type: "address",
        value: voterAddress
      },
      {
        name: "proposalID",
        type: "integer",
        value: proposalID,
        gte: 0
      },
      {
        name: "has approval",
        type: "boolean",
        value: isApproval
      }
    ]);
    const data = {
      owner_address: toHex(voterAddress),
      proposal_id: parseInt(proposalID),
      is_add_approval: isApproval
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ProposalApproveContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Create an exchange between a token and TRX.
   * Token Name should be a CASE SENSITIVE string.
   * PLEASE VERIFY THIS ON TRONSCAN.
   */
  async createTRXExchange(tokenName, tokenBalance, trxBalance, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "token name",
        type: "not-empty-string",
        value: tokenName
      },
      {
        name: "token balance",
        type: "positive-integer",
        value: tokenBalance
      },
      {
        name: "trx balance",
        type: "positive-integer",
        value: trxBalance
      }
    ]);
    const data = {
      owner_address: toHex(ownerAddress),
      first_token_id: fromUtf8(tokenName),
      first_token_balance: tokenBalance,
      second_token_id: "5f",
      // Constant for TRX.
      second_token_balance: trxBalance
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ExchangeCreateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Create an exchange between a token and another token.
   * DO NOT USE THIS FOR TRX.
   * Token Names should be a CASE SENSITIVE string.
   * PLEASE VERIFY THIS ON TRONSCAN.
   */
  async createTokenExchange(firstTokenName, firstTokenBalance, secondTokenName, secondTokenBalance, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "first token name",
        type: "not-empty-string",
        value: firstTokenName
      },
      {
        name: "second token name",
        type: "not-empty-string",
        value: secondTokenName
      },
      {
        name: "first token balance",
        type: "positive-integer",
        value: firstTokenBalance
      },
      {
        name: "second token balance",
        type: "positive-integer",
        value: secondTokenBalance
      }
    ]);
    const data = {
      owner_address: toHex(ownerAddress),
      first_token_id: fromUtf8(firstTokenName),
      first_token_balance: firstTokenBalance,
      second_token_id: fromUtf8(secondTokenName),
      second_token_balance: secondTokenBalance
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ExchangeCreateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Adds tokens into a bancor style exchange.
   * Will add both tokens at market rate.
   * Use "_" for the constant value for TRX.
   */
  async injectExchangeTokens(exchangeID, tokenName, tokenAmount, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "token name",
        type: "not-empty-string",
        value: tokenName
      },
      {
        name: "token amount",
        type: "integer",
        value: tokenAmount,
        gte: 1
      },
      {
        name: "exchangeID",
        type: "integer",
        value: exchangeID,
        gte: 0
      }
    ]);
    const data = {
      owner_address: toHex(ownerAddress),
      exchange_id: parseInt(exchangeID),
      token_id: fromUtf8(tokenName),
      quant: parseInt(tokenAmount)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ExchangeInjectContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Withdraws tokens from a bancor style exchange.
   * Will withdraw at market rate both tokens.
   * Use "_" for the constant value for TRX.
   */
  async withdrawExchangeTokens(exchangeID, tokenName, tokenAmount, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "token name",
        type: "not-empty-string",
        value: tokenName
      },
      {
        name: "token amount",
        type: "integer",
        value: tokenAmount,
        gte: 1
      },
      {
        name: "exchangeID",
        type: "integer",
        value: exchangeID,
        gte: 0
      }
    ]);
    const data = {
      owner_address: toHex(ownerAddress),
      exchange_id: parseInt(exchangeID),
      token_id: fromUtf8(tokenName),
      quant: parseInt(tokenAmount)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ExchangeWithdrawContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Trade tokens on a bancor style exchange.
   * Expected value is a validation and used to cap the total amt of token 2 spent.
   * Use "_" for the constant value for TRX.
   */
  async tradeExchangeTokens(exchangeID, tokenName, tokenAmountSold, tokenAmountExpected, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "token name",
        type: "not-empty-string",
        value: tokenName
      },
      {
        name: "tokenAmountSold",
        type: "integer",
        value: tokenAmountSold,
        gte: 1
      },
      {
        name: "tokenAmountExpected",
        type: "integer",
        value: tokenAmountExpected,
        gte: 1
      },
      {
        name: "exchangeID",
        type: "integer",
        value: exchangeID,
        gte: 0
      }
    ]);
    const data = {
      owner_address: toHex(ownerAddress),
      exchange_id: parseInt(exchangeID),
      token_id: TronWeb.fromAscii(tokenName).replace(/^0x/, ""),
      quant: parseInt(tokenAmountSold),
      expected: parseInt(tokenAmountExpected)
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.ExchangeTransactionContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Update userFeePercentage.
   */
  async updateSetting(contractAddress, userFeePercentage, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "contract",
        type: "address",
        value: contractAddress
      },
      {
        name: "userFeePercentage",
        type: "integer",
        value: userFeePercentage,
        gte: 0,
        lte: 100
      }
    ]);
    const data = {
      owner_address: toHex(ownerAddress),
      contract_address: toHex(contractAddress),
      consume_user_resource_percent: userFeePercentage
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UpdateSettingContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  /**
   * Update energy limit.
   */
  async updateEnergyLimit(contractAddress, originEnergyLimit = 0, ownerAddress = this.tronWeb.defaultAddress.hex, options = {}) {
    this.validator.notValid([
      {
        name: "owner",
        type: "address",
        value: ownerAddress
      },
      {
        name: "contract",
        type: "address",
        value: contractAddress
      },
      {
        name: "originEnergyLimit",
        type: "integer",
        value: originEnergyLimit,
        gte: 0,
        lte: 1e7
      }
    ]);
    const data = {
      owner_address: toHex(ownerAddress),
      contract_address: toHex(contractAddress),
      origin_energy_limit: originEnergyLimit
    };
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.UpdateEnergyLimitContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  checkPermissions(permissions, type) {
    if (permissions) {
      if (permissions.type !== type || !permissions.permission_name || !isString(permissions.permission_name) || !isInteger(permissions.threshold) || permissions.threshold < 1 || !permissions.keys) {
        return false;
      }
      for (const key of permissions.keys) {
        if (!TronWeb.isAddress(key.address) || !isInteger(key.weight) || key.weight > permissions.threshold || key.weight < 1 || type === 2 && !permissions.operations) {
          return false;
        }
      }
    }
    return true;
  }
  async updateAccountPermissions(ownerAddress = this.tronWeb.defaultAddress.hex, ownerPermission, witnessPermission, activesPermissions, options = {}) {
    var _a3;
    if (!TronWeb.isAddress(ownerAddress))
      throw new Error("Invalid ownerAddress provided");
    if (!this.checkPermissions(ownerPermission, 0)) {
      throw new Error("Invalid ownerPermissions provided");
    }
    if (!this.checkPermissions(witnessPermission, 1)) {
      throw new Error("Invalid witnessPermissions provided");
    }
    if (!Array.isArray(activesPermissions)) {
      activesPermissions = [activesPermissions];
    }
    for (const activesPermission of activesPermissions) {
      if (!this.checkPermissions(activesPermission, 2)) {
        throw new Error("Invalid activesPermissions provided");
      }
    }
    const data = {
      owner_address: toHex(ownerAddress)
    };
    if (ownerPermission) {
      const _ownerPermissions = deepCopyJson(ownerPermission);
      if ("type" in _ownerPermissions) {
        delete _ownerPermissions.type;
      }
      _ownerPermissions.keys = (_a3 = _ownerPermissions.keys) == null ? void 0 : _a3.map(({ address, weight }) => ({
        address: this.tronWeb.address.toHex(address),
        weight
      }));
      data.owner = _ownerPermissions;
    }
    if (witnessPermission) {
      const _witnessPermissions = deepCopyJson(witnessPermission);
      _witnessPermissions.type = "Witness";
      _witnessPermissions.keys = _witnessPermissions.keys.map(({ address, weight }) => ({
        address: this.tronWeb.address.toHex(address),
        weight
      }));
      data.witness = _witnessPermissions;
    }
    if (activesPermissions) {
      const _activesPermissions = deepCopyJson(activesPermissions);
      _activesPermissions.forEach((activePermissions) => {
        activePermissions.type = "Active";
      });
      _activesPermissions.forEach((_activesPermission) => {
        _activesPermission.keys = _activesPermission.keys.map(({ address, weight }) => ({
          address: this.tronWeb.address.toHex(address),
          weight
        }));
      });
      data.actives = _activesPermissions;
    }
    const transactionOptions = getTransactionOptions(options);
    return createTransaction(this.tronWeb, ContractType.AccountPermissionUpdateContract, data, options == null ? void 0 : options.permissionId, transactionOptions);
  }
  async newTxID(transaction, options = {}) {
    if (options == null ? void 0 : options.txLocal) {
      const contract = transaction.raw_data.contract[0];
      try {
        const tx = await createTransaction(this.tronWeb, contract.type, contract.parameter.value, contract.Permission_id, {
          fee_limit: transaction.raw_data.fee_limit,
          data: transaction.raw_data.data,
          ref_block_bytes: transaction.raw_data.ref_block_bytes,
          ref_block_hash: transaction.raw_data.ref_block_hash,
          expiration: transaction.raw_data.expiration,
          timestamp: transaction.raw_data.timestamp
        });
        tx.signature = transaction.signature;
        tx.visible = transaction.visible;
        return tx;
      } catch (e) {
        throw new Error("Error generating a new transaction id.");
      }
    }
    try {
      const res = await this.tronWeb.fullNode.request("wallet/getsignweight", transaction, "post");
      if (typeof transaction.visible === "boolean") {
        res.transaction.transaction.visible = transaction.visible;
      }
      return resultManager(
        res.transaction.transaction,
        {
          ...transaction.raw_data.contract[0].parameter.value,
          Permission_id: transaction.raw_data.contract[0].Permission_id
        },
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        /* @ts-ignore */
        { data: transaction.raw_data.data, fee_limit: transaction.raw_data.fee_limit }
      );
    } catch (e) {
      throw new Error("Error generating a new transaction id.");
    }
  }
  async alterTransaction(transaction, options = {}) {
    if (Reflect.has(transaction, "signature"))
      throw new Error("You can not extend the expiration of a signed transaction.");
    if (options.data) {
      if (options.dataFormat !== "hex")
        options.data = TronWeb.toHex(options.data);
      options.data = options.data.replace(/^0x/, "");
      if (options.data.length === 0)
        throw new Error("Invalid data provided");
      transaction.raw_data.data = options.data;
    }
    if (options.extension) {
      options.extension = parseInt(options.extension * 1e3);
      if (isNaN(options.extension) || transaction.raw_data.expiration + options.extension <= Date.now() + 3e3)
        throw new Error("Invalid extension provided");
      transaction.raw_data.expiration += options.extension;
    }
    return await this.newTxID(transaction, { txLocal: options.txLocal });
  }
  async extendExpiration(transaction, extension, options = {}) {
    return await this.alterTransaction(transaction, { extension, txLocal: options == null ? void 0 : options.txLocal });
  }
  async addUpdateData(transaction, data, dataFormat = "utf8", options = {}) {
    return this.alterTransaction(transaction, { data, dataFormat, txLocal: options == null ? void 0 : options.txLocal });
  }
};

// node_modules/tronweb/lib/esm/lib/trx.js
var TRX_MESSAGE_HEADER = "TRON Signed Message:\n32";
var ETH_MESSAGE_HEADER = "Ethereum Signed Message:\n32";
function toHex2(value) {
  return TronWeb.address.toHex(value);
}
var Trx = class _Trx {
  constructor(tronWeb) {
    __publicField(this, "tronWeb");
    __publicField(this, "cache");
    __publicField(this, "validator");
    __publicField(this, "signMessage");
    __publicField(this, "sendAsset");
    __publicField(this, "send");
    __publicField(this, "sendTrx");
    __publicField(this, "broadcast");
    __publicField(this, "broadcastHex");
    __publicField(this, "signTransaction");
    this.tronWeb = tronWeb;
    this.cache = {
      contracts: {}
    };
    this.validator = new Validator();
    this.signMessage = this.sign;
    this.sendAsset = this.sendToken;
    this.send = this.sendTransaction;
    this.sendTrx = this.sendTransaction;
    this.broadcast = this.sendRawTransaction;
    this.broadcastHex = this.sendHexTransaction;
    this.signTransaction = this.sign;
  }
  _parseToken(token) {
    return {
      ...token,
      name: this.tronWeb.toUtf8(token.name),
      abbr: token.abbr && this.tronWeb.toUtf8(token.abbr),
      description: token.description && this.tronWeb.toUtf8(token.description),
      url: token.url && this.tronWeb.toUtf8(token.url)
    };
  }
  getCurrentBlock() {
    return this.tronWeb.fullNode.request("wallet/getnowblock");
  }
  getConfirmedCurrentBlock() {
    return this.tronWeb.solidityNode.request("walletsolidity/getnowblock");
  }
  async getBlock(block = this.tronWeb.defaultBlock) {
    if (block === false) {
      throw new Error("No block identifier provided");
    }
    if (block == "earliest")
      block = 0;
    if (block == "latest")
      return this.getCurrentBlock();
    if (isNaN(+block) && utils_default2.isHex(block.toString()))
      return this.getBlockByHash(block);
    return this.getBlockByNumber(block);
  }
  async getBlockByHash(blockHash) {
    const block = await this.tronWeb.fullNode.request("wallet/getblockbyid", {
      value: blockHash
    }, "post");
    if (!Object.keys(block).length) {
      throw new Error("Block not found");
    }
    return block;
  }
  async getBlockByNumber(blockID) {
    if (!utils_default2.isInteger(blockID) || blockID < 0) {
      throw new Error("Invalid block number provided");
    }
    return this.tronWeb.fullNode.request("wallet/getblockbynum", {
      num: parseInt(blockID)
    }, "post").then((block) => {
      if (!Object.keys(block).length) {
        throw new Error("Block not found");
      }
      return block;
    });
  }
  async getBlockTransactionCount(block = this.tronWeb.defaultBlock) {
    const { transactions = [] } = await this.getBlock(block);
    return transactions.length;
  }
  async getTransactionFromBlock(block = this.tronWeb.defaultBlock, index) {
    const { transactions } = await this.getBlock(block);
    if (!transactions) {
      throw new Error("Transaction not found in block");
    }
    if (index >= 0 && index < transactions.length)
      return transactions[index];
    else
      throw new Error("Invalid transaction index provided");
  }
  async getTransactionsFromBlock(block = this.tronWeb.defaultBlock) {
    const { transactions } = await this.getBlock(block);
    if (!transactions) {
      throw new Error("Transaction not found in block");
    }
    return transactions;
  }
  async getTransaction(transactionID) {
    const transaction = await this.tronWeb.fullNode.request("wallet/gettransactionbyid", {
      value: transactionID
    }, "post");
    if (!Object.keys(transaction).length) {
      throw new Error("Transaction not found");
    }
    return transaction;
  }
  async getConfirmedTransaction(transactionID) {
    const transaction = await this.tronWeb.solidityNode.request("walletsolidity/gettransactionbyid", {
      value: transactionID
    }, "post");
    if (!Object.keys(transaction).length) {
      throw new Error("Transaction not found");
    }
    return transaction;
  }
  getUnconfirmedTransactionInfo(transactionID) {
    return this.tronWeb.fullNode.request("wallet/gettransactioninfobyid", { value: transactionID }, "post");
  }
  getTransactionInfo(transactionID) {
    return this.tronWeb.solidityNode.request("walletsolidity/gettransactioninfobyid", { value: transactionID }, "post");
  }
  getTransactionsToAddress(address = this.tronWeb.defaultAddress.hex, limit = 30, offset = 0) {
    return this.getTransactionsRelated(this.tronWeb.address.toHex(address), "to", limit, offset);
  }
  getTransactionsFromAddress(address = this.tronWeb.defaultAddress.hex, limit = 30, offset = 0) {
    return this.getTransactionsRelated(this.tronWeb.address.toHex(address), "from", limit, offset);
  }
  async getTransactionsRelated(address = this.tronWeb.defaultAddress.hex, direction = "all", limit = 30, offset = 0) {
    if (this.tronWeb.fullnodeSatisfies(">=4.1.1")) {
      throw new Error("This api is not supported any more");
    }
    if (!["to", "from", "all"].includes(direction)) {
      throw new Error('Invalid direction provided: Expected "to", "from" or "all"');
    }
    if (direction == "all") {
      const [from, to] = await Promise.all([
        this.getTransactionsRelated(address, "from", limit, offset),
        this.getTransactionsRelated(address, "to", limit, offset)
      ]);
      return [
        ...from.map((tx) => (tx.direction = "from", tx)),
        ...to.map((tx) => (tx.direction = "to", tx))
      ].sort((a, b2) => {
        return b2.raw_data.timestamp - a.raw_data.timestamp;
      });
    }
    if (!this.tronWeb.isAddress(address)) {
      throw new Error("Invalid address provided");
    }
    if (!utils_default2.isInteger(limit) || limit < 0 || offset && limit < 1) {
      throw new Error("Invalid limit provided");
    }
    if (!utils_default2.isInteger(offset) || offset < 0) {
      throw new Error("Invalid offset provided");
    }
    address = this.tronWeb.address.toHex(address);
    return this.tronWeb.solidityNode.request(`walletextension/gettransactions${direction}this`, {
      account: {
        address
      },
      offset,
      limit
    }, "post").then(({ transaction }) => {
      return transaction;
    });
  }
  async getAccount(address = this.tronWeb.defaultAddress.hex) {
    if (!this.tronWeb.isAddress(address)) {
      throw new Error("Invalid address provided");
    }
    address = this.tronWeb.address.toHex(address);
    return this.tronWeb.solidityNode.request("walletsolidity/getaccount", {
      address
    }, "post");
  }
  getAccountById(id2) {
    return this.getAccountInfoById(id2, { confirmed: true });
  }
  async getAccountInfoById(id2, options) {
    this.validator.notValid([
      {
        name: "accountId",
        type: "hex",
        value: id2
      },
      {
        name: "accountId",
        type: "string",
        lte: 32,
        gte: 8,
        value: id2
      }
    ]);
    if (id2.startsWith("0x")) {
      id2 = id2.slice(2);
    }
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getaccountbyid`, {
      account_id: id2
    }, "post");
  }
  async getBalance(address = this.tronWeb.defaultAddress.hex) {
    const { balance = 0 } = await this.getAccount(address);
    return balance;
  }
  async getUnconfirmedAccount(address = this.tronWeb.defaultAddress.hex) {
    if (!this.tronWeb.isAddress(address)) {
      throw new Error("Invalid address provided");
    }
    address = this.tronWeb.address.toHex(address);
    return this.tronWeb.fullNode.request("wallet/getaccount", {
      address
    }, "post");
  }
  getUnconfirmedAccountById(id2) {
    return this.getAccountInfoById(id2, { confirmed: false });
  }
  async getUnconfirmedBalance(address = this.tronWeb.defaultAddress.hex) {
    const { balance = 0 } = await this.getUnconfirmedAccount(address);
    return balance;
  }
  async getBandwidth(address = this.tronWeb.defaultAddress.hex) {
    if (!this.tronWeb.isAddress(address)) {
      throw new Error("Invalid address provided");
    }
    address = this.tronWeb.address.toHex(address);
    return this.tronWeb.fullNode.request("wallet/getaccountnet", {
      address
    }, "post").then(({ freeNetUsed = 0, freeNetLimit = 0, NetUsed = 0, NetLimit = 0 }) => {
      return freeNetLimit - freeNetUsed + (NetLimit - NetUsed);
    });
  }
  async getTokensIssuedByAddress(address = this.tronWeb.defaultAddress.hex) {
    if (!this.tronWeb.isAddress(address)) {
      throw new Error("Invalid address provided");
    }
    address = this.tronWeb.address.toHex(address);
    return this.tronWeb.fullNode.request("wallet/getassetissuebyaccount", {
      address
    }, "post").then(({ assetIssue }) => {
      if (!assetIssue)
        return {};
      const tokens = assetIssue.map((token) => {
        return this._parseToken(token);
      }).reduce((tokens2, token) => {
        return tokens2[token.name] = token, tokens2;
      }, {});
      return tokens;
    });
  }
  async getTokenFromID(tokenID) {
    if (utils_default2.isInteger(tokenID))
      tokenID = tokenID.toString();
    if (!utils_default2.isString(tokenID) || !tokenID.length) {
      throw new Error("Invalid token ID provided");
    }
    return this.tronWeb.fullNode.request("wallet/getassetissuebyname", {
      value: this.tronWeb.fromUtf8(tokenID)
    }, "post").then((token) => {
      if (!token.name) {
        throw new Error("Token does not exist");
      }
      return this._parseToken(token);
    });
  }
  async listNodes() {
    const { nodes = [] } = await this.tronWeb.fullNode.request("wallet/listnodes");
    return nodes.map(({ address: { host, port } }) => `${this.tronWeb.toUtf8(host)}:${port}`);
  }
  async getBlockRange(start = 0, end = 30) {
    if (!utils_default2.isInteger(start) || start < 0) {
      throw new Error("Invalid start of range provided");
    }
    if (!utils_default2.isInteger(end) || end < start) {
      throw new Error("Invalid end of range provided");
    }
    if (end + 1 - start > 100) {
      throw new Error("Invalid range size, which should be no more than 100.");
    }
    return this.tronWeb.fullNode.request("wallet/getblockbylimitnext", {
      startNum: parseInt(start),
      endNum: parseInt(end) + 1
    }, "post").then(({ block = [] }) => block);
  }
  async listSuperRepresentatives() {
    const { witnesses = [] } = await this.tronWeb.fullNode.request("wallet/listwitnesses");
    return witnesses;
  }
  async listTokens(limit = 0, offset = 0) {
    if (!utils_default2.isInteger(limit) || limit < 0 || offset && limit < 1) {
      throw new Error("Invalid limit provided");
    }
    if (!utils_default2.isInteger(offset) || offset < 0) {
      throw new Error("Invalid offset provided");
    }
    if (!limit) {
      return this.tronWeb.fullNode.request("wallet/getassetissuelist").then(({ assetIssue = [] }) => assetIssue.map((token) => this._parseToken(token)));
    }
    return this.tronWeb.fullNode.request("wallet/getpaginatedassetissuelist", {
      offset: parseInt(offset),
      limit: parseInt(limit)
    }, "post").then(({ assetIssue = [] }) => assetIssue.map((token) => this._parseToken(token)));
  }
  async timeUntilNextVoteCycle() {
    const { num = -1 } = await this.tronWeb.fullNode.request("wallet/getnextmaintenancetime");
    if (num == -1) {
      throw new Error("Failed to get time until next vote cycle");
    }
    return Math.floor(num / 1e3);
  }
  async getContract(contractAddress) {
    if (!this.tronWeb.isAddress(contractAddress)) {
      throw new Error("Invalid contract address provided");
    }
    if (this.cache.contracts[contractAddress]) {
      return this.cache.contracts[contractAddress];
    }
    contractAddress = this.tronWeb.address.toHex(contractAddress);
    const contract = await this.tronWeb.fullNode.request("wallet/getcontract", {
      value: contractAddress
    });
    if (contract.Error) {
      throw new Error("Contract does not exist");
    }
    this.cache.contracts[contractAddress] = contract;
    return contract;
  }
  ecRecover(transaction) {
    return _Trx.ecRecover(transaction);
  }
  static ecRecover(transaction) {
    var _a3;
    if (!txCheck(transaction)) {
      throw new Error("Invalid transaction");
    }
    if (!((_a3 = transaction.signature) == null ? void 0 : _a3.length)) {
      throw new Error("Transaction is not signed");
    }
    if (transaction.signature.length === 1) {
      const tronAddress = ecRecover(transaction.txID, transaction.signature[0]);
      return TronWeb.address.fromHex(tronAddress);
    }
    return transaction.signature.map((sig) => {
      const tronAddress = ecRecover(transaction.txID, sig);
      return TronWeb.address.fromHex(tronAddress);
    });
  }
  async verifyMessage(message, signature, address = this.tronWeb.defaultAddress.base58, useTronHeader = true) {
    if (!utils_default2.isHex(message)) {
      throw new Error("Expected hex message input");
    }
    if (_Trx.verifySignature(message, address, signature, useTronHeader)) {
      return true;
    }
    throw new Error("Signature does not match");
  }
  static verifySignature(message, address, signature, useTronHeader = true) {
    message = message.replace(/^0x/, "");
    const messageBytes = [
      ...toUtf8Bytes(useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER),
      ...utils_default2.code.hexStr2byteArray(message)
    ];
    const messageDigest = keccak256(new Uint8Array(messageBytes));
    const recovered = recoverAddress(messageDigest, Signature.from(`0x${signature.replace(/^0x/, "")}`));
    const tronAddress = ADDRESS_PREFIX + recovered.substr(2);
    const base58Address = TronWeb.address.fromHex(tronAddress);
    return base58Address == TronWeb.address.fromHex(address);
  }
  async verifyMessageV2(message, signature) {
    return _Trx.verifyMessageV2(message, signature);
  }
  static verifyMessageV2(message, signature) {
    return utils_default2.message.verifyMessage(message, signature);
  }
  verifyTypedData(domain, types, value, signature, address = this.tronWeb.defaultAddress.base58) {
    if (_Trx.verifyTypedData(domain, types, value, signature, address))
      return true;
    throw new Error("Signature does not match");
  }
  static verifyTypedData(domain, types, value, signature, address) {
    const messageDigest = utils_default2._TypedDataEncoder.hash(domain, types, value);
    const recovered = recoverAddress(messageDigest, Signature.from(`0x${signature.replace(/^0x/, "")}`));
    const tronAddress = ADDRESS_PREFIX + recovered.substr(2);
    const base58Address = TronWeb.address.fromHex(tronAddress);
    return base58Address == TronWeb.address.fromHex(address);
  }
  async sign(transaction, privateKey = this.tronWeb.defaultPrivateKey, useTronHeader = true, multisig = false) {
    if (utils_default2.isString(transaction)) {
      if (!utils_default2.isHex(transaction)) {
        throw new Error("Expected hex message input");
      }
      return _Trx.signString(transaction, privateKey, useTronHeader);
    }
    if (!utils_default2.isObject(transaction)) {
      throw new Error("Invalid transaction provided");
    }
    if (!multisig && transaction.signature) {
      throw new Error("Transaction is already signed");
    }
    if (!multisig) {
      const address = this.tronWeb.address.toHex(this.tronWeb.address.fromPrivateKey(privateKey)).toLowerCase();
      if (address !== this.tronWeb.address.toHex(transaction.raw_data.contract[0].parameter.value.owner_address)) {
        throw new Error("Private key does not match address in transaction");
      }
      if (!txCheck(transaction)) {
        throw new Error("Invalid transaction");
      }
    }
    return utils_default2.crypto.signTransaction(privateKey, transaction);
  }
  static signString(message, privateKey, useTronHeader = true) {
    message = message.replace(/^0x/, "");
    const value = `0x${privateKey.replace(/^0x/, "")}`;
    const signingKey = new SigningKey(value);
    const messageBytes = [
      ...toUtf8Bytes(useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER),
      ...utils_default2.code.hexStr2byteArray(message)
    ];
    const messageDigest = keccak256(new Uint8Array(messageBytes));
    const signature = signingKey.sign(messageDigest);
    const signatureHex = ["0x", signature.r.substring(2), signature.s.substring(2), Number(signature.v).toString(16)].join("");
    return signatureHex;
  }
  /**
   * sign message v2 for verified header length
   *
   * @param {message to be signed, should be Bytes or string} message
   * @param {privateKey for signature} privateKey
   * @param {reserved} options
   */
  signMessageV2(message, privateKey = this.tronWeb.defaultPrivateKey) {
    return _Trx.signMessageV2(message, privateKey);
  }
  static signMessageV2(message, privateKey) {
    return utils_default2.message.signMessage(message, privateKey);
  }
  _signTypedData(domain, types, value, privateKey = this.tronWeb.defaultPrivateKey) {
    return _Trx._signTypedData(domain, types, value, privateKey);
  }
  static _signTypedData(domain, types, value, privateKey) {
    return utils_default2.crypto._signTypedData(domain, types, value, privateKey);
  }
  async multiSign(transaction, privateKey = this.tronWeb.defaultPrivateKey, permissionId = 0) {
    if (!utils_default2.isObject(transaction) || !transaction.raw_data || !transaction.raw_data.contract) {
      throw new Error("Invalid transaction provided");
    }
    if (!transaction.raw_data.contract[0].Permission_id && permissionId > 0) {
      transaction.raw_data.contract[0].Permission_id = permissionId;
      const address = this.tronWeb.address.toHex(this.tronWeb.address.fromPrivateKey(privateKey)).toLowerCase();
      const signWeight = await this.getSignWeight(transaction, permissionId);
      if (signWeight.result.code === "PERMISSION_ERROR") {
        throw new Error(signWeight.result.message);
      }
      let foundKey = false;
      signWeight.permission.keys.map((key) => {
        if (key.address === address)
          foundKey = true;
      });
      if (!foundKey) {
        throw new Error(privateKey + " has no permission to sign");
      }
      if (signWeight.approved_list && signWeight.approved_list.indexOf(address) != -1) {
        throw new Error(privateKey + " already sign transaction");
      }
      if (signWeight.transaction && signWeight.transaction.transaction) {
        transaction = signWeight.transaction.transaction;
        if (permissionId > 0) {
          transaction.raw_data.contract[0].Permission_id = permissionId;
        }
      } else {
        throw new Error("Invalid transaction provided");
      }
    }
    if (!txCheck(transaction)) {
      throw new Error("Invalid transaction");
    }
    return utils_default2.crypto.signTransaction(privateKey, transaction);
  }
  async getApprovedList(transaction) {
    if (!utils_default2.isObject(transaction)) {
      throw new Error("Invalid transaction provided");
    }
    return this.tronWeb.fullNode.request("wallet/getapprovedlist", transaction, "post");
  }
  async getSignWeight(transaction, permissionId) {
    if (!utils_default2.isObject(transaction) || !transaction.raw_data || !transaction.raw_data.contract)
      throw new Error("Invalid transaction provided");
    if (utils_default2.isInteger(permissionId)) {
      transaction.raw_data.contract[0].Permission_id = parseInt(permissionId);
    } else if (typeof transaction.raw_data.contract[0].Permission_id !== "number") {
      transaction.raw_data.contract[0].Permission_id = 0;
    }
    return this.tronWeb.fullNode.request("wallet/getsignweight", transaction, "post");
  }
  async sendRawTransaction(signedTransaction) {
    if (!utils_default2.isObject(signedTransaction)) {
      throw new Error("Invalid transaction provided");
    }
    if (!signedTransaction.signature || !utils_default2.isArray(signedTransaction.signature)) {
      throw new Error("Transaction is not signed");
    }
    const result = await this.tronWeb.fullNode.request("wallet/broadcasttransaction", signedTransaction, "post");
    return {
      ...result,
      transaction: signedTransaction
    };
  }
  async sendHexTransaction(signedHexTransaction) {
    if (!utils_default2.isHex(signedHexTransaction)) {
      throw new Error("Invalid hex transaction provided");
    }
    const params = {
      transaction: signedHexTransaction
    };
    const result = await this.tronWeb.fullNode.request("wallet/broadcasthex", params, "post");
    if (result.result) {
      return {
        ...result,
        transaction: JSON.parse(result.transaction),
        hexTransaction: signedHexTransaction
      };
    }
    return result;
  }
  async sendTransaction(to, amount, options = {}) {
    if (typeof options === "string")
      options = { privateKey: options };
    if (!this.tronWeb.isAddress(to)) {
      throw new Error("Invalid recipient provided");
    }
    if (!utils_default2.isInteger(amount) || amount <= 0) {
      throw new Error("Invalid amount provided");
    }
    options = {
      privateKey: this.tronWeb.defaultPrivateKey,
      address: this.tronWeb.defaultAddress.hex,
      ...options
    };
    if (!options.privateKey && !options.address) {
      throw new Error("Function requires either a private key or address to be set");
    }
    const address = options.privateKey ? this.tronWeb.address.fromPrivateKey(options.privateKey) : options.address;
    const transaction = await this.tronWeb.transactionBuilder.sendTrx(to, amount, address);
    const signedTransaction = await this.sign(transaction, options.privateKey);
    const result = await this.sendRawTransaction(signedTransaction);
    return result;
  }
  async sendToken(to, amount, tokenID, options = {}) {
    if (typeof options === "string")
      options = { privateKey: options };
    if (!this.tronWeb.isAddress(to)) {
      throw new Error("Invalid recipient provided");
    }
    if (!utils_default2.isInteger(amount) || amount <= 0) {
      throw new Error("Invalid amount provided");
    }
    if (utils_default2.isInteger(tokenID))
      tokenID = tokenID.toString();
    if (!utils_default2.isString(tokenID)) {
      throw new Error("Invalid token ID provided");
    }
    options = {
      privateKey: this.tronWeb.defaultPrivateKey,
      address: this.tronWeb.defaultAddress.hex,
      ...options
    };
    if (!options.privateKey && !options.address) {
      throw new Error("Function requires either a private key or address to be set");
    }
    const address = options.privateKey ? this.tronWeb.address.fromPrivateKey(options.privateKey) : options.address;
    const transaction = await this.tronWeb.transactionBuilder.sendToken(to, amount, tokenID, address);
    const signedTransaction = await this.sign(transaction, options.privateKey);
    const result = await this.sendRawTransaction(signedTransaction);
    return result;
  }
  /**
   * Freezes an amount of TRX.
   * Will give bandwidth OR Energy and TRON Power(voting rights)
   * to the owner of the frozen tokens.
   *
   * @param amount - is the number of frozen trx
   * @param duration - is the duration in days to be frozen
   * @param resource - is the type, must be either "ENERGY" or "BANDWIDTH"
   * @param options
   */
  async freezeBalance(amount = 0, duration = 3, resource = "BANDWIDTH", options = {}, receiverAddress) {
    if (typeof options === "string")
      options = { privateKey: options };
    if (!["BANDWIDTH", "ENERGY"].includes(resource)) {
      throw new Error('Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"');
    }
    if (!utils_default2.isInteger(amount) || amount <= 0) {
      throw new Error("Invalid amount provided");
    }
    if (!utils_default2.isInteger(duration) || duration < 3) {
      throw new Error("Invalid duration provided, minimum of 3 days");
    }
    options = {
      privateKey: this.tronWeb.defaultPrivateKey,
      address: this.tronWeb.defaultAddress.hex,
      ...options
    };
    if (!options.privateKey && !options.address) {
      throw new Error("Function requires either a private key or address to be set");
    }
    const address = options.privateKey ? this.tronWeb.address.fromPrivateKey(options.privateKey) : options.address;
    const freezeBalance = await this.tronWeb.transactionBuilder.freezeBalance(amount, duration, resource, address, receiverAddress);
    const signedTransaction = await this.sign(freezeBalance, options.privateKey);
    const result = await this.sendRawTransaction(signedTransaction);
    return result;
  }
  /**
   * Unfreeze TRX that has passed the minimum freeze duration.
   * Unfreezing will remove bandwidth and TRON Power.
   *
   * @param resource - is the type, must be either "ENERGY" or "BANDWIDTH"
   * @param options
   */
  async unfreezeBalance(resource = "BANDWIDTH", options = {}, receiverAddress) {
    if (typeof options === "string")
      options = { privateKey: options };
    if (!["BANDWIDTH", "ENERGY"].includes(resource)) {
      throw new Error('Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"');
    }
    options = {
      privateKey: this.tronWeb.defaultPrivateKey,
      address: this.tronWeb.defaultAddress.hex,
      ...options
    };
    if (!options.privateKey && !options.address) {
      throw new Error("Function requires either a private key or address to be set");
    }
    const address = options.privateKey ? this.tronWeb.address.fromPrivateKey(options.privateKey) : options.address;
    const unfreezeBalance = await this.tronWeb.transactionBuilder.unfreezeBalance(resource, address, receiverAddress);
    const signedTransaction = await this.sign(unfreezeBalance, options.privateKey);
    const result = await this.sendRawTransaction(signedTransaction);
    return result;
  }
  /**
   * Modify account name
   * Note: Username is allowed to edit only once.
   *
   * @param privateKey - Account private Key
   * @param accountName - name of the account
   *
   * @return modified Transaction Object
   */
  async updateAccount(accountName, options = {}) {
    if (typeof options === "string")
      options = { privateKey: options };
    if (!utils_default2.isString(accountName) || !accountName.length) {
      throw new Error("Name must be a string");
    }
    options = {
      privateKey: this.tronWeb.defaultPrivateKey,
      address: this.tronWeb.defaultAddress.hex,
      ...options
    };
    if (!options.privateKey && !options.address)
      throw Error("Function requires either a private key or address to be set");
    const address = options.privateKey ? this.tronWeb.address.fromPrivateKey(options.privateKey) : options.address;
    const updateAccount = await this.tronWeb.transactionBuilder.updateAccount(accountName, address);
    const signedTransaction = await this.sign(updateAccount, options.privateKey);
    const result = await this.sendRawTransaction(signedTransaction);
    return result;
  }
  /**
   * Gets a network modification proposal by ID.
   */
  async getProposal(proposalID) {
    if (!utils_default2.isInteger(proposalID) || proposalID < 0) {
      throw new Error("Invalid proposalID provided");
    }
    return this.tronWeb.fullNode.request("wallet/getproposalbyid", {
      id: parseInt(proposalID)
    }, "post");
  }
  /**
   * Lists all network modification proposals.
   */
  async listProposals() {
    const { proposals = [] } = await this.tronWeb.fullNode.request("wallet/listproposals", {}, "post");
    return proposals;
  }
  /**
   * Lists all parameters available for network modification proposals.
   */
  async getChainParameters() {
    const { chainParameter = [] } = await this.tronWeb.fullNode.request("wallet/getchainparameters", {}, "post");
    return chainParameter;
  }
  /**
   * Get the account resources
   */
  async getAccountResources(address = this.tronWeb.defaultAddress.hex) {
    if (!this.tronWeb.isAddress(address)) {
      throw new Error("Invalid address provided");
    }
    return this.tronWeb.fullNode.request("wallet/getaccountresource", {
      address: this.tronWeb.address.toHex(address)
    }, "post");
  }
  /**
   * Query the amount of resources of a specific resourceType delegated by fromAddress to toAddress
   */
  async getDelegatedResourceV2(fromAddress = this.tronWeb.defaultAddress.hex, toAddress = this.tronWeb.defaultAddress.hex, options = { confirmed: true }) {
    if (!this.tronWeb.isAddress(fromAddress)) {
      throw new Error("Invalid address provided");
    }
    if (!this.tronWeb.isAddress(toAddress)) {
      throw new Error("Invalid address provided");
    }
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getdelegatedresourcev2`, {
      fromAddress: toHex2(fromAddress),
      toAddress: toHex2(toAddress)
    }, "post");
  }
  /**
   * Query the resource delegation index by an account
   */
  async getDelegatedResourceAccountIndexV2(address = this.tronWeb.defaultAddress.hex, options = { confirmed: true }) {
    if (!this.tronWeb.isAddress(address)) {
      throw new Error("Invalid address provided");
    }
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getdelegatedresourceaccountindexv2`, {
      value: toHex2(address)
    }, "post");
  }
  /**
   * Query the amount of delegatable resources of the specified resource Type for target address, unit is sun.
   */
  async getCanDelegatedMaxSize(address = this.tronWeb.defaultAddress.hex, resource = "BANDWIDTH", options = { confirmed: true }) {
    if (!this.tronWeb.isAddress(address)) {
      throw new Error("Invalid address provided");
    }
    this.validator.notValid([
      {
        name: "resource",
        type: "resource",
        value: resource,
        msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
      }
    ]);
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getcandelegatedmaxsize`, {
      owner_address: toHex2(address),
      type: resource === "ENERGY" ? 1 : 0
    }, "post");
  }
  /**
   * Remaining times of available unstaking API
   */
  async getAvailableUnfreezeCount(address = this.tronWeb.defaultAddress.hex, options = { confirmed: true }) {
    if (!this.tronWeb.isAddress(address)) {
      throw new Error("Invalid address provided");
    }
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getavailableunfreezecount`, {
      owner_address: toHex2(address)
    }, "post");
  }
  /**
   * Query the withdrawable balance at the specified timestamp
   */
  async getCanWithdrawUnfreezeAmount(address = this.tronWeb.defaultAddress.hex, timestamp = Date.now(), options = { confirmed: true }) {
    if (!this.tronWeb.isAddress(address)) {
      throw new Error("Invalid address provided");
    }
    if (!utils_default2.isInteger(timestamp) || timestamp < 0) {
      throw new Error("Invalid timestamp provided");
    }
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getcanwithdrawunfreezeamount`, {
      owner_address: toHex2(address),
      timestamp
    }, "post");
  }
  /**
   * Get the exchange ID.
   */
  async getExchangeByID(exchangeID) {
    if (!utils_default2.isInteger(exchangeID) || exchangeID < 0) {
      throw new Error("Invalid exchangeID provided");
    }
    return this.tronWeb.fullNode.request("wallet/getexchangebyid", {
      id: exchangeID
    }, "post");
  }
  /**
   * Lists the exchanges
   */
  async listExchanges() {
    return this.tronWeb.fullNode.request("wallet/listexchanges", {}, "post").then(({ exchanges = [] }) => exchanges);
  }
  /**
   * Lists all network modification proposals.
   */
  async listExchangesPaginated(limit = 10, offset = 0) {
    return this.tronWeb.fullNode.request("wallet/getpaginatedexchangelist", {
      limit,
      offset
    }, "post").then(({ exchanges = [] }) => exchanges);
  }
  /**
   * Get info about thre node
   */
  async getNodeInfo() {
    return this.tronWeb.fullNode.request("wallet/getnodeinfo", {}, "post");
  }
  async getTokenListByName(tokenID) {
    if (utils_default2.isInteger(tokenID))
      tokenID = tokenID.toString();
    if (!utils_default2.isString(tokenID) || !tokenID.length) {
      throw new Error("Invalid token ID provided");
    }
    return this.tronWeb.fullNode.request("wallet/getassetissuelistbyname", {
      value: this.tronWeb.fromUtf8(tokenID)
    }, "post").then((token) => {
      if (Array.isArray(token.assetIssue)) {
        return token.assetIssue.map((t) => this._parseToken(t));
      } else if (!token.name) {
        throw new Error("Token does not exist");
      }
      return this._parseToken(token);
    });
  }
  getTokenByID(tokenID) {
    if (utils_default2.isInteger(tokenID))
      tokenID = tokenID.toString();
    if (!utils_default2.isString(tokenID) || !tokenID.length) {
      throw new Error("Invalid token ID provided");
    }
    return this.tronWeb.fullNode.request("wallet/getassetissuebyid", {
      value: tokenID
    }, "post").then((token) => {
      if (!token.name) {
        throw new Error("Token does not exist");
      }
      return this._parseToken(token);
    });
  }
  async getReward(address, options = {}) {
    options.confirmed = true;
    return this._getReward(address, options);
  }
  async getUnconfirmedReward(address, options = {}) {
    options.confirmed = false;
    return this._getReward(address, options);
  }
  async getBrokerage(address, options = {}) {
    options.confirmed = true;
    return this._getBrokerage(address, options);
  }
  async getUnconfirmedBrokerage(address, options = {}) {
    options.confirmed = false;
    return this._getBrokerage(address, options);
  }
  async _getReward(address = this.tronWeb.defaultAddress.hex, options) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address
      }
    ]);
    const data = {
      address: toHex2(address)
    };
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getReward`, data, "post").then((result = { reward: void 0 }) => {
      if (typeof result.reward === "undefined") {
        throw new Error("Not found.");
      }
      return result.reward;
    });
  }
  async _getBrokerage(address = this.tronWeb.defaultAddress.hex, options) {
    this.validator.notValid([
      {
        name: "origin",
        type: "address",
        value: address
      }
    ]);
    const data = {
      address: toHex2(address)
    };
    return this.tronWeb[options.confirmed ? "solidityNode" : "fullNode"].request(`wallet${options.confirmed ? "solidity" : ""}/getBrokerage`, data, "post").then((result = {}) => {
      if (typeof result.brokerage === "undefined") {
        throw new Error("Not found.");
      }
      return result.brokerage;
    });
  }
  async getBandwidthPrices() {
    return this.tronWeb.fullNode.request("wallet/getbandwidthprices", {}, "post").then((result = {}) => {
      if (typeof result.prices === "undefined") {
        throw new Error("Not found.");
      }
      return result.prices;
    });
  }
  async getEnergyPrices() {
    return this.tronWeb.fullNode.request("wallet/getenergyprices", {}, "post").then((result = {}) => {
      if (typeof result.prices === "undefined") {
        throw new Error("Not found.");
      }
      return result.prices;
    });
  }
};

// node_modules/tronweb/lib/esm/lib/contract/method.js
var getFunctionSelector = (abi) => {
  if ("stateMutability" in abi) {
    abi.stateMutability = abi.stateMutability ? abi.stateMutability.toLowerCase() : "nonpayable";
  }
  abi.type = abi.type ? abi.type.toLowerCase() : "";
  if (abi.type === "fallback" || abi.type === "receive")
    return "0x";
  const iface = new utils_default2.ethersUtils.Interface([abi]);
  let obj;
  if (abi.type === "event") {
    obj = iface.getEvent(abi.name);
  } else {
    obj = iface.getFunction(abi.name);
  }
  if (obj) {
    return obj.format("sighash");
  }
  throw new Error("unknown function");
};
var decodeOutput = (abi, output3) => {
  return decodeParamsV2ByABI(abi, output3);
};
var Method = class {
  constructor(contract, abi) {
    __publicField(this, "tronWeb");
    __publicField(this, "contract");
    __publicField(this, "abi");
    __publicField(this, "name");
    __publicField(this, "inputs");
    __publicField(this, "outputs");
    __publicField(this, "functionSelector");
    __publicField(this, "signature");
    __publicField(this, "defaultOptions");
    this.tronWeb = contract.tronWeb;
    this.contract = contract;
    this.abi = abi;
    this.name = abi.name || abi.type;
    this.inputs = abi.inputs || [];
    this.outputs = [];
    if ("outputs" in abi && abi.outputs) {
      this.outputs = abi.outputs;
    }
    this.functionSelector = getFunctionSelector(abi);
    this.signature = sha32(this.functionSelector, false).slice(0, 8);
    this.defaultOptions = {
      feeLimit: this.tronWeb.feeLimit,
      callValue: 0,
      userFeePercentage: 100,
      shouldPollResponse: false
      // Only used for sign()
    };
  }
  decodeInput(data) {
    const abi = JSON.parse(JSON.stringify(this.abi));
    abi.outputs = abi.inputs;
    return decodeOutput(abi, "0x" + data);
  }
  onMethod(...args) {
    let rawParameter = "";
    if (this.abi && !/event/i.test(this.abi.type)) {
      rawParameter = encodeParamsV2ByABI(this.abi, args);
    }
    return {
      call: async (options = {}) => {
        options = {
          ...options,
          rawParameter
        };
        return await this._call([], [], options);
      },
      send: async (options = {}, privateKey = this.tronWeb.defaultPrivateKey) => {
        options = {
          ...options,
          rawParameter
        };
        return await this._send([], [], options, privateKey);
      }
    };
  }
  async _call(types, args, options = {}) {
    if (types.length !== args.length) {
      throw new Error("Invalid argument count provided");
    }
    if (!this.contract.address) {
      throw new Error("Smart contract is missing address");
    }
    if (!this.contract.deployed) {
      throw new Error("Calling smart contracts requires you to load the contract first");
    }
    if ("stateMutability" in this.abi) {
      const { stateMutability } = this.abi;
      if (stateMutability && !["pure", "view"].includes(stateMutability.toLowerCase())) {
        throw new Error(`Methods with state mutability "${stateMutability}" must use send()`);
      }
    }
    options = {
      ...this.defaultOptions,
      from: this.tronWeb.defaultAddress.hex,
      ...options,
      _isConstant: true
    };
    const parameters = args.map((value, index) => ({
      type: types[index],
      value
    }));
    const transaction = await this.tronWeb.transactionBuilder.triggerSmartContract(this.contract.address, this.functionSelector, options, parameters, options.from ? this.tronWeb.address.toHex(options.from) : void 0);
    if (!utils_default2.hasProperty(transaction, "constant_result")) {
      throw new Error("Failed to execute");
    }
    const len = transaction.constant_result[0].length;
    if (len === 0 || len % 64 === 8) {
      let msg = "The call has been reverted or has thrown an error.";
      if (len !== 0) {
        msg += " Error message: ";
        let msg2 = "";
        const chunk = transaction.constant_result[0].substring(8);
        for (let i = 0; i < len - 8; i += 64) {
          msg2 += this.tronWeb.toUtf8(chunk.substring(i, i + 64));
        }
        msg += msg2.replace(/(\u0000|\u000b|\f)+/g, " ").replace(/ +/g, " ").replace(/\s+$/g, "");
      }
      throw new Error(msg);
    }
    let output3 = decodeOutput(this.abi, "0x" + transaction.constant_result[0]);
    if (output3.length === 1 && Object.keys(output3).length === 1) {
      output3 = output3[0];
    }
    return output3;
  }
  async _send(types, args, options = {}, privateKey = this.tronWeb.defaultPrivateKey) {
    if (types.length !== args.length) {
      throw new Error("Invalid argument count provided");
    }
    if (!this.contract.address) {
      throw new Error("Smart contract is missing address");
    }
    if (!this.contract.deployed) {
      throw new Error("Calling smart contracts requires you to load the contract first");
    }
    const { stateMutability } = this.abi;
    if (["pure", "view"].includes(stateMutability.toLowerCase())) {
      throw new Error(`Methods with state mutability "${stateMutability}" must use call()`);
    }
    if (!["payable"].includes(stateMutability.toLowerCase())) {
      options.callValue = 0;
    }
    options = {
      ...this.defaultOptions,
      from: this.tronWeb.defaultAddress.hex,
      ...options
    };
    const parameters = args.map((value, index) => ({
      type: types[index],
      value
    }));
    const address = privateKey ? this.tronWeb.address.fromPrivateKey(privateKey) : this.tronWeb.defaultAddress.base58;
    const transaction = await this.tronWeb.transactionBuilder.triggerSmartContract(this.contract.address, this.functionSelector, options, parameters, this.tronWeb.address.toHex(address));
    if (!transaction.result || !transaction.result.result) {
      throw new Error("Unknown error: " + JSON.stringify(transaction, null, 2));
    }
    const signedTransaction = await this.tronWeb.trx.sign(transaction.transaction, privateKey);
    if (!signedTransaction.signature) {
      if (!privateKey) {
        throw new Error("Transaction was not signed properly");
      }
      throw new Error("Invalid private key provided");
    }
    const broadcast = await this.tronWeb.trx.sendRawTransaction(signedTransaction);
    if (broadcast.code) {
      const err = {
        error: broadcast.code,
        message: broadcast.code
      };
      if (broadcast.message)
        err.message = this.tronWeb.toUtf8(broadcast.message);
      const error = new Error(err.message);
      error.error = broadcast.code;
      throw error;
    }
    if (!options.shouldPollResponse) {
      return signedTransaction.txID;
    }
    const checkResult = async (index) => {
      if (index === (options.pollTimes || 20)) {
        const error = new Error("Cannot find result in solidity node");
        error.error = "Cannot find result in solidity node";
        error.transaction = signedTransaction;
        throw error;
      }
      const output3 = await this.tronWeb.trx.getTransactionInfo(signedTransaction.txID);
      if (!Object.keys(output3).length) {
        await new Promise((r) => setTimeout(r, 3e3));
        return checkResult(index + 1);
      }
      if (output3.result && output3.result === "FAILED") {
        const error = new Error(this.tronWeb.toUtf8(output3.resMessage));
        error.error = this.tronWeb.toUtf8(output3.resMessage);
        error.transaction = signedTransaction;
        error.output = output3;
        throw error;
      }
      if (!utils_default2.hasProperty(output3, "contractResult")) {
        const error = new Error("Failed to execute: " + JSON.stringify(output3, null, 2));
        error.error = "Failed to execute: " + JSON.stringify(output3, null, 2);
        error.transaction = signedTransaction;
        error.output = output3;
        throw error;
      }
      if (options.rawResponse) {
        return output3;
      }
      let decoded = decodeOutput(this.abi, "0x" + output3.contractResult[0]);
      if (decoded.length === 1 && Object.keys(decoded).length === 1) {
        decoded = decoded[0];
      }
      if (options.keepTxID) {
        return [signedTransaction.txID, decoded];
      }
      return decoded;
    };
    return checkResult(0);
  }
};

// node_modules/tronweb/lib/esm/lib/contract/index.js
var Contract2 = class {
  constructor(tronWeb, abi = [], address) {
    __publicField(this, "tronWeb");
    __publicField(this, "abi");
    __publicField(this, "address");
    __publicField(this, "eventListener");
    __publicField(this, "bytecode");
    __publicField(this, "deployed");
    __publicField(this, "lastBlock");
    __publicField(this, "methods");
    __publicField(this, "methodInstances");
    __publicField(this, "props");
    if (!tronWeb || !(tronWeb instanceof TronWeb))
      throw new Error("Expected instance of TronWeb");
    this.tronWeb = tronWeb;
    this.address = address;
    this.abi = abi;
    this.eventListener = false;
    this.bytecode = false;
    this.deployed = false;
    this.lastBlock = false;
    this.methods = {};
    this.methodInstances = {};
    this.props = [];
    if (utils_default2.address.isAddress(address)) {
      this.deployed = true;
    } else {
      this.address = false;
    }
    this.loadAbi(abi);
  }
  hasProperty(property) {
    return this.hasOwnProperty(property) || this.__proto__.hasOwnProperty(property);
  }
  loadAbi(abi) {
    this.abi = abi;
    this.methods = {};
    this.props.forEach((prop) => delete this[prop]);
    abi.forEach((func) => {
      if (!func.type || /constructor|error/i.test(func.type))
        return;
      const method = new Method(this, func);
      const methodCall = method.onMethod.bind(method);
      const { name, functionSelector, signature } = method;
      this.methods[name] = methodCall;
      this.methods[functionSelector] = methodCall;
      this.methods[signature] = methodCall;
      this.methodInstances[name] = method;
      this.methodInstances[functionSelector] = method;
      this.methodInstances[signature] = method;
      if (!this.hasProperty(name)) {
        this[name] = methodCall;
        this.props.push(name);
      }
      if (!this.hasProperty(functionSelector)) {
        this[functionSelector] = methodCall;
        this.props.push(functionSelector);
      }
      if (!this.hasProperty(signature)) {
        this[signature] = methodCall;
        this.props.push(signature);
      }
    });
  }
  decodeInput(data) {
    const methodName = data.substring(0, 8);
    const inputData = data.substring(8);
    if (!this.methodInstances[methodName])
      throw new Error("Contract method " + methodName + " not found");
    const methodInstance = this.methodInstances[methodName];
    return {
      name: methodInstance.name,
      params: this.methodInstances[methodName].decodeInput(inputData)
    };
  }
  async new(options, privateKey = this.tronWeb.defaultPrivateKey) {
    const address = this.tronWeb.address.fromPrivateKey(privateKey);
    const transaction = await this.tronWeb.transactionBuilder.createSmartContract(options, address);
    const signedTransaction = await this.tronWeb.trx.sign(transaction, privateKey);
    const contract = await this.tronWeb.trx.sendRawTransaction(signedTransaction);
    if (contract.code) {
      throw {
        error: contract.code,
        message: this.tronWeb.toUtf8(contract.message)
      };
    }
    await utils_default2.sleep(3e3);
    return this.at(signedTransaction.contract_address);
  }
  async at(contractAddress) {
    try {
      const contract = await this.tronWeb.trx.getContract(contractAddress);
      if (!contract.contract_address) {
        throw new Error("Unknown error: " + JSON.stringify(contract, null, 2));
      }
      this.address = contract.contract_address;
      this.bytecode = contract.bytecode;
      this.deployed = true;
      this.loadAbi(contract.abi ? contract.abi.entrys ? contract.abi.entrys : [] : []);
      return this;
    } catch (ex) {
      if (ex.toString().includes("does not exist")) {
        throw new Error("Contract has not been deployed on the network");
      }
      throw new Error(ex);
    }
  }
};

// node_modules/tronweb/lib/esm/lib/plugin.js
var import_semver = __toESM(require_semver2(), 1);
var Plugin = class {
  constructor(tronWeb, options = {}) {
    __publicField(this, "tronWeb");
    __publicField(this, "pluginNoOverride");
    __publicField(this, "disablePlugins");
    if (!tronWeb || !(tronWeb instanceof TronWeb))
      throw new Error("Expected instance of TronWeb");
    this.tronWeb = tronWeb;
    this.pluginNoOverride = ["register"];
    this.disablePlugins = !!options.disablePlugins;
  }
  register(Plugin2, options) {
    let pluginInterface = {
      requires: "0.0.0",
      components: {}
    };
    const result = {
      libs: [],
      plugged: [],
      skipped: [],
      error: void 0
    };
    if (this.disablePlugins) {
      result.error = "This instance of TronWeb has plugins disabled.";
      return result;
    }
    const plugin = new Plugin2(this.tronWeb);
    if (utils_default2.isFunction(plugin.pluginInterface)) {
      pluginInterface = plugin.pluginInterface(options);
    }
    if (import_semver.default.satisfies(TronWeb.version, pluginInterface.requires)) {
      if (pluginInterface.fullClass) {
        const className = plugin.constructor.name;
        const classInstanceName = className.substring(0, 1).toLowerCase() + className.substring(1);
        if (className !== classInstanceName) {
          Object.assign(TronWeb, {
            [className]: Plugin2
          });
          Object.assign(this.tronWeb, {
            [classInstanceName]: plugin
          });
          result.libs.push(className);
        }
      } else {
        for (const component in pluginInterface.components) {
          if (!this.tronWeb.hasOwnProperty(component)) {
            continue;
          }
          const methods = pluginInterface.components[component];
          const pluginNoOverride = this.tronWeb[component].pluginNoOverride || [];
          for (const method in methods) {
            if (method === "constructor" || this.tronWeb[component][method] && (pluginNoOverride.includes(method) || // blacklisted methods
            /^_/.test(method))) {
              result.skipped.push(method);
              continue;
            }
            this.tronWeb[component][method] = methods[method].bind(this.tronWeb[component]);
            result.plugged.push(method);
          }
        }
      }
    } else {
      throw new Error("The plugin is not compatible with this version of TronWeb");
    }
    return result;
  }
};

// node_modules/tronweb/lib/esm/lib/event.js
var Event = class {
  constructor(tronWeb) {
    __publicField(this, "tronWeb");
    if (!tronWeb || !(tronWeb instanceof TronWeb))
      throw new Error("Expected instance of TronWeb");
    this.tronWeb = tronWeb;
  }
  setServer(eventServer, healthcheck = "healthcheck") {
    if (!eventServer)
      return this.tronWeb.eventServer = void 0;
    if (utils_default2.isString(eventServer))
      eventServer = new HttpProvider(eventServer);
    if (!this.tronWeb.isValidProvider(eventServer))
      throw new Error("Invalid event server provided");
    this.tronWeb.eventServer = eventServer;
    this.tronWeb.eventServer.isConnected = () => this.tronWeb.eventServer.request(healthcheck).then(() => true).catch(() => false);
  }
  async getEventsByContractAddress(contractAddress, options = {}) {
    const newOptions = Object.assign({
      limit: 20
    }, options);
    const { eventName, blockNumber, onlyUnconfirmed, onlyConfirmed, minBlockTimestamp, maxBlockTimestamp, orderBy, fingerprint } = newOptions;
    let { limit } = newOptions;
    if (!this.tronWeb.eventServer) {
      throw new Error("No event server configured");
    }
    if (!this.tronWeb.isAddress(contractAddress)) {
      throw new Error("Invalid contract address provided");
    }
    if (typeof minBlockTimestamp !== "undefined" && !utils_default2.isInteger(minBlockTimestamp)) {
      throw new Error("Invalid minBlockTimestamp provided");
    }
    if (typeof maxBlockTimestamp !== "undefined" && !utils_default2.isInteger(maxBlockTimestamp)) {
      throw new Error("Invalid maxBlockTimestamp provided");
    }
    if (utils_default2.isInteger(limit) && limit > 200) {
      console.warn("Defaulting to maximum accepted limit: 200");
      limit = 200;
    }
    const qs = {};
    if (eventName)
      qs.event_name = eventName;
    if (blockNumber)
      qs.block_number = blockNumber;
    if (typeof onlyUnconfirmed === "boolean")
      qs.only_unconfirmed = onlyUnconfirmed;
    if (typeof onlyConfirmed === "boolean")
      qs.only_confirmed = onlyConfirmed;
    if (minBlockTimestamp)
      qs.min_block_timestamp = minBlockTimestamp;
    if (maxBlockTimestamp)
      qs.max_block_timestamp = maxBlockTimestamp;
    if (orderBy)
      qs.order_by = orderBy;
    if (fingerprint)
      qs.fingerprint = fingerprint;
    if (utils_default2.isInteger(limit))
      qs.limit = limit;
    const res = await this.tronWeb.eventServer.request(`v1/contracts/${this.tronWeb.address.fromHex(contractAddress)}/events?${new URLSearchParams(qs).toString()}`);
    if (res.success) {
      return res;
    }
    throw new Error(res.error);
  }
  async getEventsByTransactionID(transactionID, options = {}) {
    if (!this.tronWeb.eventServer) {
      throw new Error("No event server configured");
    }
    const qs = {};
    if (typeof options.only_unconfirmed === "boolean") {
      qs.only_unconfirmed = options.only_unconfirmed;
    }
    if (typeof options.only_confirmed === "boolean") {
      qs.only_confirmed = options.only_confirmed;
    }
    return this.tronWeb.eventServer.request(`v1/transactions/${transactionID}/events?${new URLSearchParams(qs).toString()}`).then((res) => {
      if (res.success) {
        return res;
      }
      throw new Error(JSON.parse(res.error).message);
    });
  }
  async getEventsByBlockNumber(blockNumber, options = {}) {
    if (!this.tronWeb.eventServer) {
      throw new Error("No event server configured");
    }
    const qs = {};
    if (typeof options.only_confirmed === "boolean") {
      qs.only_confirmed = options.only_confirmed;
    }
    if (options.limit) {
      qs.limit = options.limit;
    }
    if (options.fingerprint) {
      qs.fingerprint = options.fingerprint;
    }
    return this.tronWeb.eventServer.request(`v1/blocks/${blockNumber}/events?${new URLSearchParams(qs).toString()}`).then((res) => {
      if (res.success) {
        return res;
      }
      throw new Error(res.error);
    });
  }
  async getEventsOfLatestBlock(options = {}) {
    if (!this.tronWeb.eventServer) {
      throw new Error("No event server configured");
    }
    const qs = {};
    if (typeof options.only_confirmed === "boolean") {
      qs.only_confirmed = options.only_confirmed;
    }
    return this.tronWeb.eventServer.request(`v1/blocks/latest/events?${new URLSearchParams(qs).toString()}`).then((res) => {
      if (res.success) {
        return res;
      }
      throw new Error(res.error);
    });
  }
};

// node_modules/tronweb/lib/esm/tronweb.js
var DEFAULT_VERSION = "4.7.1";
var FEE_LIMIT = 15e7;
var version2 = "6.0.3";
function isValidOptions(options) {
  return !!options && typeof options === "object" && (!!options.fullNode || !!options.fullHost);
}
var _TronWeb = class _TronWeb extends eventemitter3_default {
  constructor(options, solidityNode = "", eventServer, privateKey = "") {
    super();
    __publicField(this, "providers");
    __publicField(this, "BigNumber");
    __publicField(this, "transactionBuilder");
    __publicField(this, "trx");
    __publicField(this, "plugin");
    __publicField(this, "event");
    __publicField(this, "version");
    __publicField(this, "utils");
    __publicField(this, "defaultBlock");
    __publicField(this, "defaultPrivateKey");
    __publicField(this, "defaultAddress");
    __publicField(this, "fullnodeVersion");
    __publicField(this, "feeLimit");
    __publicField(this, "fullNode");
    __publicField(this, "solidityNode");
    __publicField(this, "eventServer");
    __publicField(this, "address");
    __publicField(this, "sha3");
    __publicField(this, "toHex");
    __publicField(this, "toUtf8");
    __publicField(this, "fromUtf8");
    __publicField(this, "toAscii");
    __publicField(this, "fromAscii");
    __publicField(this, "toDecimal");
    __publicField(this, "fromDecimal");
    __publicField(this, "fromSun");
    __publicField(this, "toSun");
    __publicField(this, "toBigNumber");
    __publicField(this, "isAddress");
    __publicField(this, "createAccount");
    __publicField(this, "createRandom");
    __publicField(this, "fromMnemonic");
    let fullNode;
    let headers = false;
    let eventHeaders = false;
    if (isValidOptions(options)) {
      fullNode = options.fullNode || options.fullHost;
      solidityNode = options.solidityNode || options.fullHost;
      eventServer = options.eventServer || options.fullHost;
      headers = options.headers || false;
      eventHeaders = options.eventHeaders || headers;
      privateKey = options.privateKey;
    } else {
      fullNode = options;
    }
    if (utils_default2.isString(fullNode))
      fullNode = new providers.HttpProvider(fullNode);
    if (utils_default2.isString(solidityNode))
      solidityNode = new providers.HttpProvider(solidityNode);
    if (utils_default2.isString(eventServer))
      eventServer = new providers.HttpProvider(eventServer);
    this.event = new Event(this);
    this.transactionBuilder = new TransactionBuilder(this);
    this.trx = new Trx(this);
    this.plugin = new Plugin(this, {
      disablePlugins: isValidOptions(options) ? options.disablePlugins : false
    });
    this.utils = utils_default2;
    this.setFullNode(fullNode);
    this.setSolidityNode(solidityNode);
    this.setEventServer(eventServer);
    this.providers = providers;
    this.BigNumber = BigNumber;
    this.defaultBlock = false;
    this.defaultPrivateKey = false;
    this.defaultAddress = {
      hex: false,
      base58: false
    };
    this.version = _TronWeb.version;
    this.sha3 = _TronWeb.sha3;
    this.fromUtf8 = _TronWeb.fromUtf8;
    this.address = _TronWeb.address;
    this.toAscii = _TronWeb.toAscii;
    this.toUtf8 = _TronWeb.toUtf8;
    this.isAddress = _TronWeb.isAddress;
    this.fromAscii = _TronWeb.fromAscii;
    this.toHex = _TronWeb.toHex;
    this.toBigNumber = _TronWeb.toBigNumber;
    this.toDecimal = _TronWeb.toDecimal;
    this.fromDecimal = _TronWeb.fromDecimal;
    this.toSun = _TronWeb.toSun;
    this.fromSun = _TronWeb.fromSun;
    this.createAccount = _TronWeb.createAccount;
    this.createRandom = _TronWeb.createRandom;
    this.fromMnemonic = _TronWeb.fromMnemonic;
    if (privateKey)
      this.setPrivateKey(privateKey);
    this.fullnodeVersion = DEFAULT_VERSION;
    this.feeLimit = FEE_LIMIT;
    if (headers) {
      this.setFullNodeHeader(headers);
    }
    if (eventHeaders) {
      this.setEventHeader(eventHeaders);
    }
  }
  async getFullnodeVersion() {
    try {
      const nodeInfo = await this.trx.getNodeInfo();
      this.fullnodeVersion = nodeInfo.configNodeInfo.codeVersion;
      if (this.fullnodeVersion.split(".").length === 2) {
        this.fullnodeVersion += ".0";
      }
    } catch (err) {
      this.fullnodeVersion = DEFAULT_VERSION;
    }
  }
  setDefaultBlock(blockID = false) {
    if ([false, "latest", "earliest", 0].includes(blockID)) {
      return this.defaultBlock = blockID;
    }
    if (!utils_default2.isInteger(blockID) || !blockID)
      throw new Error("Invalid block ID provided");
    return this.defaultBlock = Math.abs(blockID);
  }
  setPrivateKey(privateKey) {
    try {
      this.setAddress(_TronWeb.address.fromPrivateKey(privateKey));
    } catch {
      throw new Error("Invalid private key provided");
    }
    this.defaultPrivateKey = privateKey;
    this.emit("privateKeyChanged", privateKey);
  }
  setAddress(address) {
    if (!_TronWeb.isAddress(address))
      throw new Error("Invalid address provided");
    const hex = _TronWeb.address.toHex(address);
    const base58 = _TronWeb.address.fromHex(address);
    if (this.defaultPrivateKey && _TronWeb.address.fromPrivateKey(this.defaultPrivateKey) !== base58)
      this.defaultPrivateKey = false;
    this.defaultAddress = {
      hex,
      base58
    };
    this.emit("addressChanged", { hex, base58 });
  }
  fullnodeSatisfies(version3) {
    return import_semver2.default.satisfies(this.fullnodeVersion, version3);
  }
  isValidProvider(provider) {
    return Object.values(providers).some((knownProvider) => provider instanceof knownProvider);
  }
  setFullNode(fullNode) {
    if (isString(fullNode))
      fullNode = new providers.HttpProvider(fullNode);
    if (!this.isValidProvider(fullNode))
      throw new Error("Invalid full node provided");
    this.fullNode = fullNode;
    this.fullNode.setStatusPage("wallet/getnowblock");
  }
  setSolidityNode(solidityNode) {
    if (utils_default2.isString(solidityNode))
      solidityNode = new providers.HttpProvider(solidityNode);
    if (!this.isValidProvider(solidityNode))
      throw new Error("Invalid solidity node provided");
    this.solidityNode = solidityNode;
    this.solidityNode.setStatusPage("walletsolidity/getnowblock");
  }
  setEventServer(eventServer, healthcheck) {
    this.event.setServer(eventServer, healthcheck);
  }
  setHeader(headers = {}) {
    const fullNode = new providers.HttpProvider(this.fullNode.host, 3e4, "", "", headers);
    const solidityNode = new providers.HttpProvider(this.solidityNode.host, 3e4, "", "", headers);
    const eventServer = new providers.HttpProvider(this.eventServer.host, 3e4, "", "", headers);
    this.setFullNode(fullNode);
    this.setSolidityNode(solidityNode);
    this.setEventServer(eventServer);
  }
  setFullNodeHeader(headers = {}) {
    const fullNode = new providers.HttpProvider(this.fullNode.host, 3e4, "", "", headers);
    const solidityNode = new providers.HttpProvider(this.solidityNode.host, 3e4, "", "", headers);
    this.setFullNode(fullNode);
    this.setSolidityNode(solidityNode);
  }
  setEventHeader(headers = {}) {
    const eventServer = new providers.HttpProvider(this.eventServer.host, 3e4, "", "", headers);
    this.setEventServer(eventServer);
  }
  currentProviders() {
    return {
      fullNode: this.fullNode,
      solidityNode: this.solidityNode,
      eventServer: this.eventServer
    };
  }
  currentProvider() {
    return this.currentProviders();
  }
  getEventResult(...params) {
    return this.event.getEventsByContractAddress(...params);
  }
  getEventByTransactionID(...params) {
    return this.event.getEventsByTransactionID(...params);
  }
  contract(abi = [], address) {
    return new Contract2(this, abi, address);
  }
  static get address() {
    return {
      fromHex(address) {
        return fromHex(address);
      },
      toHex(address) {
        return toHex(address);
      },
      toChecksumAddress(address) {
        return toChecksumAddress(address);
      },
      isChecksumAddress(address) {
        return isChecksumAddress(address);
      },
      fromPrivateKey(privateKey, strict = false) {
        return fromPrivateKey(privateKey, strict);
      }
    };
  }
  static sha3(string, prefix = true) {
    return (prefix ? "0x" : "") + keccak256(Buffer.from(string, "utf-8")).toString().substring(2);
  }
  static toHex(val) {
    if (utils_default2.isBoolean(val))
      return _TronWeb.fromDecimal(+val);
    if (utils_default2.isBigNumber(val))
      return _TronWeb.fromDecimal(val);
    if (typeof val === "object")
      return _TronWeb.fromUtf8(JSON.stringify(val));
    if (utils_default2.isString(val)) {
      if (/^(-|)0x/.test(val))
        return val;
      if (!isFinite(val) || /^\s*$/.test(val))
        return _TronWeb.fromUtf8(val);
    }
    const result = _TronWeb.fromDecimal(val);
    if (result === "0xNaN") {
      throw new Error("The passed value is not convertible to a hex string");
    } else {
      return result;
    }
  }
  static toUtf8(hex) {
    if (utils_default2.isHex(hex)) {
      hex = hex.replace(/^0x/, "");
      return Buffer.from(hex, "hex").toString("utf8");
    } else {
      throw new Error("The passed value is not a valid hex string");
    }
  }
  static fromUtf8(string) {
    if (!utils_default2.isString(string)) {
      throw new Error("The passed value is not a valid utf-8 string");
    }
    return "0x" + Buffer.from(string, "utf8").toString("hex");
  }
  static toAscii(hex) {
    if (utils_default2.isHex(hex)) {
      let str = "";
      let i = 0;
      const l = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l; i += 2) {
        const code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    } else {
      throw new Error("The passed value is not a valid hex string");
    }
  }
  static fromAscii(string, padding3) {
    if (!utils_default2.isString(string)) {
      throw new Error("The passed value is not a valid utf-8 string");
    }
    return "0x" + Buffer.from(string, "ascii").toString("hex").padEnd(padding3, "0");
  }
  static toDecimal(value) {
    return _TronWeb.toBigNumber(value).toNumber();
  }
  static fromDecimal(value) {
    const number3 = _TronWeb.toBigNumber(value);
    const result = number3.toString(16);
    return number3.isLessThan(0) ? "-0x" + result.substr(1) : "0x" + result;
  }
  static fromSun(sun) {
    const trx = _TronWeb.toBigNumber(sun).div(1e6);
    return utils_default2.isBigNumber(sun) ? trx : trx.toString(10);
  }
  static toSun(trx) {
    const sun = _TronWeb.toBigNumber(trx).times(1e6);
    return utils_default2.isBigNumber(trx) ? sun : sun.toString(10);
  }
  static toBigNumber(amount = 0) {
    if (utils_default2.isBigNumber(amount))
      return amount;
    if (utils_default2.isString(amount) && /^(-|)0x/.test(amount))
      return new BigNumber(amount.replace("0x", ""), 16);
    return new BigNumber(amount.toString(10), 10);
  }
  static isAddress(address = "") {
    return isAddress2(address);
  }
  static async createAccount() {
    const account = utils_default2.accounts.generateAccount();
    return account;
  }
  static createRandom(...params) {
    const account = utils_default2.accounts.generateRandom(...params);
    return account;
  }
  static fromMnemonic(...params) {
    const account = utils_default2.accounts.generateAccountWithMnemonic(...params);
    return account;
  }
  async isConnected() {
    return {
      fullNode: await this.fullNode.isConnected(),
      solidityNode: await this.solidityNode.isConnected(),
      eventServer: this.eventServer && await this.eventServer.isConnected()
    };
  }
};
__publicField(_TronWeb, "version", version2);
var TronWeb = _TronWeb;
var tronweb_default = TronWeb;

// node_modules/tronweb/lib/esm/utils/typedData.js
function getAddress2(address) {
  return TronWeb.address.toHex(address).replace(ADDRESS_PREFIX_REGEX, "0x");
}
function getTronAddress(address) {
  return TronWeb.address.toHex(address);
}
var padding2 = new Uint8Array(32);
padding2.fill(0);
var BN__12 = BigInt(-1);
var BN_012 = BigInt(0);
var BN_17 = BigInt(1);
var BN_MAX_UINT2563 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight2(value) {
  const bytes3 = getBytes(value);
  const padOffset = bytes3.length % 32;
  if (padOffset) {
    return concat([bytes3, padding2.slice(padOffset)]);
  }
  return hexlify(bytes3);
}
var hexTrue2 = toBeHex(BN_17, 32);
var hexFalse2 = toBeHex(BN_012, 32);
var domainFieldTypes2 = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames2 = ["name", "version", "chainId", "verifyingContract", "salt"];
function checkString2(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
var domainChecks2 = {
  name: checkString2("name"),
  version: checkString2("version"),
  chainId: function(_value2) {
    const value = getBigInt(_value2, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getTronAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes3 = getBytes(value, "domain.salt");
    assertArgument(bytes3.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes3);
  }
};
function getBaseEncoder2(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT2563, signed ? width - 1 : width);
      const boundsLower = signed ? (boundsUpper + BN_17) * BN__12 : BN_012;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes3 = getBytes(value);
        assertArgument(bytes3.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight2(value);
      };
    }
  }
  switch (type) {
    case "trcToken":
      return getBaseEncoder2("uint256");
    case "address":
      return function(value) {
        return zeroPadValue(getAddress2(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse2 : hexTrue2;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType2(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
var _types2, _fullTypes2, _encoderCache2, _TypedDataEncoder_instances2, getEncoder_fn2;
var _TypedDataEncoder2 = class _TypedDataEncoder2 {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(types) {
    __privateAdd(this, _TypedDataEncoder_instances2);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    __publicField(this, "primaryType");
    __privateAdd(this, _types2);
    __privateAdd(this, _fullTypes2);
    __privateAdd(this, _encoderCache2);
    __privateSet(this, _types2, JSON.stringify(types));
    __privateSet(this, _fullTypes2, /* @__PURE__ */ new Map());
    __privateSet(this, _encoderCache2, /* @__PURE__ */ new Map());
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    Object.keys(types).forEach((type) => {
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    for (const name in types) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
        uniqueNames.add(field.name);
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        const encoder = getBaseEncoder2(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", types);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", types);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", types);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", types);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      __privateGet(this, _fullTypes2).set(name, encodeType2(name, types[name]) + st.map((t) => encodeType2(t, types[t])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(__privateGet(this, _types2));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = __privateGet(this, _encoderCache2).get(type);
    if (!encoder) {
      encoder = __privateMethod(this, _TypedDataEncoder_instances2, getEncoder_fn2).call(this, type);
      __privateGet(this, _encoderCache2).set(type, encoder);
    }
    return encoder;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name) {
    const result = __privateGet(this, _fullTypes2).get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder2(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, "value", value);
      return value.map((v) => this._visit(match[1], v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types) {
    return new _TypedDataEncoder2(types);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types) {
    return _TypedDataEncoder2.from(types).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name, types, value) {
    return _TypedDataEncoder2.from(types).hashStruct(name, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes2[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a, b2) => {
      return domainFieldNames2.indexOf(a.name) - domainFieldNames2.indexOf(b2.name);
    });
    return _TypedDataEncoder2.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain, types, value) {
    return concat(["0x1901", _TypedDataEncoder2.hashDomain(domain), _TypedDataEncoder2.from(types).hash(value)]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain, types, value) {
    return keccak256(_TypedDataEncoder2.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain, types, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = _TypedDataEncoder2.from(types);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain, types, value) {
    _TypedDataEncoder2.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames2.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks2[name](value2);
      domainTypes.push({ name, type: domainFieldTypes2[name] });
    });
    const encoder = _TypedDataEncoder2.from(types);
    const typesWithDomain = Object.assign({}, types);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "trcToken":
            return getBigInt(value2).toString();
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
};
_types2 = new WeakMap();
_fullTypes2 = new WeakMap();
_encoderCache2 = new WeakMap();
_TypedDataEncoder_instances2 = new WeakSet();
getEncoder_fn2 = function(type) {
  {
    const encoder = getBaseEncoder2(type);
    if (encoder) {
      return encoder;
    }
  }
  const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
  if (match) {
    const subtype = match[1];
    const subEncoder = this.getEncoder(subtype);
    return (value) => {
      assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, "value", value);
      let result = value.map(subEncoder);
      if (__privateGet(this, _fullTypes2).has(subtype)) {
        result = result.map(keccak256);
      }
      return keccak256(concat(result));
    };
  }
  const fields = this.types[type];
  if (fields) {
    const encodedType = id(__privateGet(this, _fullTypes2).get(type));
    return (value) => {
      const values = fields.map(({ name, type: type2 }) => {
        const result = this.getEncoder(type2)(value[name]);
        if (__privateGet(this, _fullTypes2).has(type2)) {
          return keccak256(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return concat(values);
    };
  }
  assertArgument(false, `unknown type: ${type}`, "type", type);
};
var TypedDataEncoder2 = _TypedDataEncoder2;

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_assert.js
function number2(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`positive integer expected, not ${n2}`);
}
function isBytes2(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes2(b2, ...lengths) {
  if (!isBytes2(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b2.length}`);
}
function hash2(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number2(h.outputLen);
  number2(h.blockLen);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/crypto.js
var crypto4 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/utils.js
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var hexes3 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes3(data);
  bytes2(data);
  return data;
}
function concatBytes3(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    bytes2(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr2 = {}.toString;
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes4(bytesLength = 32) {
  if (crypto4 && typeof crypto4.getRandomValues === "function") {
    return crypto4.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_md.js
function setBigUint642(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
var Chi2 = (a, b2, c) => a & b2 ^ ~a & c;
var Maj2 = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
var HashMD = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    exists2(this);
    const { view, buffer, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists2(this);
    output2(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = new Uint32Array(64);
var SHA2562 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W2[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W2[i - 15];
      const W2 = SHA256_W2[i - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T13 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T22 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T13 | 0;
      D = C;
      C = B;
      B = A;
      A = T13 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA2242 = class extends SHA2562 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2563 = wrapConstructor2(() => new SHA2562());
var sha2242 = wrapConstructor2(() => new SHA2242());

// node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/hmac.js
var HMAC2 = class extends Hash2 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash2(hash3);
    const key = toBytes2(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists2(this);
    bytes2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
hmac2.create = (hash3, key) => new HMAC2(hash3, key);

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports3 = {};
__export(utils_exports3, {
  abytes: () => abytes,
  bitGet: () => bitGet2,
  bitLen: () => bitLen2,
  bitMask: () => bitMask2,
  bitSet: () => bitSet2,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE2,
  bytesToNumberLE: () => bytesToNumberLE2,
  concatBytes: () => concatBytes4,
  createHmacDrbg: () => createHmacDrbg2,
  ensureBytes: () => ensureBytes2,
  equalBytes: () => equalBytes2,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber2,
  isBytes: () => isBytes3,
  numberToBytesBE: () => numberToBytesBE2,
  numberToBytesLE: () => numberToBytesLE2,
  numberToHexUnpadded: () => numberToHexUnpadded2,
  numberToVarBytesBE: () => numberToVarBytesBE2,
  utf8ToBytes: () => utf8ToBytes4,
  validateObject: () => validateObject2
});
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n6 = BigInt(2);
function isBytes3(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes3(item))
    throw new Error("Uint8Array expected");
}
var hexes4 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex2(bytes3) {
  abytes(bytes3);
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes4[bytes3[i]];
  }
  return hex;
}
function numberToHexUnpadded2(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE2(bytes3) {
  return hexToNumber2(bytesToHex2(bytes3));
}
function bytesToNumberLE2(bytes3) {
  abytes(bytes3);
  return hexToNumber2(bytesToHex2(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE2(n2, len) {
  return hexToBytes2(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE2(n2, len) {
  return numberToBytesBE2(n2, len).reverse();
}
function numberToVarBytesBE2(n2) {
  return hexToBytes2(numberToHexUnpadded2(n2));
}
function ensureBytes2(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes3(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes4(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function equalBytes2(a, b2) {
  if (a.length !== b2.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b2[i];
  return diff === 0;
}
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen2(n2) {
  let len;
  for (len = 0; n2 > _0n7; n2 >>= _1n7, len += 1)
    ;
  return len;
}
function bitGet2(n2, pos) {
  return n2 >> BigInt(pos) & _1n7;
}
function bitSet2(n2, pos, value) {
  return n2 | (value ? _1n7 : _0n7) << BigInt(pos);
}
var bitMask2 = (n2) => (_2n6 << BigInt(n2 - 1)) - _1n7;
var u8n2 = (data) => new Uint8Array(data);
var u8fr2 = (arr) => Uint8Array.from(arr);
function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n2(hashLen);
  let k = u8n2(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b2) => hmacFn(k, v, ...b2);
  const reseed = (seed = u8n2()) => {
    k = h(u8fr2([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr2([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes4(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns2 = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes3(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject2(object2, validators3, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns2[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators3))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/modular.js
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
var _2n7 = BigInt(2);
var _3n3 = BigInt(3);
var _4n3 = BigInt(4);
var _5n2 = BigInt(5);
var _8n2 = BigInt(8);
var _9n2 = BigInt(9);
var _16n2 = BigInt(16);
function mod2(a, b2) {
  const result = a % b2;
  return result >= _0n8 ? result : b2 + result;
}
function pow3(num, power, modulo) {
  if (modulo <= _0n8 || power < _0n8)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n8)
    return _0n8;
  let res = _1n8;
  while (power > _0n8) {
    if (power & _1n8)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n8;
  }
  return res;
}
function pow22(x, power, modulo) {
  let res = x;
  while (power-- > _0n8) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert2(number3, modulo) {
  if (number3 === _0n8 || modulo <= _0n8) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod2(number3, modulo);
  let b2 = modulo;
  let x = _0n8, y = _1n8, u = _1n8, v = _0n8;
  while (a !== _0n8) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x - u * q;
    const n2 = y - v * q;
    b2 = a, a = r, x = u, y = v, u = m, v = n2;
  }
  const gcd = b2;
  if (gcd !== _1n8)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function tonelliShanks2(P) {
  const legendreC = (P - _1n8) / _2n7;
  let Q, S2, Z;
  for (Q = P - _1n8, S2 = 0; Q % _2n7 === _0n8; Q /= _2n7, S2++)
    ;
  for (Z = _2n7; Z < P && pow3(Z, legendreC, P) !== P - _1n8; Z++)
    ;
  if (S2 === 1) {
    const p1div4 = (P + _1n8) / _4n3;
    return function tonelliFast(Fp3, n2) {
      const root = Fp3.pow(n2, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n8) / _2n7;
  return function tonelliSlow(Fp3, n2) {
    if (Fp3.pow(n2, legendreC) === Fp3.neg(Fp3.ONE))
      throw new Error("Cannot find square root");
    let r = S2;
    let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
    let x = Fp3.pow(n2, Q1div2);
    let b2 = Fp3.pow(n2, Q);
    while (!Fp3.eql(b2, Fp3.ONE)) {
      if (Fp3.eql(b2, Fp3.ZERO))
        return Fp3.ZERO;
      let m = 1;
      for (let t2 = Fp3.sqr(b2); m < r; m++) {
        if (Fp3.eql(t2, Fp3.ONE))
          break;
        t2 = Fp3.sqr(t2);
      }
      const ge3 = Fp3.pow(g, _1n8 << BigInt(r - m - 1));
      g = Fp3.sqr(ge3);
      x = Fp3.mul(x, ge3);
      b2 = Fp3.mul(b2, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt2(P) {
  if (P % _4n3 === _3n3) {
    const p1div4 = (P + _1n8) / _4n3;
    return function sqrt3mod4(Fp3, n2) {
      const root = Fp3.pow(n2, p1div4);
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n2 === _5n2) {
    const c1 = (P - _5n2) / _8n2;
    return function sqrt5mod8(Fp3, n2) {
      const n22 = Fp3.mul(n2, _2n7);
      const v = Fp3.pow(n22, c1);
      const nv = Fp3.mul(n2, v);
      const i = Fp3.mul(Fp3.mul(nv, _2n7), v);
      const root = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
      if (!Fp3.eql(Fp3.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n2 === _9n2) {
  }
  return tonelliShanks2(P);
}
var FIELD_FIELDS2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS2.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject2(field, opts);
}
function FpPow2(f2, num, power) {
  if (power < _0n8)
    throw new Error("Expected power > 0");
  if (power === _0n8)
    return f2.ONE;
  if (power === _1n8)
    return num;
  let p = f2.ONE;
  let d = num;
  while (power > _0n8) {
    if (power & _1n8)
      p = f2.mul(p, d);
    d = f2.sqr(d);
    power >>= _1n8;
  }
  return p;
}
function FpInvertBatch2(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength2(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field2(ORDER, bitLen3, isLE3 = false, redef = {}) {
  if (ORDER <= _0n8)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, bitLen3);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt2(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n8,
    ONE: _1n8,
    create: (num) => mod2(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n8 <= num && num < ORDER;
    },
    is0: (num) => num === _0n8,
    isOdd: (num) => (num & _1n8) === _1n8,
    neg: (num) => mod2(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod2(num * num, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num, power) => FpPow2(f2, num, power),
    div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert2(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch2(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b2, c) => c ? b2 : a,
    toBytes: (num) => isLE3 ? numberToBytesLE2(num, BYTES) : numberToBytesBE2(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE3 ? bytesToNumberLE2(bytes3) : bytesToNumberBE2(bytes3);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength2(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength2(fieldOrder) {
  const length = getFieldBytesLength2(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField2(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength2(fieldOrder);
  const minLen = getMinHashLength2(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE3 ? bytesToNumberBE2(key) : bytesToNumberLE2(key);
  const reduced = mod2(num, fieldOrder - _1n8) + _1n8;
  return isLE3 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/curve.js
var _0n9 = BigInt(0);
var _1n9 = BigInt(1);
function wNAF2(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p = c.ZERO;
      let d = elm;
      while (n2 > _0n9) {
        if (n2 & _1n9)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n9;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n2) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n9;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P, precomputesMap, n2, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n2);
    }
  };
}
function validateBasic2(curve) {
  validateField2(curve.Fp);
  validateObject2(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength2(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts2(curve) {
  const opts = validateBasic2(curve);
  validateObject2(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp3, a } = opts;
  if (endo) {
    if (!Fp3.eql(a, Fp3.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n2, hexToBytes: h2b2 } = utils_exports3;
var DER2 = {
  // asn.1 DER encoding utils
  Err: class DERErr2 extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER2;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n2(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER2;
    const data = typeof hex === "string" ? h2b2(hex) : hex;
    abytes(data);
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER2._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER2._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n10 = BigInt(0);
var _1n10 = BigInt(1);
var _2n8 = BigInt(2);
var _3n4 = BigInt(3);
var _4n4 = BigInt(4);
function weierstrassPoints2(opts) {
  const CURVE = validatePointOpts2(opts);
  const { Fp: Fp3 } = CURVE;
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes4(Uint8Array.from([4]), Fp3.toBytes(a.x), Fp3.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
    const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b: b2 } = CURVE;
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b2);
  }
  if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n10 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes3(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE2(ensureBytes2("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod2(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp3.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp3.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp3.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp3.eql(i, Fp3.ZERO);
      if (is0(x) && is0(y))
        return Point3.ZERO;
      return new Point3(x, y, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp3.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point3.fromAffine(fromBytes(ensureBytes2("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp3.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp3.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp3.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp3.isOdd)
        return !Fp3.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U22 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp3.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp3.mul(b2, _3n4);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point3(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
      const a = CURVE.a;
      const b3 = Fp3.mul(CURVE.b, _3n4);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point3(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp3.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I = Point3.ZERO;
      if (n2 === _0n10)
        return I;
      assertGE(n2);
      if (n2 === _1n10)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n10 || k2 > _0n10) {
        if (k1 & _1n10)
          k1p = k1p.add(d);
        if (k2 & _1n10)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n10;
        k2 >>= _1n10;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(n2);
        point = p;
        fake = f2;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b2) {
      const G = Point3.BASE;
      const mul = (P, a2) => a2 === _0n10 || a2 === _1n10 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp3.ONE : Fp3.inv(z);
      const ax = Fp3.mul(x, iz);
      const ay = Fp3.mul(y, iz);
      const zz = Fp3.mul(z, iz);
      if (is0)
        return { x: Fp3.ZERO, y: Fp3.ZERO };
      if (!Fp3.eql(zz, Fp3.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n10)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n10)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes3(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point3.ZERO = new Point3(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF2(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts2(curve) {
  const opts = validateBasic2(curve);
  validateObject2(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass2(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp3.BYTES + 1;
  const uncompressedLen = 2 * Fp3.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n10 < num && num < Fp3.ORDER;
  }
  function modN3(a) {
    return mod2(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert2(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints2({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp3.toBytes(a.x);
      const cat = concatBytes4;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp3.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE2(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp3.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n10) === _1n10;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp3.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE2(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n10;
    return number3 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN3(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE2(b2.slice(from, to));
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes2("compactSignature", hex, l * 2);
      return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER2.toSig(ensureBytes2("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes2("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp3.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN3(-h * ir);
      const u2 = modN3(s * ir);
      const Q = Point3.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN3(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER2.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength2(CURVE.n);
      return mapHashToField2(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes3(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point3.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    const num = bytesToNumberBE2(bytes3);
    const delta = bytes3.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN3(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask2(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n10 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE2(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes5 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes2("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes2("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes5(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes2("extraEntropy", e));
    }
    const seed = concatBytes4(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point3.BASE.multiply(k).toAffine();
      const r = modN3(q.x);
      if (r === _0n10)
        return;
      const s = modN3(ik * modN3(m + r * d));
      if (s === _0n10)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n10);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg2(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a3;
    const sg = signature;
    msgHash = ensureBytes2("msgHash", msgHash);
    publicKey = ensureBytes2("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig2 = void 0;
    let P;
    try {
      if (typeof sg === "string" || isBytes3(sg)) {
        try {
          _sig2 = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER2.Err))
            throw derError;
          _sig2 = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig2 = new Signature2(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point3.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig2;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN3(h * is);
    const u2 = modN3(r * is);
    const R = (_a3 = Point3.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a3.toAffine();
    if (!R)
      return false;
    const v = modN3(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point3,
    Signature: Signature2,
    utils: utils2
  };
}
function SWUFpSqrtRatio2(Fp3, Z) {
  const q = Fp3.ORDER;
  let l = _0n10;
  for (let o = q - _1n10; o % _2n8 === _0n10; o /= _2n8)
    l += _1n10;
  const c1 = l;
  const _2n_pow_c1_1 = _2n8 << c1 - _1n10 - _1n10;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n8;
  const c2 = (q - _1n10) / _2n_pow_c1;
  const c3 = (c2 - _1n10) / _2n8;
  const c4 = _2n_pow_c1 - _1n10;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp3.pow(Z, c2);
  const c7 = Fp3.pow(Z, (c2 + _1n10) / _2n8);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp3.pow(v, c4);
    let tv3 = Fp3.sqr(tv2);
    tv3 = Fp3.mul(tv3, v);
    let tv5 = Fp3.mul(u, tv3);
    tv5 = Fp3.pow(tv5, c3);
    tv5 = Fp3.mul(tv5, tv2);
    tv2 = Fp3.mul(tv5, v);
    tv3 = Fp3.mul(tv5, u);
    let tv4 = Fp3.mul(tv3, tv2);
    tv5 = Fp3.pow(tv4, c5);
    let isQR = Fp3.eql(tv5, Fp3.ONE);
    tv2 = Fp3.mul(tv3, c7);
    tv5 = Fp3.mul(tv4, tv1);
    tv3 = Fp3.cmov(tv2, tv3, isQR);
    tv4 = Fp3.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n10; i--) {
      let tv52 = i - _2n8;
      tv52 = _2n8 << tv52 - _1n10;
      let tvv5 = Fp3.pow(tv4, tv52);
      const e1 = Fp3.eql(tvv5, Fp3.ONE);
      tv2 = Fp3.mul(tv3, tv1);
      tv1 = Fp3.mul(tv1, tv1);
      tvv5 = Fp3.mul(tv4, tv1);
      tv3 = Fp3.cmov(tv2, tv3, e1);
      tv4 = Fp3.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp3.ORDER % _4n4 === _3n4) {
    const c12 = (Fp3.ORDER - _3n4) / _4n4;
    const c22 = Fp3.sqrt(Fp3.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp3.sqr(v);
      const tv2 = Fp3.mul(u, v);
      tv1 = Fp3.mul(tv1, tv2);
      let y1 = Fp3.pow(tv1, c12);
      y1 = Fp3.mul(y1, tv2);
      const y2 = Fp3.mul(y1, c22);
      const tv3 = Fp3.mul(Fp3.sqr(y1), v);
      const isQR = Fp3.eql(tv3, u);
      let y = Fp3.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU2(Fp3, opts) {
  validateField2(Fp3);
  if (!Fp3.isValid(opts.A) || !Fp3.isValid(opts.B) || !Fp3.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio2(Fp3, opts.Z);
  if (!Fp3.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp3.sqr(u);
    tv1 = Fp3.mul(tv1, opts.Z);
    tv2 = Fp3.sqr(tv1);
    tv2 = Fp3.add(tv2, tv1);
    tv3 = Fp3.add(tv2, Fp3.ONE);
    tv3 = Fp3.mul(tv3, opts.B);
    tv4 = Fp3.cmov(opts.Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
    tv4 = Fp3.mul(tv4, opts.A);
    tv2 = Fp3.sqr(tv3);
    tv6 = Fp3.sqr(tv4);
    tv5 = Fp3.mul(tv6, opts.A);
    tv2 = Fp3.add(tv2, tv5);
    tv2 = Fp3.mul(tv2, tv3);
    tv6 = Fp3.mul(tv6, tv4);
    tv5 = Fp3.mul(tv6, opts.B);
    tv2 = Fp3.add(tv2, tv5);
    x = Fp3.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp3.mul(tv1, u);
    y = Fp3.mul(y, value);
    x = Fp3.cmov(x, tv3, isValid);
    y = Fp3.cmov(y, value, isValid);
    const e1 = Fp3.isOdd(u) === Fp3.isOdd(y);
    y = Fp3.cmov(Fp3.neg(y), y, e1);
    x = Fp3.div(x, tv4);
    return { x, y };
  };
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash2(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac2(hash3, key, concatBytes3(...msgs)),
    randomBytes: randomBytes4
  };
}
function createCurve2(curveDef, defHash) {
  const create = (hash3) => weierstrass2({ ...curveDef, ...getHash2(hash3) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip2 = bytesToNumberBE2;
function i2osp2(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor2(a, b2) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b2[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd2(msg, DST, lenInBytes, H) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes4(utf8ToBytes4("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes4(DST, i2osp2(DST.length, 1));
  const Z_pad = i2osp2(0, r_in_bytes);
  const l_i_b_str = i2osp2(lenInBytes, 2);
  const b2 = new Array(ell);
  const b_0 = H(concatBytes4(Z_pad, msg, l_i_b_str, i2osp2(0, 1), DST_prime));
  b2[0] = H(concatBytes4(b_0, i2osp2(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor2(b_0, b2[i - 1]), i2osp2(i + 1, 1), DST_prime];
    b2[i] = H(concatBytes4(...args));
  }
  const pseudo_random_bytes = concatBytes4(...b2);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof2(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes4("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp2(lenInBytes, 2)).update(DST).update(i2osp2(DST.length, 1)).digest();
}
function hash_to_field2(msg, count, options) {
  validateObject2(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash3, expand, DST: _DST } = options;
  abytes(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes4(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd2(msg, DST, len_in_bytes, hash3);
  } else if (expand === "xof") {
    prb = expand_message_xof2(msg, DST, len_in_bytes, k, hash3);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod2(os2ip2(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap2(field, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher2(Point3, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u = hash_to_field2(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point3.fromAffine(mapToCurve(u[0]));
      const u1 = Point3.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u = hash_to_field2(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point3.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i of scalars)
        if (typeof i !== "bigint")
          throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);
      const P = Point3.fromAffine(mapToCurve(scalars)).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P2 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n11 = BigInt(1);
var _2n9 = BigInt(2);
var divNearest2 = (a, b2) => (a + b2 / _2n9) / b2;
function sqrtMod2(y) {
  const P = secp256k1P2;
  const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow22(b3, _3n5, P) * b3 % P;
  const b9 = pow22(b6, _3n5, P) * b3 % P;
  const b11 = pow22(b9, _2n9, P) * b2 % P;
  const b22 = pow22(b11, _11n, P) * b11 % P;
  const b44 = pow22(b22, _22n, P) * b22 % P;
  const b88 = pow22(b44, _44n, P) * b44 % P;
  const b176 = pow22(b88, _88n, P) * b88 % P;
  const b220 = pow22(b176, _44n, P) * b44 % P;
  const b223 = pow22(b220, _3n5, P) * b3 % P;
  const t1 = pow22(b223, _23n, P) * b22 % P;
  const t2 = pow22(t1, _6n, P) * b2 % P;
  const root = pow22(t2, _2n9, P);
  if (!Fp2.eql(Fp2.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp2 = Field2(secp256k1P2, void 0, void 0, { sqrt: sqrtMod2 });
var secp256k12 = createCurve2({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fp2,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N2,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1N2;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n11 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest2(b2 * k, n2);
      const c2 = divNearest2(-b1 * k, n2);
      let k1 = mod2(k - c1 * a1 - c2 * a2, n2);
      let k2 = mod2(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2563);
var _0n11 = BigInt(0);
var fe2 = (x) => typeof x === "bigint" && _0n11 < x && x < secp256k1P2;
var ge2 = (x) => typeof x === "bigint" && _0n11 < x && x < secp256k1N2;
var TAGGED_HASH_PREFIXES2 = {};
function taggedHash2(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES2[tag];
  if (tagP === void 0) {
    const tagH = sha2563(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes4(tagH, tagH);
    TAGGED_HASH_PREFIXES2[tag] = tagP;
  }
  return sha2563(concatBytes4(tagP, ...messages));
}
var pointToBytes2 = (point) => point.toRawBytes(true).slice(1);
var numTo32b2 = (n2) => numberToBytesBE2(n2, 32);
var modP2 = (x) => mod2(x, secp256k1P2);
var modN2 = (x) => mod2(x, secp256k1N2);
var Point2 = secp256k12.ProjectivePoint;
var GmulAdd2 = (Q, a, b2) => Point2.BASE.multiplyAndAddUnsafe(Q, a, b2);
function schnorrGetExtPubKey2(priv) {
  let d_ = secp256k12.utils.normPrivateKeyToScalar(priv);
  let p = Point2.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN2(-d_);
  return { scalar, bytes: pointToBytes2(p) };
}
function lift_x2(x) {
  if (!fe2(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP2(x * x);
  const c = modP2(xx * x + BigInt(7));
  let y = sqrtMod2(c);
  if (y % _2n9 !== _0n11)
    y = modP2(-y);
  const p = new Point2(x, y, _1n11);
  p.assertValidity();
  return p;
}
function challenge2(...args) {
  return modN2(bytesToNumberBE2(taggedHash2("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey2(privateKey) {
  return schnorrGetExtPubKey2(privateKey).bytes;
}
function schnorrSign2(message, privateKey, auxRand = randomBytes4(32)) {
  const m = ensureBytes2("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey2(privateKey);
  const a = ensureBytes2("auxRand", auxRand, 32);
  const t = numTo32b2(d ^ bytesToNumberBE2(taggedHash2("BIP0340/aux", a)));
  const rand = taggedHash2("BIP0340/nonce", t, px, m);
  const k_ = modN2(bytesToNumberBE2(rand));
  if (k_ === _0n11)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey2(k_);
  const e = challenge2(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b2(modN2(k + e * d)), 32);
  if (!schnorrVerify2(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify2(signature, message, publicKey) {
  const sig = ensureBytes2("signature", signature, 64);
  const m = ensureBytes2("message", message);
  const pub = ensureBytes2("publicKey", publicKey, 32);
  try {
    const P = lift_x2(bytesToNumberBE2(pub));
    const r = bytesToNumberBE2(sig.subarray(0, 32));
    if (!fe2(r))
      return false;
    const s = bytesToNumberBE2(sig.subarray(32, 64));
    if (!ge2(s))
      return false;
    const e = challenge2(numTo32b2(r), pointToBytes2(P), m);
    const R = GmulAdd2(P, s, modN2(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr2 = (() => ({
  getPublicKey: schnorrGetPublicKey2,
  sign: schnorrSign2,
  verify: schnorrVerify2,
  utils: {
    randomPrivateKey: secp256k12.utils.randomPrivateKey,
    lift_x: lift_x2,
    pointToBytes: pointToBytes2,
    numberToBytesBE: numberToBytesBE2,
    bytesToNumberBE: bytesToNumberBE2,
    taggedHash: taggedHash2,
    mod: mod2
  }
}))();
var isoMap2 = (() => isogenyMap2(Fp2, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU2 = (() => mapToCurveSimpleSWU2(Fp2, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp2.create(BigInt("-11"))
}))();
var htf2 = (() => createHasher2(secp256k12.ProjectivePoint, (scalars) => {
  const { x, y } = mapSWU2(Fp2.create(scalars[0]));
  return isoMap2(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp2.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha2563
}))();
var hashToCurve2 = (() => htf2.hashToCurve)();
var encodeToCurve2 = (() => htf2.encodeToCurve)();

// node_modules/tronweb/lib/esm/utils/crypto.js
function normalizePrivateKeyBytes(priKeyBytes) {
  return hexStr2byteArray(byteArray2hexStr(priKeyBytes).padStart(64, "0"));
}
function getBase58CheckAddress(addressBytes) {
  const hash0 = SHA2563(addressBytes);
  const hash1 = SHA2563(hash0);
  let checkSum = hash1.slice(0, 4);
  checkSum = addressBytes.concat(checkSum);
  return encode58(checkSum);
}
function decodeBase58Address(base58Sting) {
  if (typeof base58Sting != "string")
    return false;
  if (base58Sting.length <= 4)
    return false;
  let address = decode58(base58Sting);
  if (base58Sting.length <= 4)
    return false;
  const len = address.length;
  const offset = len - 4;
  const checkSum = address.slice(offset);
  address = address.slice(0, offset);
  const hash0 = SHA2563(address);
  const hash1 = SHA2563(hash0);
  const checkSum1 = hash1.slice(0, 4);
  if (checkSum[0] == checkSum1[0] && checkSum[1] == checkSum1[1] && checkSum[2] == checkSum1[2] && checkSum[3] == checkSum1[3]) {
    return address;
  }
  throw new Error("Invalid address provided");
}
function signTransaction(priKeyBytes, transaction) {
  if (typeof priKeyBytes === "string")
    priKeyBytes = hexStr2byteArray(priKeyBytes);
  const txID = transaction.txID;
  const signature = ECKeySign(hexStr2byteArray(txID), priKeyBytes);
  if (Array.isArray(transaction.signature)) {
    if (!transaction.signature.includes(signature))
      transaction.signature.push(signature);
  } else
    transaction.signature = [signature];
  return transaction;
}
function ecRecover(signedData, signature) {
  signedData = "0x" + signedData.replace(/^0x/, "");
  signature = "0x" + signature.replace(/^0x/, "");
  const recovered = recoverAddress(arrayify(signedData), Signature.from(signature));
  const tronAddress = ADDRESS_PREFIX + recovered.substring(2);
  return tronAddress;
}
function arrayToBase64String(a) {
  return btoa(String.fromCharCode(...a));
}
function signBytes(privateKey, contents) {
  if (typeof privateKey === "string")
    privateKey = hexStr2byteArray(privateKey);
  const hashBytes = SHA2563(contents);
  const signBytes2 = ECKeySign(hashBytes, privateKey);
  return signBytes2;
}
function _signTypedData(domain, types, value, privateKey) {
  const key = `0x${privateKey.replace(/^0x/, "")}`;
  const signingKey = new SigningKey(key);
  const messageDigest = TypedDataEncoder2.hash(domain, types, value);
  const signature = signingKey.sign(messageDigest);
  const signatureHex = ["0x", signature.r.substring(2), signature.s.substring(2), Number(signature.v).toString(16)].join("");
  return signatureHex;
}
function getRowBytesFromTransactionBase64(base64Data) {
  const bytesDecode = base64DecodeFromString(base64Data);
  const transaction = globalThis.proto.protocol.Transaction.deserializeBinary(bytesDecode);
  const raw = transaction.getRawData();
  return raw.serializeBinary();
}
function genPriKey() {
  const priKey = secp256k12.utils.randomPrivateKey();
  let priKeyHex = byteArray2hexStr(priKey);
  priKeyHex = priKeyHex.padStart(64, "0");
  return hexStr2byteArray(priKeyHex);
}
function computeAddress2(pubBytes) {
  if (pubBytes.length === 65)
    pubBytes = pubBytes.slice(1);
  const hash3 = keccak256(new Uint8Array(pubBytes)).toString().substring(2);
  const addressHex = ADDRESS_PREFIX + hash3.substring(24);
  return hexStr2byteArray(addressHex);
}
function getAddressFromPriKey(priKeyBytes) {
  const pubBytes = getPubKeyFromPriKey(priKeyBytes);
  return computeAddress2(pubBytes);
}
function decode58Check(addressStr) {
  const decodeCheck = decode58(addressStr);
  if (decodeCheck.length <= 4)
    return false;
  const decodeData = decodeCheck.slice(0, decodeCheck.length - 4);
  const hash0 = SHA2563(decodeData);
  const hash1 = SHA2563(hash0);
  if (hash1[0] === decodeCheck[decodeData.length] && hash1[1] === decodeCheck[decodeData.length + 1] && hash1[2] === decodeCheck[decodeData.length + 2] && hash1[3] === decodeCheck[decodeData.length + 3]) {
    return decodeData;
  }
  return false;
}
function isAddressValid(base58Str) {
  if (typeof base58Str !== "string")
    return false;
  if (base58Str.length !== ADDRESS_SIZE)
    return false;
  let address = decode58(base58Str);
  if (address.length !== 25)
    return false;
  if (address[0] !== ADDRESS_PREFIX_BYTE)
    return false;
  const checkSum = address.slice(21);
  address = address.slice(0, 21);
  const hash0 = SHA2563(address);
  const hash1 = SHA2563(hash0);
  const checkSum1 = hash1.slice(0, 4);
  if (checkSum[0] == checkSum1[0] && checkSum[1] == checkSum1[1] && checkSum[2] == checkSum1[2] && checkSum[3] == checkSum1[3]) {
    return true;
  }
  return false;
}
function getBase58CheckAddressFromPriKeyBase64String(priKeyBase64String) {
  const priKeyBytes = base64DecodeFromString(priKeyBase64String);
  const pubBytes = getPubKeyFromPriKey(priKeyBytes);
  const addressBytes = computeAddress2(pubBytes);
  return getBase58CheckAddress(addressBytes);
}
function getHexStrAddressFromPriKeyBase64String(priKeyBase64String) {
  const priKeyBytes = base64DecodeFromString(priKeyBase64String);
  const pubBytes = getPubKeyFromPriKey(priKeyBytes);
  const addressBytes = computeAddress2(pubBytes);
  const addressHex = byteArray2hexStr(addressBytes);
  return addressHex;
}
function getAddressFromPriKeyBase64String(priKeyBase64String) {
  const priKeyBytes = base64DecodeFromString(priKeyBase64String);
  const pubBytes = getPubKeyFromPriKey(priKeyBytes);
  const addressBytes = computeAddress2(pubBytes);
  const addressBase64 = base64EncodeToString(addressBytes);
  return addressBase64;
}
function getPubKeyFromPriKey(priKeyBytes) {
  const pubkey = secp256k12.ProjectivePoint.fromPrivateKey(new Uint8Array(normalizePrivateKeyBytes(priKeyBytes)));
  const x = pubkey.x;
  const y = pubkey.y;
  const xHex = x.toString(16).padStart(64, "0");
  const yHex = y.toString(16).padStart(64, "0");
  const pubkeyHex = `04${xHex}${yHex}`;
  const pubkeyBytes = hexStr2byteArray(pubkeyHex);
  return pubkeyBytes;
}
function ECKeySign(hashBytes, priKeyBytes) {
  const signature = secp256k12.sign(byteArray2hexStr(hashBytes), byteArray2hexStr(priKeyBytes));
  const r = signature.r.toString(16);
  const s = signature.s.toString(16);
  const v = signature.recovery + 27;
  return r.padStart(64, "0") + s.padStart(64, "0") + byte2hexStr(v);
}
function SHA2563(msgBytes) {
  const msgHex = byteArray2hexStr(msgBytes);
  const hashHex = sha2562("0x" + msgHex).replace(/^0x/, "");
  return hexStr2byteArray(hashHex);
}
function passwordToAddress(password) {
  const com_priKeyBytes = base64DecodeFromString(password);
  const com_addressBytes = getAddressFromPriKey(com_priKeyBytes);
  return getBase58CheckAddress(com_addressBytes);
}
function pkToAddress(privateKey, strict = false) {
  const com_priKeyBytes = hexStr2byteArray(privateKey, strict);
  const com_addressBytes = getAddressFromPriKey(com_priKeyBytes);
  return getBase58CheckAddress(com_addressBytes);
}
function sha32(string, prefix = true) {
  return (prefix ? "0x" : "") + keccak256(Buffer.from(string, "utf-8")).toString().substring(2);
}

// node_modules/tronweb/lib/esm/utils/accounts.js
var INVALID_TRON_PATH_ERROR_MSG = "Invalid tron path provided";
function generateAccount() {
  const priKeyBytes = genPriKey();
  const pubKeyBytes = getPubKeyFromPriKey(priKeyBytes);
  const addressBytes = getAddressFromPriKey(priKeyBytes);
  const privateKey = byteArray2hexStr(priKeyBytes);
  const publicKey = byteArray2hexStr(pubKeyBytes);
  return {
    privateKey,
    publicKey,
    address: {
      base58: getBase58CheckAddress(addressBytes),
      hex: byteArray2hexStr(addressBytes)
    }
  };
}
function generateRandom(password = "", path = TRON_BIP39_PATH_INDEX_0, wordlist2) {
  const account = HDNodeWallet.createRandom(password, path, wordlist2);
  const result = {
    mnemonic: account.mnemonic,
    privateKey: account.privateKey,
    publicKey: account.signingKey.publicKey,
    address: pkToAddress(account.privateKey.replace(/^0x/, "")),
    path: account.path
  };
  return result;
}
function generateAccountWithMnemonic(mnemonic, path = TRON_BIP39_PATH_INDEX_0, password = "", wordlist2 = null) {
  if (!String(path).match(/^m\/44\'\/195\'/)) {
    throw new Error(INVALID_TRON_PATH_ERROR_MSG);
  }
  const account = HDNodeWallet.fromMnemonic(Mnemonic.fromPhrase(mnemonic, password, wordlist2), path);
  const result = {
    mnemonic: account.mnemonic,
    privateKey: account.privateKey,
    publicKey: account.signingKey.publicKey,
    address: pkToAddress(account.privateKey.replace(/^0x/, ""))
  };
  return result;
}

// node_modules/tronweb/lib/esm/utils/message.js
var message_exports = {};
__export(message_exports, {
  TRON_MESSAGE_PREFIX: () => TRON_MESSAGE_PREFIX,
  hashMessage: () => hashMessage2,
  signMessage: () => signMessage,
  verifyMessage: () => verifyMessage2
});
var TRON_MESSAGE_PREFIX = "TRON Signed Message:\n";
function hashMessage2(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  } else if (Array.isArray(message)) {
    message = new Uint8Array(message);
  }
  return keccak256(concat([toUtf8Bytes(TRON_MESSAGE_PREFIX), toUtf8Bytes(String(message.length)), message]));
}
function signMessage(message, privateKey) {
  if (!privateKey.match(/^0x/)) {
    privateKey = "0x" + privateKey;
  }
  const signingKey = new SigningKey(privateKey);
  const messageDigest = hashMessage2(message);
  const signature = signingKey.sign(messageDigest);
  return joinSignature(signature);
}
function verifyMessage2(message, signature) {
  if (!signature.match(/^0x/)) {
    signature = "0x" + signature;
  }
  const recovered = recoverAddress(hashMessage2(message), signature);
  const base58Address = getBase58CheckAddress(hexStr2byteArray(recovered.replace(/^0x/, ADDRESS_PREFIX)));
  return base58Address;
}

// node_modules/tronweb/lib/esm/utils/index.js
var utils = {
  ...validations_exports,
  address: address_exports,
  code: code_exports,
  accounts: accounts_exports,
  base58: base58_exports,
  bytes: bytes_exports,
  crypto: crypto_exports,
  abi: abi_exports,
  message: message_exports,
  _TypedDataEncoder: TypedDataEncoder2,
  transaction: transaction_exports,
  ethersUtils: ethersUtils_exports
};
var utils_default2 = utils;

// node_modules/tronweb/lib/esm/types/index.js
var types_exports = {};
__export(types_exports, {
  AccountType: () => AccountType,
  ContractType: () => ContractType,
  Permission_PermissionType: () => Permission_PermissionType,
  ResourceCode: () => ResourceCode2
});

// node_modules/tronweb/lib/esm/types/Trx.js
var ResourceCode2;
(function(ResourceCode3) {
  ResourceCode3[ResourceCode3["BANDWIDTH"] = 0] = "BANDWIDTH";
  ResourceCode3[ResourceCode3["ENERGY"] = 1] = "ENERGY";
  ResourceCode3[ResourceCode3["TRON_POWER"] = 2] = "TRON_POWER";
})(ResourceCode2 || (ResourceCode2 = {}));
var TransactionSignWeight_response_code;
(function(TransactionSignWeight_response_code2) {
  TransactionSignWeight_response_code2["ENOUGH_PERMISSION"] = "ENOUGH_PERMISSION";
  TransactionSignWeight_response_code2["NOT_ENOUGH_PERMISSION"] = "NOT_ENOUGH_PERMISSION";
  TransactionSignWeight_response_code2["SIGNATURE_FORMAT_ERROR"] = "SIGNATURE_FORMAT_ERROR";
  TransactionSignWeight_response_code2["COMPUTE_ADDRESS_ERROR"] = "COMPUTE_ADDRESS_ERROR";
  TransactionSignWeight_response_code2["PERMISSION_ERROR"] = "PERMISSION_ERROR";
  TransactionSignWeight_response_code2["OTHER_ERROR"] = "OTHER_ERROR";
})(TransactionSignWeight_response_code || (TransactionSignWeight_response_code = {}));
var BroadcastReturn_response_code;
(function(BroadcastReturn_response_code2) {
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["SUCCESS"] = 0] = "SUCCESS";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["SIGERROR"] = 1] = "SIGERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["CONTRACT_VALIDATE_ERROR"] = 2] = "CONTRACT_VALIDATE_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["CONTRACT_EXE_ERROR"] = 3] = "CONTRACT_EXE_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["BANDWITH_ERROR"] = 4] = "BANDWITH_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["DUP_TRANSACTION_ERROR"] = 5] = "DUP_TRANSACTION_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["TAPOS_ERROR"] = 6] = "TAPOS_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["TOO_BIG_TRANSACTION_ERROR"] = 7] = "TOO_BIG_TRANSACTION_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["TRANSACTION_EXPIRATION_ERROR"] = 8] = "TRANSACTION_EXPIRATION_ERROR";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["SERVER_BUSY"] = 9] = "SERVER_BUSY";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["NO_CONNECTION"] = 10] = "NO_CONNECTION";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["NOT_ENOUGH_EFFECTIVE_CONNECTION"] = 11] = "NOT_ENOUGH_EFFECTIVE_CONNECTION";
  BroadcastReturn_response_code2[BroadcastReturn_response_code2["OTHER_ERROR"] = 20] = "OTHER_ERROR";
})(BroadcastReturn_response_code || (BroadcastReturn_response_code = {}));
var ProposalState;
(function(ProposalState2) {
  ProposalState2[ProposalState2["PENDING"] = 0] = "PENDING";
  ProposalState2[ProposalState2["DISAPPROVED"] = 1] = "DISAPPROVED";
  ProposalState2[ProposalState2["APPROVED"] = 2] = "APPROVED";
  ProposalState2[ProposalState2["CANCELED"] = 3] = "CANCELED";
})(ProposalState || (ProposalState = {}));

// node_modules/tronweb/lib/esm/index.js
var esm_default = {
  utils: utils_default2,
  BigNumber,
  providers,
  TransactionBuilder,
  Trx,
  Contract: Contract2,
  Method,
  Event,
  Plugin,
  TronWeb,
  Types: types_exports
};
export {
  BigNumber,
  Contract2 as Contract,
  Event,
  Method,
  Plugin,
  TransactionBuilder,
  TronWeb,
  Trx,
  types_exports as Types,
  esm_default as default,
  providers,
  utils_default2 as utils
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

aes-js/lib.esm/aes.js:
  (*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. *)
*/
//# sourceMappingURL=tronweb.js.map
